<sn><md>### **Index**
---

- About
- **Chapter 1: Getting started with JavaScript**
    - Section 1.1: Using console.log()
    - Section 1.2: Using the DOM API
    - Section 1.3: Using window.alert()
    - Section 1.4: Using window.prompt()
    - Section 1.5: Using window.confirm()
    - Section 1.6: Using the DOM API (with graphical text: Canvas, SVG, or image file)
- **Chapter 2: JavaScript Variables**
    - Section 2.1: Defining a Variable
    - Section 2.2: Using a Variable
    - Section 2.3: Types of Variables
    - Section 2.4: Arrays and Objects
- **Chapter 3: Built-in Constants**
    - Section 3.1: null
    - Section 3.2: Testing for NaN using isNaN()
    - Section 3.3: NaN
    - Section 3.4: undefined and null
    - Section 3.5: Infinity and -Infinity
    - Section 3.6: Number constants
    - Section 3.7: Operations that return NaN
    - Section 3.8: Math library functions that return NaN
- **Chapter 4: Comments**
    - Section 4.1: Using Comments
    - Section 4.2: Using HTML comments in JavaScript (Bad practice)
- **Chapter 5: Console**
    - Section 5.1: Measuring time - console.time()
    - Section 5.2: Formatting console output
    - Section 5.3: Printing to a browser's debugging console
    - Section 5.4: Including a stack trace when logging - console.trace()
    - Section 5.5: Tabulating values - console.table()
    - Section 5.6: Counting - console.count()
    - Section 5.7: Clearing the console - console.clear()
    - Section 5.8: Displaying objects and XML interactively - console.dir(), console.dirxml()
    - Section 5.9: Debugging with assertions - console.assert()
- **Chapter 6: Datatypes in JavaScript**
    - Section 6.1: typeof
    - Section 6.2: Finding an object's class
    - Section 6.3: Getting object type by constructor name
- **Chapter 7: Strings**
    - Section 7.1: Basic Info and String Concatenation
    - Section 7.2: Reverse String
    - Section 7.3: Comparing Strings Lexicographically
    - Section 7.4: Access character at index in string
    - Section 7.5: Escaping quotes
    - Section 7.6: Word Counter
    - Section 7.8: Splitting a string into an array
    - Section 7.9: Strings are unicode
    - Section 7.10: Detecting a string
    - Section 7.11: Substrings with slice
    - Section 7.12: Character code
    - Section 7.13: String Representations of Numbers
    - Section 7.14: String Find and Replace Functions
    - Section 7.15: Find the index of a substring inside a string
    - Section 7.16: String to Upper Case
    - Section 7.17: String to Lower Case
    - Section 7.18: Repeat a String
- **Chapter 8: Date**
    - Section 8.1: Create a new Date object
    - Section 8.2: Convert to a string format
    - Section 8.3: Creating a Date from UTC
    - Section 8.4: Formatting a JavaScript date
    - Section 8.5: Get the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC
    - Section 8.6: Get the current time and date
    - Section 8.7: Increment a Date Object
    - Section 8.8: Convert to JSON
- **Chapter 9: Date Comparison**
    - Section 9.1: Comparing Date values
    - Section 9.2: Date Difference Calculation
- **Chapter 10: Comparison Operations**
    - Section 10.1: Abstract equality / inequality and type conversion
    - Section 10.2: NaN Property of the Global Object
    - Section 10.3: Short-circuiting in boolean operators
    - Section 10.4: Null and Undefined
    - Section 10.5: Abstract Equality (==)
    - Section 10.6: Logic Operators with Booleans
    - Section 10.7: Automatic Type Conversions
    - Section 10.8: Logic Operators with Non-boolean values (boolean coercion)
    - Section 10.9: Empty Array
    - Section 10.10: Equality comparison operations
    - Section 10.11: Relational operators (&lt;, &lt;=, &gt;, &gt;=)
    - Section 10.12: Inequality
    - Section 10.13: List of Comparison Operators
    - Section 10.14: Grouping multiple logic statements
    - Section 10.15: Bit fields to optimise comparison of multi state data
- **Chapter 11: Conditions**
    - Section 11.1: Ternary operators
    - Section 11.2: Switch statement
    - Section 11.3: If / Else If / Else Control
    - Section 11.4: Strategy
    - Section 11.5: Using || and &amp;&amp; short circuiting
- **Chapter 12: Arrays**
    - Section 12.1: Converting Array-like Objects to Arrays
    - Section 12.2: Reducing values
    - Section 12.3: Mapping values
    - Section 12.5: Sorting Arrays
    - Section 12.6: Iteration
    - Section 12.7: Destructuring an array
    - Section 12.8: Removing duplicate elements
    - Section 12.9: Array comparison
    - Section 12.10: Reversing arrays
    - Section 12.11: Shallow cloning an array
    - Section 12.12: Concatenating Arrays
    - Section 12.13: Merge two array as key value pair
    - Section 12.14: Array spread / rest
    - Section 12.15: Filtering values
    - Section 12.16: Searching an Array
    - Section 12.17: Convert a String to an Array
    - Section 12.18: Removing items from an array
    - Section 12.19: Removing all elements
    - Section 12.20: Finding the minimum or maximum element
    - Section 12.21: Standard array initialization
    - Section 12.22: Joining array elements in a string
    - Section 12.23: Removing/Adding elements using splice()
    - Section 12.24: The entries() method
    - Section 12.25: Remove value from array
    - Section 12.26: Flattening Arrays
    - Section 12.27: Append / Prepend items to Array
    - Section 12.28: Object keys and values to array
    - Section 12.29: Logical connective of values
    - Section 12.30: Checking if an object is an Array
    - Section 12.31: Insert an item into an array at a specific index
    - Section 12.32: Sorting multidimensional array
    - Section 12.33: Test all array items for equality
    - Section 12.34: Copy part of an Array
- **Chapter 13: Objects**
    - Section 13.1: Shallow cloning
    - Section 13.2: Object.freeze
    - Section 13.3: Object cloning
    - Section 13.4: Object properties iteration
    - Section 13.5: Object.assign
    - Section 13.6: Object rest/spread (...)
    - Section 13.7: Object.defineProperty
    - Section 13.8: Accesor properties (get and set)
    - Section 13.9: Dynamic / variable property names
    - Section 13.10: Arrays are Objects
    - Section 13.11: Object.seal
    - Section 13.12: Convert object's values to array
    - Section 13.13: Retrieving properties from an object
    - Section 13.14: Read-Only property
    - Section 13.15: Non enumerable property
    - Section 13.16: Lock property description
    - Section 13.17: Object.getOwnPropertyDescriptor
    - Section 13.18: Descriptors and Named Properties
    - Section 13.19: Object.keys
    - Section 13.21: Creating an Iterable object
    - Section 13.22: Iterating over Object entries - Object.entries()
    - Section 13.23: Object.values()
- **Chapter 14: Arithmetic (Math)**
    - Section 14.1: Constants
    - Section 14.2: Remainder / Modulus (%)
    - Section 14.3: Rounding
    - Section 14.4: Trigonometry
    - Section 14.5: Bitwise operators
    - Section 14.6: Incrementing (++)
    - Section 14.7: Exponentiation (Math.pow() or **)
    - Section 14.8: Random Integers and Floats
    - Section 14.9: Addition (+)
    - Section 14.10: Little / Big endian for typed arrays when using bitwise operators
    - Section 14.11: Get Random Between Two Numbers
    - Section 14.12: Simulating events with different probabilities
    - Section 14.13: Subtraction (-)
    - Section 14.14: Multiplication (*)
    - Section 14.15: Getting maximum and minimum
    - Section 14.16: Restrict Number to Min/Max Range
    - Section 14.17: Ceiling and Floor
    - Section 14.18: Getting roots of a number
    - Section 14.19: Random with gaussian distribution
    - Section 14.20: Math.atan2 to find direction
    - Section 14.21: Sin &amp; Cos to create a vector given direction &amp; distance
    - Section 14.22: Math.hypot
    - Section 14.23: Periodic functions using Math.sin
    - Section 14.24: Division (/)
    - Section 14.25: Decrementing (--)
- **Chapter 15: Bitwise operators**
    - Section 15.1: Bitwise operators
    - Section 15.2: Shift Operators
- **Chapter 16: Constructor functions**
    - Section 16.1: Declaring a constructor function
- **Chapter 17: Declarations and Assignments**
    - Section 17.1: Modifying constants
    - Section 17.2: Declaring and initializing constants
    - Section 17.3: Declaration
    - Section 17.4: Undefined
    - Section 17.5: Data Types
    - Section 17.6: Mathematic operations and assignment
    - Section 17.7: Assignment
- **Chapter 18: Loops**
    - Section 18.1: Standard "for" loops
    - Section 18.2: "for ... of" loop
    - Section 18.3: "for ... in" loop
    - Section 18.4: "while" Loops
    - Section 18.5: "continue" a loop
    - Section 18.6: Break specific nested loops
    - Section 18.8: Break and continue labels
- **Chapter 19: Functions**
    - Section 19.1: Function Scoping
    - Section 19.2: Currying
    - Section 19.3: Immediately Invoked Function Expressions
    - Section 19.4: Named Functions
    - Section 19.5: Binding `this` and arguments
    - Section 19.6: Functions with an Unknown Number of Arguments (variadic functions)
    - Section 19.7: Anonymous Function
    - Section 19.8: Default parameters
    - Section 19.9: Call and apply
    - Section 19.10: Partial Application
    - Section 19.11: Passing arguments by reference or value
    - Section 19.12: Function Arguments, "arguments" object, rest and spread parameters
    - Section 19.13: Function Composition
    - Section 19.14: Get the name of a function object
    - Section 19.15: Recursive Function
    - Section 19.16: Using the Return Statement
    - Section 19.17: Functions as a variable
- **Chapter 21: Prototypes, objects**
    - Section 21.1: Creation and initialising Prototype
- **Chapter 22: Classes**
    - Section 22.1: Class Constructor
    - Section 22.2: Class Inheritance
    - Section 22.3: Static Methods
    - Section 22.4: Getters and Setters
    - Section 22.5: Private Members
    - Section 22.6: Methods
    - Section 22.7: Dynamic Method Names
    - Section 22.8: Managing Private Data with Classes
    - Section 22.9: Class Name binding
- **Chapter 23: Namespacing**
    - Section 23.1: Namespace by direct assignment
    - Section 23.2: Nested Namespaces
- **Chapter 24: Context (this)**
    - Section 24.1: this with simple objects
    - Section 24.2: Saving this for use in nested functions / objects
    - Section 24.3: Binding function context
    - Section 24.4: this in constructor functions
- **Chapter 25: Setters and Getters**
    - Section 25.1: Defining a Setter/Getter Using Object.defineProperty
    - Section 25.2: Defining an Setter/Getter in a Newly Created Object
    - Section 25.3: Defining getters and setters in ES6 class
- **Chapter 26:**
    - Section 26.1: Page, DOM and Browser loading
- **Chapter 27: Inheritance**
    - Section 27.1: Standard function prototype
    - Section 27.2: Difference between Object.key and Object.prototype.key
    - Section 27.3: Prototypal inheritance
    - Section 27.4: Pseudo-classical inheritance
    - Section 27.5: Setting an Object's prototype
- **Chapter 28: Method Chaining**
    - Section 28.1: Chainable object design and chaining
    - Section 28.2: Method Chaining
- **Chapter 29: Callbacks**
    - Section 29.1: Simple Callback Usage Examples
    - Section 29.2: Continuation (synchronous and asynchronous)
    - Section 29.3: What is a callback?
    - Section 29.4: Callbacks and `this`
    - Section 29.5: Callback using Arrow function
    - Section 29.6: Error handling and control-flow branching
- **Chapter 30: Intervals and Timeouts**
    - Section 30.1: Recursive setTimeout
    - Section 30.2: Intervals
    - Section 30.3: Intervals
    - Section 30.4: Removing intervals
    - Section 30.5: Removing timeouts
    - Section 30.6: setTimeout, order of operations, clearTimeout
- **Chapter 31: Regular expressions**
    - Section 31.1: Creating a RegExp Object
    - Section 31.2: RegExp Flags
    - Section 31.3: Check if string contains pattern using .test()
    - Section 31.4: Matching With .exec()
    - Section 31.5: Using RegExp With Strings
    - Section 31.6: RegExp Groups
    - Section 31.7: Replacing string match with a callback function
    - Section 31.8: Using Regex.exec() with parentheses regex to extract matches of a string
- **Chapter 32: Cookies**
    - Section 32.1: Test if cookies are enabled
    - Section 32.2: Adding and Setting Cookies
    - Section 32.3: Reading cookies
    - Section 32.4: Removing cookies
- **Chapter 33: Web Storage**
    - Section 33.1: Using localStorage
    - Section 33.2: Simpler way of handling Storage
    - Section 33.3: Storage events
    - Section 33.4: sessionStorage
    - Section 33.5: localStorage length
    - Section 33.6: Error conditions
    - Section 33.7: Clearing storage
    - Section 33.8: Remove Storage Item
- **Chapter 34: Data attributes**
- **Chapter 35: JSON**
    - Section 35.1: JSON versus JavaScript literals
    - Section 35.2: Parsing with a reviver function
    - Section 35.3: Serializing a value
    - Section 35.4: Serializing and restoring class instances
    - Section 35.5: Serializing with a replacer function
    - Section 35.6: Parsing a simple JSON string
    - Section 35.7: Cyclic object values
- **Chapter 36: AJAX**
    - Section 36.1: Sending and Receiving JSON Data via POST
    - Section 36.2: Add an AJAX preloader
    - Section 36.3: Displaying the top JavaScript questions of the month from Stack Overflow's API
    - Section 36.4: Using GET with parameters
    - Section 36.5: Check if a file exists via a HEAD request
    - Section 36.6: Using GET and no parameters
    - Section 36.7: Listening to AJAX events at a global level
- **Chapter 37: Enumerations**
    - Section 37.1: Enum definition using Object.freeze()
    - Section 37.2: Alternate definition
    - Section 37.3: Printing an enum variable
    - Section 37.4: Implementing Enums Using Symbols
    - Section 37.5: Automatic Enumeration Value
- **Chapter 38: Map**
    - Section 38.1: Creating a Map
    - Section 38.2: Clearing a Map
    - Section 38.3: Removing an element from a Map
    - Section 38.4: Checking if a key exists in a Map
    - Section 38.5: Iterating Maps
    - Section 38.6: Getting and setting elements
    - Section 38.7: Getting the number of elements of a Map
- **Chapter 39: Timestamps**
    - Section 39.1: High-resolution timestamps
    - Section 39.2: Get Timestamp in Seconds
    - Section 39.3: Low-resolution timestamps
    - Section 39.4: Support for legacy browsers
- **Chapter 40: Unary Operators**
    - Section 40.1: Overview
    - Section 40.2: The typeof operator
    - Section 40.3: The delete operator
    - Section 40.4: The unary plus operator (+)
    - Section 40.5: The void operator
    - Section 40.6: The unary negation operator (-)
    - Section 40.7: The bitwise NOT operator (~)
    - Section 40.8: The logical NOT operator (!)
- **Chapter 41: Generators**
    - Section 41.1: Generator Functions
    - Section 41.2: Sending Values to Generator
    - Section 41.3: Delegating to other Generator
    - Section 41.5: Async flow with generators
    - Section 41.6: Iterator-Observer interface
- **Chapter 42: Promises**
    - Section 42.1: Introduction
    - Section 42.2: Promise chaining
    - Section 42.3: Waiting for multiple concurrent promises
    - Section 42.4: Reduce an array to chained promises
    - Section 42.5: Waiting for the first of multiple concurrent promises
    - Section 42.6: "Promisifying" functions with callbacks
    - Section 42.7: Error Handling
    - Section 42.8: Reconciling synchronous and asynchronous operations
    - Section 42.9: Delay function call
    - Section 42.10: "Promisifying" values
    - Section 42.11: Using ES2017 async/await
    - Section 42.12: Performing cleanup with finally()
    - Section 42.13: forEach with promises
    - Section 42.14: Asynchronous API request
- **Chapter 43: Set**
    - Section 43.1: Creating a Set
    - Section 43.2: Adding a value to a Set
    - Section 43.3: Removing value from a set
    - Section 43.4: Checking if a value exist in a set
    - Section 43.5: Clearing a Set
    - Section 43.6: Getting set length
    - Section 43.7: Converting Sets to arrays
    - Section 43.8: Intersection and difference in Sets
    - Section 43.9: Iterating Sets
- **Chapter 45: execCommand and contenteditable**
    - Section 45.1: Listening to Changes of contenteditable
    - Section 45.2: Getting started
    - Section 45.3: Copy to clipboard from textarea using execCommand("copy")
    - Section 45.4: Formatting
- **Chapter 46: History**
    - Section 46.1: history.pushState()
    - Section 46.2: history.replaceState()
    - Section 46.3: Load a specific URL from the history list
- **Chapter 47: Navigator Object**
    - Section 47.1: Get some basic browser data and return it as a JSON object
- **Chapter 48: BOM (Browser Object Model)**
    - Section 48.1: Introduction
    - Section 48.2: Window Object Properties
    - Section 48.3: Window Object Methods
- **Chapter 49:**
    - Section 49.1: The event loop in a web browser
    - Section 49.2: Asynchronous operations and the event loop
- **Chapter 50: Strict mode**
    - Section 50.1: For entire scripts
    - Section 50.2: For functions
    - Section 50.3: Changes to properties
    - Section 50.4: Changes to global properties
    - Section 50.5: Duplicate Parameters
    - Section 50.6: Function scoping in strict mode
    - Section 50.7: Behaviour of a function's arguments list
    - Section 50.8: Non-Simple parameter lists
- **Chapter 51: Custom Elements**
    - Section 51.1: Extending Native Elements
    - Section 51.2: Registering New Elements
- **Chapter 52: Data Manipulation**
    - Section 52.1: Format numbers as money
    - Section 52.2: Extract extension from file name
    - Section 52.3: Set object property given its string name
- **Chapter 53: Binary Data**
    - Section 53.1: Getting binary representation of an image file
    - Section 53.2: Converting between Blobs and ArrayBuffers
    - Section 53.3: Manipulating ArrayBuffers with DataViews
    - Section 53.4: Creating a TypedArray from a Base64 string
    - Section 53.5: Using TypedArrays
    - Section 53.6: Iterating through an arrayBuffer
- **Chapter 54: Template Literals**
    - Section 54.1: Basic interpolation and multiline strings
    - Section 54.2: Tagged strings
    - Section 54.3: Raw strings
    - Section 54.4: Templating HTML With Template Strings
    - Section 54.5: Introduction
- **Chapter 55: Fetch**
    - Section 55.1: Getting JSON data
    - Section 55.2: Set Request Headers
    - Section 55.3: POST Data
    - Section 55.4: Send cookies
    - Section 55.5: GlobalFetch
    - Section 55.6: Using Fetch to Display Questions from the Stack Overflow API
- **Chapter 56: Scope**
    - Section 56.1: Closures
    - Section 56.2: Hoisting
    - Section 56.3: Difference between var and let
    - Section 56.4: Apply and Call syntax and invocation
    - Section 56.5: Arrow function invocation
    - Section 56.6: Bound invocation
    - Section 56.7: Method invocation
    - Section 56.8: Anonymous invocation
    - Section 56.9: Constructor invocation
- **Chapter 57: Modules**
    - Section 57.1: Defining a module
    - Section 57.2: Default exports
    - Section 57.3: Importing named members from another module
    - Section 57.4: Importing an entire module
    - Section 57.5: Importing named members with aliases
    - Section 57.6: Importing with side effects
    - Section 57.7: Exporting multiple named members
- **Chapter 58: Screen**
    - Section 58.1: Getting the screen resolution
    - Section 58.2: Getting the “available” area of the screen
    - Section 58.3: Page width and height
    - Section 58.4: Window innerWidth and innerHeight Properties
    - Section 58.5: Getting color information about the screen
- **Chapter 59: Variable coercion/conversion**
    - Section 59.1: Double Negation (!!x)
    - Section 59.2: Implicit conversion
    - Section 59.3: Converting to boolean
    - Section 59.4: Converting a string to a number
    - Section 59.5: Converting a number to a string
    - Section 59.6: Primitive to Primitive conversion table
    - Section 59.7: Convert an array to a string
    - Section 59.8: Array to String using array methods
    - Section 59.9: Converting a number to a boolean
    - Section 59.10: Converting a string to a boolean
    - Section 59.11: Integer to Float
    - Section 59.12: Float to Integer
    - Section 59.13: Convert string to float
- **Chapter 60: Destructuring assignment**
    - Section 60.1: Destructuring Objects
    - Section 60.2: Destructuring function arguments
    - Section 60.3: Nested Destructuring
    - Section 60.4: Destructuring Arrays
    - Section 60.5: Destructuring inside variables
    - Section 60.6: Default Value While Destructuring
    - Section 60.7: Renaming Variables While Destructuring
- **Chapter 61: WebSockets**
    - Section 61.1: Working with string messages
    - Section 61.2: Establish a web socket connection
    - Section 61.3: Working with binary messages
    - Section 61.4: Making a secure web socket connection
- **Chapter 62: Arrow Functions**
    - Section 62.1: Introduction
    - Section 62.2: Lexical Scoping &amp; Binding (Value of "this")
    - Section 62.3: Arguments Object
    - Section 62.4: Implicit Return
    - Section 62.5: Arrow functions as a constructor
    - Section 62.6: Explicit Return
- **Chapter 64: requestAnimationFrame**
    - Section 64.1: Use requestAnimationFrame to fade in element
    - Section 64.2: Keeping Compatibility
    - Section 64.3: Cancelling an Animation
- **Chapter 65: Creational Design Patterns**
    - Section 65.1: Factory Functions
    - Section 65.2: Factory with Composition
    - Section 65.3: Module and Revealing Module Patterns
    - Section 65.4: Prototype Pattern
    - Section 65.5: Singleton Pattern
    - Section 65.6: Abstract Factory Pattern
- **Chapter 66: Detecting browser**
    - Section 66.1: Feature Detection Method
    - Section 66.2: User Agent Detection
    - Section 66.3: Library Method
- **Chapter 67: Symbols**
    - Section 67.1: Basics of symbol primitive type
    - Section 67.2: Using Symbol.for() to create global, shared symbols
    - Section 67.3: Converting a symbol into a string
- **Chapter 68: Transpiling**
    - Section 68.1: Introduction to Transpiling
    - Section 68.2: Start using ES6/7 with Babel
- **Chapter 69: Automatic Semicolon Insertion - ASI**
    - Section 69.1: Avoid semicolon insertion on return statements
    - Section 69.2: Rules of Automatic Semicolon Insertion
    - Section 69.3: Statements affected by automatic semicolon insertion
- **Chapter 70: Localization**
    - Section 70.1: Number formatting
    - Section 70.2: Currency formatting
    - Section 70.3: Date and time formatting
- **Chapter 72: IndexedDB**
    - Section 72.1: Opening a database
    - Section 72.2: Adding objects
    - Section 72.3: Retrieving data
    - Section 72.4: Testing for IndexedDB availability
- **Chapter 73: Modularization Techniques**
    - Section 73.1: ES6 Modules
    - Section 73.3: Immediately invoked function expressions (IIFE)
    - Section 73.4: Asynchronous Module Definition (AMD)
    - Section 73.5: CommonJS - Node.js
- **Chapter 74: Proxy**
    - Section 74.1: Proxying property lookup
    - Section 74.2: Very simple proxy (using the set trap)
- **Chapter 75: .postMessage() and MessageEvent**
    - Section 75.1: Getting Started
- **Chapter 76: WeakMap**
    - Section 76.1: Creating a WeakMap object
    - Section 76.2: Getting a value associated to the key
    - Section 76.3: Assigning a value to the key
    - Section 76.4: Checking if an element with the key exists
    - Section 76.5: Removing an element with the key
    - Section 76.6: Weak reference demo
- **Chapter 77: WeakSet**
    - Section 77.1: Creating a WeakSet object
    - Section 77.2: Adding a value
    - Section 77.3: Checking if a value exists
    - Section 77.4: Removing a value
- **Chapter 78: Escape Sequences**
    - Section 78.1: Entering special characters in strings and regular expressions
    - Section 78.2: Escape sequence types
- **Chapter 79: Behavioral Design Patterns**
    - Section 79.1: Observer pattern
    - Section 79.2: Mediator Pattern
    - Section 79.3: Command
    - Section 79.4: Iterator
- **Chapter 80: Server-sent events**
    - Section 80.1: Setting up a basic event stream to the server
    - Section 80.2: Closing an event stream
    - Section 80.3: Binding event listeners to EventSource
- **Chapter 81: Async functions (async/await)**
    - Section 81.1: Introduction
    - Section 81.2: Await and operator precedence
    - Section 81.3: Async functions compared to Promises
    - Section 81.4: Looping with async await
    - Section 81.5: Less indentation
    - Section 81.6: Simultaneous async (parallel) operations
- **Chapter 82: Async Iterators**
    - Section 82.1: Basics
- **Chapter 83: How to make iterator usable inside async callback function**
    - Section 83.1: Erroneous code, can you spot why this usage of key will lead to bugs?
    - Section 83.2: Correct Writing
- **Chapter 86: Tilde ~**
    - Section 86.1: ~ Integer
    - Section 86.2: ~~ Operator
    - Section 86.3: Converting Non-numeric values to Numbers
    - Section 86.4: Shorthands
    - Section 86.5: ~ Decimal
- **Chapter 87: Using JavaScript to get/set CSS custom variables**
    - Section 87.1: How to get and set CSS variable property values
- **Chapter 88: Selection API**
    - Section 88.1: Get the text of the selection
    - Section 88.2: Deselect everything that is selected
    - Section 88.3: Select the contents of an element
- **Chapter 89: File API, Blobs and FileReaders**
    - Section 89.1: Read file as string
    - Section 89.2: Read file as dataURL
    - Section 89.3: Slice a file
    - Section 89.4: Get the properties of the file
    - Section 89.5: Selecting multiple files and restricting file types
    - Section 89.6: Client side csv download using Blob
- **Chapter 90: Notifications API**
    - Section 90.1: Requesting Permission to send notifications
    - Section 90.2: Sending Notifications
    - Section 90.3: Closing a notification
    - Section 90.4: Notification events
- **Chapter 91: Vibration API**
    - Section 91.1: Single vibration
    - Section 91.2: Check for support
    - Section 91.3: Vibration patterns
- **Chapter 92: Battery Status API**
    - Section 92.1: Battery Events
    - Section 92.2: Getting current battery level
    - Section 92.3: Is battery charging?
    - Section 92.4: Get time left until battery is empty
    - Section 92.5: Get time left until battery is fully charged
- **Chapter 93: Fluent API**
    - Section 93.1: Fluent API capturing construction of HTML articles with JS
- **Chapter 94: Web Cryptography API**
    - Section 94.1: Creating digests (e.g. SHA-256)
    - Section 94.2: Cryptographically random data
    - Section 94.3: Generating RSA key pair and converting to PEM format
    - Section 94.4: Converting PEM key pair to CryptoKey
- **Chapter 97: Error Handling**
    - Section 97.1: Error objects
    - Section 97.2: Interaction with Promises
    - Section 97.3: Error types
    - Section 97.4: Order of operations plus advanced thoughts
- **Chapter 98: Global error handling in browsers**
    - Section 98.1: Handling window.onerror to report all errors back to the server-side
- **Chapter 99: Debugging**
    - Section 99.1: Interactive interpreter variables
    - Section 99.2: Breakpoints
    - Section 99.3: Using setters and getters to find what changed a property
    - Section 99.4: Using the console
    - Section 99.5: Automatically pausing execution
    - Section 99.6: Elements inspector
    - Section 99.7: Break when a function is called
    - Section 99.8: Stepping through code
- **Chapter 100: Unit Testing JavaScript**
    - Section 100.1: Unit Testing Promises with Mocha, Sinon, Chai and Proxyquire
    - Section 100.2: Basic Assertion
- **Chapter 101: Evaluating JavaScript**
    - Section 101.1: Evaluate a string of JavaScript statements
    - Section 101.2: Introduction
    - Section 101.3: Evaluation and Math
- **Chapter 102: Linters - Ensuring code quality**
    - Section 102.1: JSHint
    - Section 102.2: ESLint / JSCS
    - Section 102.3: JSLint
- **Chapter 103: Anti-patterns**
    - Section 103.1: Chaining assignments in var declarations
- **Chapter 104: Performance Tips**
    - Section 104.1: Avoid try/catch in performance-critical functions
    - Section 104.2: Limit DOM Updates
    - Section 104.3: Benchmarking your code - measuring execution time
    - Section 104.4: Use a memoizer for heavy-computing functions
    - Section 104.5: Initializing object properties with null
    - Section 104.6: Reuse objects rather than recreate
    - Section 104.7: Prefer local variables to globals, attributes, and indexed values
    - Section 104.8: Be consistent in use of Numbers
- **Chapter 105: Memory efficiency**
    - Section 105.1: Drawback of creating true private method
- Appendix A: Reserved Keywords
    - Section A.1: Reserved Keywords
    - Section A.2: Identifiers &amp; Identifier Names
- You may also like
</md></sn><config style="display:none"><tags>#01.index</tags><thumbnail></thumbnail><heading></heading><udate>Mon May 26 2025 13:36:28 GMT+0600 (Bangladesh Standard Time)</udate><id>article-kJOawdqBPx</id><duration></duration></config>