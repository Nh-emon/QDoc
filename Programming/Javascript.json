{"subject_name":"Javascript","subject_id":45,"chapters":[{"chapter_name":"05.Console","topics":[{"topic_name":"00.Introduction","topic_html":"<sn><h3>Console<br></h3><p>A browser's debugging console or web console is generally used by developers to <m>identify errors</m>, <m>understand flow</m><br><m>of execution</m>, <m>log data</m> and for many other purpose at runtime. This information is accessed through the console<br>object<img class=\"img-fluid\" alt=\"image\" src=\"https://developer.chrome.com/static/docs/devtools/console/image/the-console-panel-dc4828392d194.png\"></p><p>The information displayed by a <m>debugging/web console</m> is made available through the multiple methods of the<br>console Javascript object that can be consulted through<c> console.dir(console)</c>. Besides the <m>console.memory</m><br>property, the methods displayed are generally the following (taken from Chromium's output):</p><pre data-v=\"javascript\">Console {\n  log: ƒ log()\n  warn: ƒ warn()\n  error: ƒ error()\n  dir: ƒ dir()\n  table: ƒ table()\n  trace: ƒ trace()\n  group: ƒ group()\n  groupCollapsed: ƒ groupCollapsed()\n  groupEnd: ƒ groupEnd()\n  time: ƒ time()\n  timeLog: ƒ timeLog()\n  timeEnd: ƒ timeEnd()\n  clear: ƒ clear()\n  count: ƒ count()\n  countReset: ƒ countReset()\n  assert: ƒ assert()\n  debug: ƒ debug()\n  info: ƒ info()\n  dirxml: ƒ dirxml()\n  profile: ƒ profile()\n  profileEnd: ƒ profileEnd()\n  timeStamp: ƒ timeStamp()\n  context: ƒ context()\n  memory: MemoryInfo\n}\n</pre><p>The Console Object has mostly function except the <m>memory</m> which is a Object<br></p></sn><sn><h5>Opening Browser Console<br></h5><p>Browser console can be opened via right clicking on mouse and selecting inspect option from popup context menu<br></p><md data-rr=\"true\"><pre>Here's a table summarizing shortcuts to open the browser console for different browsers and operating systems:<br><br>| **Browser**      | **Windows/Linux**                     | **Mac**                          | **Notes**                                                                 |<br>|-------------------|---------------------------------------|-----------------------------------|---------------------------------------------------------------------------|<br>| **Google Chrome** | `Ctrl + Shift + J`                   | `Cmd + Option + J`               | Opens the **Console** directly.                                           |<br>| **Mozilla Firefox**| `Ctrl + Shift + K`                  | `Cmd + Option + K`               | Opens the **Web Console** directly.                                       |<br>| **Microsoft Edge**| `Ctrl + Shift + J`                   | `Cmd + Option + J`               | Similar to Chrome, as Edge is based on Chromium.                          |<br>| **Safari**        | *(N/A)* (Not on Windows/Linux)       | `Cmd + Option + C`               | Requires enabling **Developer Menu** in Safari Preferences &gt; Advanced.    |<br>| **Opera**         | `Ctrl + Shift + J`                   | `Cmd + Option + J`               | Same shortcut as Chrome and Edge.                                         |<br><br></pre></md></sn>","topic_id":562,"last_visited":"2024-12-08T02:27:28.499Z"},{"topic_name":"01.Console Time","topic_html":"<sn><h3 class=\"text-info text-center\">&nbsp;Measuring time - console.time()</h3><p>console.time() can be used to measure how long a task in your code takes to run</p><p>Calling <m>console.time([label])</m> starts a new timer. When <m>console.timeEnd([label])</m> is called, the elapsed time, in<br>milliseconds, since the <m>original .time()</m> call is calculated and logged. Because of this behavior, you can call<br>.timeEnd() multiple times with the same label to log the elapsed time since the <m>original .time()</m> call was made.</p></sn><sn><h5>Example1 :<br></h5><pre data-v=\"javascript\">const test = 'testingUserSpeed'\nconsole.time(test)//here test is the label\nalert('click to continue')\nconsole.timeEnd(test)\n//testingUserSpeed: 5615ms - timer ended</pre></sn><sn><h5>Example2 :<br></h5><pre data-v=\"javascript\">console.time('test-x')\nconsole.log('processing...')\nsetTimeout(()=&gt;{\n   console.log('processing end')\n},3000)\nconsole.timeEnd('test-x')\n//processing...\n//test-x: Xms (elapsed time since console.time was called)\n//processing end</pre><p>As setTimeout is asynchronous so it run after 3s and <m>console.time</m> and <m>console.timeEnd</m> is synchronous<br></p></sn><sn><h5>Example 3 :<br></h5><pre data-v=\"javascript\">console.time('test-x');\nconsole.log('processing...');\nsetTimeout(() =&gt; {\n   console.log('processing end');\n   console.timeEnd('test-x');\n}, 3000);\n//processing...\n//processing end\n//test-x: 3002ms - timer ended\n</pre><pre class=\"copy-container parentEl\"></pre></sn>","topic_id":563,"last_visited":"2024-12-08T03:09:36.371Z"},{"topic_name":"02.Console Group","topic_html":"<sn><h3>Console Group<br></h3><md data-rr=\"true\"><pre>In JavaScript, `console.group()`, `console.groupCollapsed()`, and `console.groupEnd()` are methods used to group log messages in the browser's developer console, making it easier to organize and collapse/expand related logs.<br><br>### 1. `console.group()`<br><br>- **Purpose**: Starts a new group in the console, where all subsequent `console.log()` messages will be nested under it.<br>- **How it works**: When a `console.group()` is called, all logs that follow will be indented and displayed inside a collapsible group, making the output more organized.<br><br>#### Example:<br>```javascript<br>console.group('My Group');<br>console.log('First log inside the group');<br>console.log('Second log inside the group');<br>console.groupEnd();<br>```<br>**Explanation**:<br>- `console.group('My Group')` starts the group and labels it \"My Group\".<br>- The following two `console.log()` statements will be indented and shown as part of the group.<br>- `console.groupEnd()` ends the group, returning to normal indentation.<br><br>### 2. `console.groupCollapsed()`<br><br>- **Purpose**: Similar to `console.group()`, but the group is collapsed by default in the console, meaning you have to expand it manually to view the logs inside.<br>- **How it works**: This method is useful if you have large or complex groups of logs and want to minimize the clutter in the console initially.<br><br>#### Example:<br>```javascript<br>console.groupCollapsed('Collapsed Group');<br>console.log('This log is inside a collapsed group');<br>console.log('Another log inside the collapsed group');<br>console.groupEnd();<br>```<br>**Explanation**:<br>- `console.groupCollapsed('Collapsed Group')` starts a group that is initially collapsed in the console.<br>- The logs inside this group are hidden until you expand the group manually.<br><br>### 3. `console.groupEnd()`<br><br>- **Purpose**: Ends the current group, returning the log output to the previous indentation level (or no indentation if no other group exists).<br>- **How it works**: Every call to `console.group()` or `console.groupCollapsed()` should be paired with a corresponding `console.groupEnd()` to close the group.<br><br>#### Example:<br>```javascript<br>console.group('Outer Group');<br>console.log('Log inside outer group');<br><br>console.group('Inner Group');<br>console.log('Log inside inner group');<br>console.groupEnd();<br><br>console.log('Back to outer group');<br>console.groupEnd();<br>```<br><br>**Explanation**:<br>- The outer group is started with `console.group('Outer Group')`, and an inner group is created with `console.group('Inner Group')`.<br>- `console.groupEnd()` closes the inner group first, and then the outer group is closed at the end.<br>- The output will show the nested structure in the console, with the inner group indented further.<br><br>### Summary:<br>- **`console.group()`**: Creates a new, expandable group in the console.<br>- **`console.groupCollapsed()`**: Creates a new, collapsed group in the console.<br>- **`console.groupEnd()`**: Ends the current group and returns to the previous indentation level.<br><br>These methods are great for structuring complex logs, especially when debugging or working with large datasets, helping you organize information in a more readable format.</pre></md></sn>","topic_id":565,"last_visited":"2024-12-08T05:39:34.648Z"},{"topic_name":"02.Formatting Console Output","topic_html":"<sn><h3>Formatting Console Output<br></h3><p>Many of the console's print methods can also handle C-like string formatting, using % tokens:</p><pre data-v=\"javascript\">console.log('%s has %d points', 'Sam', 100)\n//Sam has 100 points</pre><md data-rr=\"true\"><pre>Here is a table for the full list of format specifiers in JavaScript:<br><br>| **Specifier** | **Output**                                                     |<br>|---------------|-----------------------------------------------------------------|<br>| `%s`          | Formats the value as a string                                  |<br>| `%i` or `%d`  | Formats the value as an integer                                |<br>| `%f`          | Formats the value as a floating-point value                    |<br>| `%o`          | Formats the value as an expandable DOM element                 |<br>| `%O`          | Formats the value as an expandable JavaScript object           |<br>| `%c`          | Applies CSS style rules to the output string (from 2nd parameter) |</pre></md></sn><sn><h5>Example :<br></h5><pre data-v=\"javascript\">console.log('My name is %s','Emon')\nconsole.log('My age is %i',21)\nconsole.log('My height is %f',5.7)\nconsole.log('%o',document.body)\nconsole.log('%O',{name:'emon',age:21,height:5.7})\nconsole.log('%cHello World','color:blue;font-size:xx-large')</pre><h5>output<br></h5><im>https://raw.githubusercontent.com/Nh-emon/QDoc/main/Programming/js%20media/console%20formatiing%20output%20screenshot.png</im></sn><sn><h5>Advanced Styling<br></h5><p>When the CSS format specifier (%c) is placed at the left side of the string, the print method will accept a second<br>parameter with CSS rules which allow fine-grained control over the formatting of that string:</p><ul><li>Any substring to the right of a %c has a corresponding parameter in the print method</li><li>\nThis parameter may be an empty string, if there is no need to apply CSS rules to that same substring</li><li>\nIf two %c format specifiers are found, the 1st (encased in %c) and 2nd substring will have their rules defined in\nthe 2nd and 3rd parameter of the print method respectively</li><li>\nIf three %c format specifiers are found, then the 1st, 2nd and 3rd substrings will have their rules defined in\nthe 2nd , 3rd and 4th parameter respectively, and so on</li></ul><pre data-v=\"javascript\">console.log('chapter is %cremoved','color:crimson') \nconsole.log('%cchapter is %cremoved','color:blue','color:crimson')\nconsole.log('%cchapter%c is %cremoved','color:blue','','color:crimson')</pre></sn>","topic_id":564,"last_visited":"2024-12-08T05:39:12.249Z"},{"topic_name":"03.Console log","topic_html":"<sn><h3>Printing to a browser's debugging console</h3><p>A browser's debugging console can be used in order to print simple messages. This debugging or web console can<br>be directly opened in the browser ( F12 key in most browsers ) and<br>the log method of the console JavaScript object can be invoked by typing the following</p><pre data-v=\"javascript\">console.log('My message');</pre><p>Then, by pressing <c>Enter</c> , this will display My message in the debugging console</p></sn><sn><p>console.log() can be called with any number of arguments and variables available in the current scope. Multiple<br>arguments will be printed in one line with a small space between them</p><pre data-v=\"javascript\">var obj = { test: 1 };\nconsole.log(['string'], 1, obj, window);</pre></sn><sn><p>Beside plain strings, console.log() can handle other types, like arrays, objects, dates, functions, etc.</p><pre data-v=\"javascript\">console.log([0, 3, 32, 'a string']);\nconsole.log({ key1: 'value', key2: 'another value'});</pre></sn><sn><p>Certain types such as Date objects and functions may be displayed differently</p><pre data-v=\"javascript\">console.log(new Date(0));\nconsole.log(function test(a, b) { return c; });\n// &gt;Date Thu Jan 01 1970 06:00:00 GMT+0600 (Bangladesh Standard Time)\n// &gt;function test(a, b)</pre></sn><sn><h5>Other Print Method<br></h5><p>In addition to the log method, modern browsers also support similar methods:</p><md data-rr=\"true\"><pre><br>| **Function Name**     | **Features**                                                                 |<br>|-----------------------|-------------------------------------------------------------------------------|<br>| **`console.info()`**   | Logs general information to the console. Displays with blue text (default).   |<br>| **`console.warn()`**   | Logs a warning message. Displays with a yellow warning icon (triangle).       |<br>| **`console.error()`**  | Logs an error message. Displays with a red error icon (circle) or red text.   |<br>| **`console.timestamp()`** | (Custom method) Logs the current timestamp, often used for logging time-related data. |<br>| **`console.trace()`**  | Logs the stack trace, showing the path the code execution took.              |</pre></md><h5>Example :<br></h5><pre data-v=\"javascript\">console.info('my browser is firefox')\nconsole.warn('switch to edge -microsoft')\nconsole.error('invalid api')\nconsole.timeStamp('msg')\n\nfunction sec(){\n\tfirst()\n}\nfunction first(){\n\tconsole.trace()\n}\nsec()</pre><nt>Output :<br><im>https://raw.githubusercontent.com/Nh-emon/QDoc/main/Programming/js%20media/different%20console%20type.png</im></nt></sn>","topic_id":566,"last_visited":"2024-12-08T06:14:39.611Z"},{"topic_name":"04.Console trace","topic_html":"<sn><h3>Including a stack trace when logging - console.trace()</h3><p><code>console.trace()</code> is a method in JavaScript that outputs a stack trace to the console, showing the path your code has taken to reach the point where <code>console.trace()</code> is called. This is useful for debugging because it helps you identify how your code has reached a particular line and what function calls led to it.</p></sn><sn><h5>Example<br></h5><pre data-v=\"javascript\">function functionA() {\n  functionB();\n}\n\nfunction functionB() {\n  functionC();\n}\n\nfunction functionC() {\n  console.trace('Stack trace at functionC');\n}\n\nfunctionA();\n</pre><h5>Output :<br></h5><pre data-v=\"text\">Stack trace at functionC\n    at functionC (example.js:9)\n    at functionB (example.js:5)\n    at functionA (example.js:2)\n    at example.js:12\n</pre></sn><sn><h5>Explanation :<br></h5><ul><li>When functionC() is called, it logs the stack trace with console.trace</li><li>\nThe trace shows the call stack, starting from functionC(), then functionB(), then functionA(), and finally the point where functionA() was invoked in the script</li><li>\nThis helps to understand the sequence of function calls leading up to the trace</li></ul></sn><sn><nt>Note: Where available it's also useful to know that the same stack trace is accessible as a property of the Error<br>object. This can be useful for post-processing and gathering automated feedback.</nt><pre data-v=\"javascript\">var e = new Error('foo');\nconsole.log(e.stack);</pre></sn>","topic_id":567,"last_visited":"2024-12-08T06:19:28.038Z"},{"topic_name":"05.Console table","topic_html":"<sn><h3>Tabulating values - console.table()<br></h3><p>In most environments, console.table() can be used to display objects and arrays in a tabular format</p><pre data-v=\"javascript\">console.table(['Hello', 'world']);</pre><h5>output :<br></h5><tb>\n<pre>| (index)<br> | Values<br> |\n| ---  | --- |\n| 0<br> | Hello<br> |\n| 1<br> | world<br> |\n</pre></tb><h5>Object :<br></h5><pre data-v=\"javascript\">console.table({foo: 'bar', bar: 'baz'})</pre><tb>\n<pre>| (index)<br> | Values<br> |\n| ---  | --- |\n| foo<br> | bar<br> |\n| bar<br> | baz<br> |\n</pre></tb></sn><sn><h5>Example of large Object :<br></h5><pre data-v=\"javascript\">var personArr = [\n{\n\"personId\": 123,\n\"name\": \"Jhon\",\n\"city\": \"Melbourne\",\n\"phoneNo\": \"1234567890\"\n},\n{\n\"personId\": 124,\n\"name\": \"Amelia\",\n\"city\": \"Sydney\",\n\"phoneNo\": \"1234567890\"\n},\n{\n\"personId\": 125,\n\"name\": \"Emily\",\n\"city\": \"Perth\",\n\"phoneNo\": \"1234567890\"\n},\n{\n\"personId\": 126,\n\"name\": \"Abraham\",\n\"city\": \"Perth\",\n\"phoneNo\": \"1234567890\"\n}\n];\nconsole.table(personArr, ['name', 'personId']);</pre><im>https://raw.githubusercontent.com/Nh-emon/QDoc/main/Programming/js%20media/console%20table.png</im></sn>","topic_id":568,"last_visited":"2024-12-08T06:46:11.589Z"},{"topic_name":"06.Console count","topic_html":"<sn><h3>&nbsp;Counting - console.count()</h3><p><m>console.count([obj])</m> places a counter on the object's value provided as argument. Each time this method is invoked, the counter is increased (with the exception of the empty string ''). A label together with a number is displayed in the debugging console according to the following format :<br></p><p class=\"box-bg-1 text-info\">[label] : X<br></p><p>label represents the value of the object passed as argument and X represents the counter's value.</p></sn><sn><p>An object's value is always considered, even if variables are provided as arguments:<br></p><pre data-v=\"javascript\">var o1 = 1, o2 = '2', o3 = \"\";\nconsole.count(o1); // 1: 1\nconsole.count(o2); // 2: 1\nconsole.count(o3); //&lt;no label&gt; : 1\nconsole.count(1);  // 1:2\nconsole.count('2');// 2:2\nconsole.count(''); //&lt;no label&gt; : 2</pre></sn><sn><p>Strings with numbers are converted to Number objects :</p><pre data-v=\"javascript\">console.count(42.3);            //42.3: 1\nconsole.count(Number('42.3'));  //42.3: 2\nconsole.count('42.3')           //42.3: 3\n</pre></sn><sn><p>Functions point always to the global Function object :</p><pre data-v=\"javascript\">console.count(console.constructor);\nconsole.count(function(){});\nconsole.count(Object);\nvar fn1 = function myfn(){};\nconsole.count(fn1);\nconsole.count(Number);\n</pre><pre data-v=\"text\">[Function: Object]: 1\nfunction (): 1\n[Function: Object]: 2\nfunction myfn: 1\n[Function: Number]: 1</pre></sn><sn><p>Certain objects get specific counters associated to the type of object they refer to :</p><pre data-v=\"javascript\">console.count(undefined);\nconsole.count(document.Batman);\nvar obj;\nconsole.count(obj);\nconsole.count(Number(undefined));\nconsole.count(NaN);\nconsole.count(NaN+3);\nconsole.count(1/0);\nconsole.count(String(1/0));\nconsole.count(window);\nconsole.count(document);\nconsole.count(console);\nconsole.count(console.__proto__);\nconsole.count(console.constructor.prototype);\nconsole.count(console.__proto__.constructor.prototype);\nconsole.count(Object.getPrototypeOf(console));\nconsole.count(null);</pre><pre data-v=\"text\">undefined: 1\nundefined: 2\nundefined: 3\nNaN: 1\nNaN: 2\nNaN: 3\nInfinity: 1\nInfinity: 1\n[object Window]: 1\n[object Document]: 1\n[object Console]: 1\n[object Object]: 1\n[object Object]: 2\n[object Object]: 3\n[object Object]: 4\nnull: 1\n</pre></sn><sn><p>If no argument is provided while sequentially inputting the count method in the debugging console, an empty<br>string is assumed as parameter<br></p><pre data-v=\"bash\">console.count()   // : 1\nconsole.count('') // : 2\nconsole.count(\"\") // : 3</pre></sn>","topic_id":569,"last_visited":"2024-12-08T06:52:22.116Z"},{"topic_name":"07.Console clear","topic_html":"<sn><h5>Clearing the console - console.clear()</h5><p>You can clear the console window using the <c> console.clear()</c> method. This removes all previously printed messages in the console and may print a message like \"Console was cleared\" in some environments.</p></sn>","topic_id":570,"last_visited":"2024-12-08T07:20:38.835Z"},{"topic_name":"08.Console dir","topic_html":"<sn><h3>Displaying objects and XML interactively console.dir() ,console.dirxml()</h3><p><c>console.dir(object)</c> displays an interactive list of the properties of the specified JavaScript object. The output is<br>presented as a hierarchical listing with disclosure triangles that let you see the contents of child objects</p><p><m>console.dirxml(object)</m> prints an XML representation of the descendant elements of object if possible, or the JavaScript representation if not. Calling <m>console.dirxml()</m> on HTML and XML elements is equivalent to calling console.log()</p><pre data-v=\"javascript\">console.dir([object])\nconsole.dir(document)\nconsole.dirxml(document)</pre></sn>","topic_id":571,"last_visited":"2024-12-08T07:49:14.411Z"},{"topic_name":"09.Console assert","topic_html":"<sn><h3>Debugging with assertions - console.assert()</h3><p>Writes an error message to the console if the assertion is false. Otherwise, if the assertion is true, this does nothing.</p><pre data-v=\"javascript\">console.assert('one' === 1)</pre><al class=\"alert alert-danger\"><p class=\"alert-body\"><span class=\"message-body-wrapper\"><span class=\"message-flex-body\"><span class=\"message-body devtools-monospace\"><span>Assertion failed: </span></span></span></span></p></al><pre data-v=\"javascript\">console.assert(true,\"testing assertion\")\n//undefined\nconsole.assert(true,\"testing assertion\",NaN,undefined,Object)\n//undefined\nconsole.assert(false,\"testing assertion\",NaN,undefined,Object)\n</pre><al class=\"alert alert-danger\"><p class=\"alert-body\"><span class=\"message-body-wrapper\"><span class=\"message-flex-body\"><span class=\"message-body devtools-monospace\"><span>Assertion failed: <span class=\"objectBox objectBox-string\">testing assertion</span> <span class=\"objectBox objectBox-nan\">NaN</span> <span class=\"objectBox objectBox-undefined\">undefined</span></span></span></span></span></p></al></sn>","topic_id":572,"last_visited":"2024-12-08T08:06:38.962Z"}],"chapter_id":178},{"chapter_name":"12.Arrays","topics":[{"topic_name":"01.Converting Array like Object to Array","topic_html":"<sn><md data-rr=\"true\"><pre>## **Converting Array-like Objects to Arrays**<br><br>### **What are Array-like Objects?**<br><br>JavaScript has \"Array-like Objects,\" which are object representations of arrays with a `length` property. For example:<br><br>```javascript<br>var realArray = ['a', 'b', 'c'];<br>var arrayLike = {<br>  0: 'a',<br>  1: 'b',<br>  2: 'c',<br>  length: 3<br>};<br>```<br><br>### **Common Examples of Array-like Objects**<br>- **`arguments`** object in functions.<br>- **`HTMLCollection`** or **`NodeList`** objects returned from DOM methods like `document.getElementsByTagName` or `document.querySelectorAll`.<br><br>### **Key Differences Between Arrays and Array-like Objects**<br>- Array-like objects inherit from **`Object.prototype`**, not **`Array.prototype`**.<br>- They **cannot access common Array prototype methods** such as `forEach()`, `push()`, `map()`, `filter()`, and `slice()`.<br><br>Example:<br>```javascript<br>var parent = document.getElementById('myDropdown');<br>var desiredOption = parent.querySelector('option[value=\"desired\"]');<br>var domList = parent.children;<br><br>// Errors!<br>domList.indexOf(desiredOption); // Error! indexOf is not defined.<br>domList.forEach(() =&gt; {});      // Error! forEach is not defined.<br>```<br><br>However, the `arguments` object can still display its contents:<br>```javascript<br>function func() {<br>  console.log(arguments);<br>}<br>func(1, 2, 3); // → [1, 2, 3]<br>```<br><br>---<br><br>## **Converting Array-like Objects to Arrays**<br><br>### **Using ES6+ Methods**<br><br>1. **`Array.from`**<br>   - Converts array-like objects to arrays.<br>   - Example:<br>     ```javascript<br>     const arrayLike = {<br>       0: 'Value 0',<br>       1: 'Value 1',<br>       length: 2<br>     };<br><br>     const realArray = Array.from(arrayLike);<br>     realArray.forEach(value =&gt; {<br>       console.log(value); // Works!<br>     });<br>     ```<br><br>2. **`for...of`**<br>   - Example:<br>     ```javascript<br>     const arrayLike = { 0: 'Value 0', 1: 'Value 1', length: 2 };<br>     const realArray = [];<br><br>     for (const element of Array.from(arrayLike)) {<br>       realArray.push(element);<br>     }<br>     ```<br><br>3. **Spread Operator (`...`)**<br>   - Example:<br>     ```javascript<br>     const realArray = [...arrayLike];<br>     ```<br><br>4. **`Object.values`**<br>   - Requires ES7+.<br>   - Example:<br>     ```javascript<br>     const realArray = Object.values(arrayLike);<br>     ```<br><br>5. **`Object.keys`**<br>   - Example:<br>     ```javascript<br>     const realArray = Object.keys(arrayLike).map(key =&gt; arrayLike[key]);<br>     ```<br><br>---<br><br>### **Using Pre-ES6 Methods**<br><br>1. **`Array.prototype.slice`**<br>   - Example:<br>     ```javascript<br>     var arrayLike = { 0: 'Value 0', 1: 'Value 1', length: 2 };<br><br>     var realArray = Array.prototype.slice.call(arrayLike);<br>     console.log(realArray.indexOf('Value 1')); // Works!<br>     ```<br><br>2. **Calling Array Methods Directly**<br>   - Use `Function.prototype.call` to invoke Array methods directly:<br>     ```javascript<br>     var domList = document.querySelectorAll('#myDropdown option');<br><br>     Array.prototype.forEach.call(domList, function(option) {<br>       console.log(option); // Works!<br>     });<br>     ```<br><br>3. **Borrowing Array Methods**<br>   - Example:<br>     ```javascript<br>     var arrayLike = { 0: 'Value 0', 1: 'Value 1', length: 2 };<br><br>     [].forEach.bind(arrayLike)(function(val) {<br>       console.log(val); // Works!<br>     });<br>     ```<br><br>---<br><br>### **Modifying Items During Conversion**<br><br>With ES6+ `Array.from`, you can specify a map function to transform items during conversion:<br>```javascript<br>Array.from(domList, element =&gt; element.tagName);<br>// Creates an array of tag names.<br>```</pre></md></sn><sn><md data-rr=\"true\"><pre>### **Q&amp;A Section**<br><br>---<br><br>#### **Q1: Why can’t we use array methods like `forEach` on DOM returned collections (`children`)?**<br><br>- **Answer**: <br>  DOM methods like `parent.children` return an **`HTMLCollection`**, which is an array-like object but does not inherit from `Array.prototype`. Hence, methods like `forEach` or `indexOf` are not available.  <br>  To use these methods, you must convert the `HTMLCollection` to an array using `Array.from()`.<br><br>---<br><br>#### **Q2: Can we use `forEach` directly on DOM collections like `querySelectorAll` results?**<br><br>- **Answer**: <br>  Yes, `querySelectorAll` returns a **`NodeList`**, which is array-like **and iterable** in modern browsers. Therefore, methods like `forEach` work directly on `NodeList` without conversion.<br><br>---<br><br>#### **Q3: Why does the following code throw an error?**<br><br>```javascript<br>const arrLike = { 0: 'emon', 1: 'mahin', length: 2 };<br>const arr = [...arrLike];<br>```<br><br>- **Answer**: <br>  The error occurs because `arrLike` is not **iterable**. The spread operator (`...`) requires the object to implement a `[Symbol.iterator]` method, which `arrLike` lacks. Use `Array.from()` to convert such objects to arrays.<br><br>---<br><br>#### **Q4: Why does the note include the spread operator (`[...]`) for converting array-like objects to arrays?**<br><br>- **Answer**: <br>  The spread operator works on **iterable** array-like objects like `NodeList`. Since `NodeList` is iterable in modern browsers, `[...nodeList]` works. However, for non-iterable objects (e.g., `{0: 'emon', 1: 'mahin', length: 2}`), you must use `Array.from()` instead.<br><br>--- <br><br>This concise Q&amp;A should help you quickly recall key points about array-like objects and their conversion to arrays!</pre></md></sn>","topic_id":590,"last_visited":"2024-12-09T22:12:28.194Z"},{"topic_name":"02.Reducing Values","topic_html":"<sn><md data-rr=\"true\"><pre><br>### Reducing Values<br>**Version ≥ 5.1**<br><br>The `reduce()` method applies a function against an accumulator and each value of the array (from left-to-right) to reduce it to a single value.<br><br>#### **Array Sum**<br>The `reduce()` method can condense all values of an array into a single value:<br>```javascript<br>[1, 2, 3, 4].reduce(function(a, b) {<br>  return a + b;<br>});<br>// → 10<br>```<br><br>An optional second parameter can be passed to `reduce()`. Its value will be used as the first argument (`a`) for the first call to the callback:<br>```javascript<br>[2].reduce(function(a, b) {<br>  console.log(a, b); // prints: 1 2<br>  return a + b;<br>}, 1);<br>// → 3<br>```<br><br>---<br><br>#### **Flatten Array of Objects**<br>To flatten an array of objects into a single object, use `reduce()` as shown below:<br><br>**Version ≤ 5.1:**<br>```javascript<br>var array = [{<br>  key: 'one',<br>  value: 1<br>}, {<br>  key: 'two',<br>  value: 2<br>}, {<br>  key: 'three',<br>  value: 3<br>}];<br><br>array.reduce(function(obj, current) {<br>  obj[current.key] = current.value;<br>  return obj;<br>}, {});<br>// Result: { one: 1, two: 2, three: 3 }<br>```<br><br>**Version ≥ 6:**<br>```javascript<br>array.reduce((obj, current) =&gt; Object.assign(obj, {<br>  [current.key]: current.value<br>}), {});<br>```<br><br>**Version ≥ 7:**<br>```javascript<br>array.reduce((obj, current) =&gt; ({...obj, [current.key]: current.value}), {});<br>```<br><br>Note: The Rest/Spread Properties is not supported by ES2016, but you can use the Babel plugin `babel-plugin-transform-object-rest-spread` for support.<br><br>---<br><br>#### **Map Using Reduce**<br>You can use the initial value parameter to call a function on an array of items and return the results in a new array:<br>```javascript<br>function map(list, fn) {<br>  return list.reduce(function(newList, item) {<br>    return newList.concat(fn(item));<br>  }, []);<br>}<br><br>// Usage:<br>map([1, 2, 3], function(n) { return n * n; });<br>// → [1, 4, 9]<br>```<br><br>&gt; **Note:** This is for illustration (of the initial value parameter) only. For list transformations, prefer using the native `map()`.<br><br>---<br><br>#### **Find Min or Max Value**<br>You can use `reduce()` to track the min or max value in an array. Here's an example to find the minimum value:<br>```javascript<br>var arr = [4, 2, 1, -10, 9];<br>arr.reduce(function(a, b) {<br>  return a &lt; b ? a : b;<br>}, Infinity);<br>// → -10<br>```<br><br>---<br><br>#### **Find Unique Values**<br>To return unique values from an array, use `reduce()` with an empty array as the second argument:<br>```javascript<br>var arr = [1, 2, 1, 5, 9, 5];<br>arr.reduce((prev, number) =&gt; {<br>  if (prev.indexOf(number) === -1) {<br>    prev.push(number);<br>  }<br>  return prev;<br>}, []);<br>// → [1, 2, 5, 9]<br>```<br><br></pre></md></sn>","topic_id":591,"last_visited":"2024-12-10T03:51:03.067Z"},{"topic_name":"03.Mapping Values","topic_html":"<sn><md data-rr=\"true\"><pre><br>### Mapping Values<br><br>The `map()` method is used to generate a new array based on the values of an existing array.<br><br>#### **Example: Generate String Lengths**<br>To create an array of string lengths from an array of strings:<br><br>**Version ≥ 5.1:**<br>```javascript<br>['one', 'two', 'three', 'four'].map(function(value, index, arr) {<br>  return value.length;<br>});<br>// → [3, 3, 5, 4]<br>```<br><br>**Version ≥ 6:**<br>```javascript<br>['one', 'two', 'three', 'four'].map(value =&gt; value.length);<br>// → [3, 3, 5, 4]<br>```<br><br>---<br><br>#### **How `map()` Works**<br>The `map()` function calls the provided callback function for each element in the array, passing the following parameters in order:<br><br>1. **The element itself**  <br>2. **The index of the element** (e.g., 0, 1, 2...)  <br>3. **The entire array**  <br><br>---<br><br>#### **Setting the `this` Context**<br>The `map()` method also provides an optional second parameter to set the value of `this` inside the mapping function.  <br><br>- **Default `this` in Browsers:**  <br>  In a browser environment, the default value of `this` is `window`.<br><br>  ```javascript<br>  ['one', 'two'].map(function(value, index, arr) {<br>    console.log(this); // window (the default value in browsers)<br>    return value.length;<br>  });<br>  ```<br><br>- **Custom `this` Value:**  <br>  You can specify a custom object as the value of `this`:<br><br>  ```javascript<br>  ['one', 'two'].map(function(value, index, arr) {<br>    console.log(this); // Object { documentation: \"randomObject\" }<br>    return value.length;<br>  }, {<br>    documentation: 'randomObject'<br>  });<br>  ```</pre></md></sn>","topic_id":592,"last_visited":"2024-12-10T03:52:46.808Z"},{"topic_name":"04.Filtering Object Values","topic_html":"<sn><md data-rr=\"true\"><pre>### Filtering Object Arrays<br><br>The `filter()` method is used to create a new array containing only the elements of the original array that pass the test provided by a callback function.<br><br>---<br><br>#### **Filtering Numbers**<br>For example, to filter all odd numbers from an array:<br><br>```javascript<br>var numbers = [5, 32, 43, 4];<br>```<br><br>**Version ≥ 5.1:**<br>```javascript<br>var odd = numbers.filter(function(n) {<br>  return n % 2 !== 0;<br>});<br>```<br><br>**Version ≥ 6:**<br>```javascript<br>let odd = numbers.filter(n =&gt; n % 2 !== 0);<br>```<br><br>The result is:<br>```javascript<br>// odd = [5, 43]<br>```<br><br>---<br><br>#### **Filtering Objects**<br>The `filter()` method can also be used with arrays of objects. For example, to filter people younger than 35:<br><br>```javascript<br>var people = [<br>  { id: 1, name: \"John\", age: 28 },<br>  { id: 2, name: \"Jane\", age: 31 },<br>  { id: 3, name: \"Peter\", age: 55 }<br>];<br>```<br><br>**Version ≥ 5.1:**<br>```javascript<br>var young = people.filter(function(person) {<br>  return person.age &lt; 35;<br>});<br>```<br><br>**Version ≥ 6:**<br>```javascript<br>let young = people.filter(person =&gt; person.age &lt; 35);<br>```<br><br>The result is:<br>```javascript<br>// young = [<br>//   { id: 1, name: \"John\", age: 28 },<br>//   { id: 2, name: \"Jane\", age: 31 }<br>// ]<br>```<br><br>---<br><br>#### **Searching for a Value in Objects**<br>You can search for a value across all properties of the objects in an array:<br><br>```javascript<br>var young = people.filter((obj) =&gt; {<br>  var flag = false;<br>  Object.values(obj).forEach((val) =&gt; {<br>    if (String(val).indexOf(\"J\") &gt; -1) {<br>      flag = true;<br>      return;<br>    }<br>  });<br>  if (flag) return obj;<br>});<br>```<br><br>This searches for the letter `\"J\"` in any property of the objects and returns:<br>```javascript<br>// young = [<br>//   { id: 1, name: \"John\", age: 28 },<br>//   { id: 2, name: \"Jane\", age: 31 }<br>// ]<br>```</pre></md></sn>","topic_id":593,"last_visited":"2024-12-10T04:14:25.212Z"},{"topic_name":"05.Sorting arrays","topic_html":"<sn><md data-rr=\"true\"><pre>### Sorting Arrays<br><br>The `.sort()` method sorts the elements of an array. By default, it sorts based on string Unicode code points. To sort an array numerically or in custom orders, a `compareFunction` must be provided.<br><br>&gt; **Note:** The `.sort()` method is impure. It sorts the array **in-place**, meaning the original array is modified and re-ordered.<br><br>---<br><br>#### **Default Sort**<br>The default sort arranges elements in Unicode order:<br>```javascript<br>['s', 't', 'a', 34, 'K', 'o', 'v', 'E', 'r', '2', '4', 'o', 'W', -1, '-4'].sort();<br>```<br>**Results:**<br>```javascript<br>[-1, '-4', '2', 34, '4', 'E', 'K', 'W', 'a', 'l', 'o', 'o', 'r', 's', 't', 'v']<br>```<br>- Uppercase letters are sorted before lowercase.<br>- Numbers are not sorted numerically.<br><br>---<br><br>#### **Alphabetical Sort**<br>Sort alphabetically:<br>```javascript<br>['s', 't', 'a', 'c', 'K', 'o', 'v', 'E', 'r', 'f', 'l', 'W', '2', '1'].sort((a, b) =&gt; {<br>  return a.localeCompare(b);<br>});<br>```<br>**Results:**<br>```javascript<br>['1', '2', 'a', 'c', 'E', 'f', 'K', 'l', 'o', 'r', 's', 't', 'v', 'W']<br>```<br><br>**Safe Alphabetical Sort (with mixed types):**<br>```javascript<br>['s', 't', 'a', 'c', 'K', 1, 'v', 'E', 'r', 'f', 'l', 'o', 'W'].sort((a, b) =&gt; {<br>  return a.toString().localeCompare(b);<br>});<br>```<br><br>---<br><br>#### **String Sorting by Length**<br>- **Longest First:**<br>  ```javascript<br>  [\"zebras\", \"dogs\", \"elephants\", \"penguins\"].sort(function(a, b) {<br>    return b.length - a.length;<br>  });<br>  ```<br>  **Results:**<br>  ```javascript<br>  [\"elephants\", \"penguins\", \"zebras\", \"dogs\"]<br>  ```<br><br>- **Shortest First:**<br>  ```javascript<br>  [\"zebras\", \"dogs\", \"elephants\", \"penguins\"].sort(function(a, b) {<br>    return a.length - b.length;<br>  });<br>  ```<br>  **Results:**<br>  ```javascript<br>  [\"dogs\", \"zebras\", \"penguins\", \"elephants\"]<br>  ```<br><br>---<br><br>#### **Numerical Sort**<br>- **Ascending Order:**<br>  ```javascript<br>  [100, 1000, 10, 10000, 1].sort(function(a, b) {<br>    return a - b;<br>  });<br>  ```<br>  **Results:**<br>  ```javascript<br>  [1, 10, 100, 1000, 10000]<br>  ```<br><br>- **Descending Order:**<br>  ```javascript<br>  [100, 1000, 10, 10000, 1].sort(function(a, b) {<br>    return b - a;<br>  });<br>  ```<br>  **Results:**<br>  ```javascript<br>  [10000, 1000, 100, 10, 1]<br>  ```<br><br>---<br><br>#### **Sorting by Even and Odd Numbers**<br>Separate even numbers first, then sort numerically:<br>```javascript<br>[10, 21, 4, 15, 7, 99, 0, 12].sort(function(a, b) {<br>  return (a &amp; 1) - (b &amp; 1) || a - b;<br>});<br>```<br>**Results:**<br>```javascript<br>[0, 4, 10, 12, 7, 15, 21, 99]<br>```<br><br>---<br><br>#### **Sorting Dates**<br>Sort dates in descending order:<br>```javascript<br>var dates = [<br>  new Date(2007, 11, 10),<br>  new Date(2014, 2, 21),<br>  new Date(2009, 6, 11),<br>  new Date(2016, 7, 23)<br>];<br><br>// Method 1: Using comparison<br>dates.sort(function(a, b) {<br>  if (a &gt; b) return -1;<br>  if (a &lt; b) return 1;<br>  return 0;<br>});<br><br>// Method 2: Using subtraction<br>dates.sort(function(a, b) {<br>  return b - a;<br>});<br>```<br>**Results:**<br>```javascript<br>[<br>  \"Tue Aug 23 2016 00:00:00 GMT-0600 (MDT)\",<br>  \"Fri Mar 21 2014 00:00:00 GMT-0600 (MDT)\",<br>  \"Sat Jul 11 2009 00:00:00 GMT-0600 (MDT)\",<br>  \"Mon Dec 10 2007 00:00:00 GMT-0700 (MST)\"<br>]<br>```</pre></md></sn>","topic_id":594,"last_visited":"2024-12-10T04:19:19.102Z"},{"topic_name":"06.Iteration","topic_html":"<sn><md data-rr=\"true\" class=\"p-1 p-md-2 my-2\">### Iteration\n\nJavaScript provides various ways to iterate over arrays and objects. Here's an overview of different techniques:\n\n---\n\n#### **1. Traditional `for` Loop**\n\nA traditional `for` loop consists of three components:\n1. **Initialization**: Executed before the loop starts.\n2. **Condition**: Checked before every iteration; exits if false.\n3. **Afterthought**: Executed after each iteration.\n\nSyntax:\n```javascript\nfor (initialization; condition; afterthought) {\n  // Do stuff\n}\n```\n\n**Minimal Example:**\n```javascript\nfor (;;) {\n  // Infinite loop; requires a break statement to exit\n  if (condition === true) break;\n}\n```\n\n**Common Usage:**\n```javascript\nfor (var i = 0, length = 10; i &lt; length; i++) {\n  console.log(i);\n}\n```\n\n---\n\n#### **2. Looping Through an Array**\n\n**Forward Iteration:**\n```javascript\nfor (var i = 0, length = myArray.length; i &lt; length; i++) {\n  console.log(myArray[i]);\n}\n```\n\n**Backward Iteration:**\n```javascript\nfor (var i = myArray.length - 1; i &gt;= 0; i--) {\n  console.log(myArray[i]);\n}\n```\n\n**Other Variations:**\n- Using `value` directly:\n  ```javascript\n  for (var key = 0, value = myArray[key], length = myArray.length; key &lt; length; value = myArray[++key]) {\n    console.log(value);\n  }\n  ```\n- Incrementing within the loop:\n  ```javascript\n  var i = 0, length = myArray.length;\n  for (; i &lt; length;) {\n    console.log(myArray[i]);\n    i++;\n  }\n  ```\n- Using assignment in the loop condition:\n  ```javascript\n  var key = 0, value;\n  for (; value = myArray[key++];) {\n    console.log(value);\n  }\n  ```\n\n---\n\n#### **3. `while` Loop**\n\n**Example:**\n```javascript\nvar key = 0;\nwhile (value = myArray[key++]) {\n  console.log(value);\n}\n```\n\n**Equivalent `for` Loop:**\n```javascript\nfor (var key = 0; value = myArray[key++];) {\n  console.log(value);\n}\n```\n\n---\n\n#### **4. `for...in` Loop**\n\nLoops over the properties (keys) of an object or array:\n```javascript\nfor (i in myArray) {\n  console.log(myArray[i]);\n}\n```\n**Caution:** Avoid using `for...in` for arrays as it may include inherited properties. Refer to discussions on why `for...in` is not ideal for arrays.\n\n---\n\n#### **5. `for...of` Loop (ES6)**\n\nRecommended for iterating over array **values**:\n```javascript\nlet myArray = [1, 2, 3, 4];\nfor (let value of myArray) {\n  console.log(value * 2); // Doubles each value\n}\n```\n\n**Comparison:**\n```javascript\nlet myArray = [3, 5, 7];\nmyArray.foo = \"hello\";\n\nfor (var i in myArray) {\n  console.log(i); // Logs: 0, 1, 2, \"foo\"\n}\n\nfor (var i of myArray) {\n  console.log(i); // Logs: 3, 5, 7\n}\n```\n\n---\n\n#### **6. `Array.prototype.keys()` (ES6)**\n\nIterates over array **indices**:\n```javascript\nlet myArray = [1, 2, 3, 4];\nfor (let i of myArray.keys()) {\n  console.log(`Index: ${i}, Value: ${myArray[i]}`);\n}\n```\n\n---\n\n#### **7. `Array.prototype.forEach()`**\n\nExecutes a function for each array element:\n```javascript\n[1, 2, 3, 4].forEach(function(value, index, arr) {\n  console.log(`Value: ${value}, Index: ${index}`);\n});\n```\n**Limitation:** Cannot use `break` or `continue` inside `.forEach()`.\n\n---\n\n#### **8. `Array.prototype.every()`**\n\nIterates until the callback returns `false`:\n```javascript\n[2, 4, 7, 9].every(function(value) {\n  console.log(value);\n  return value % 2 === 0; // Stops at the first odd number\n});\n```\n\nEquivalent traditional loop:\n```javascript\nvar arr = [2, 4, 7, 9];\nfor (var i = 0; i &lt; arr.length &amp;&amp; arr[i] % 2 === 0; i++) {\n  console.log(arr[i]);\n}\n```\n\n---\n\n#### **9. `Array.prototype.some()`**\n\nIterates until the callback returns `true`:\n```javascript\n[2, 4, 7, 9].some(function(value) {\n  console.log(value);\n  return value === 7; // Stops when it finds 7\n});\n```\n\nEquivalent traditional loop:\n```javascript\nvar arr = [2, 4, 7, 9];\nfor (var i = 0; i &lt; arr.length &amp;&amp; arr[i] !== 7; i++) {\n  console.log(arr[i]);\n}\n```\n\n---\n\n#### **10. Libraries**\n\nPopular utility libraries provide iteration methods:\n\n- **jQuery:**\n  ```javascript\n  $.each(myArray, function(key, value) {\n    console.log(value);\n  });\n  ```\n\n- **Underscore.js:**\n  ```javascript\n  _.each(myArray, function(value, key) {\n    console.log(value);\n  });\n  ```\n\n- **Lodash:**\n  ```javascript\n  _.forEach(myArray, function(value, key) {\n    console.log(value);\n  });\n  ```</md></sn>","topic_id":595,"last_visited":"2025-02-17T13:36:33.029Z"},{"topic_name":"07.Destructuring an array","topic_html":"<sn><md data-rr=\"true\"><pre>### Destructuring an Array<br><br>**Version ≥ 6**<br><br>#### Basic Destructuring<br>An array can be destructured when assigning it to a new set of variables:<br><br>```javascript<br>const triangle = [3, 4, 5];<br>const [length, height, hypotenuse] = triangle;<br><br>console.log(length === 3);    // → true<br>console.log(height === 4);    // → true<br>console.log(hypotenuse === 5); // → true<br>```<br><br>---<br><br>#### Skipping Elements<br>You can skip elements in the array using commas:<br><br>```javascript<br>const [, b, , c] = [1, 2, 3, 4];<br>console.log(b, c); // → 2, 4<br>```<br><br>---<br><br>#### Using the Rest Operator<br>The rest operator (`...`) can be used to collect the remaining elements of the array:<br><br>```javascript<br>const [b, c, ...xs] = [2, 3, 4, 5];<br>console.log(b, c, xs); // → 2, 3, [4, 5]<br>```<br><br>---<br><br>#### Destructuring in Function Arguments<br>An array can also be destructured directly as a function argument:<br><br>```javascript<br>function area([length, height]) {<br>  return (length * height) / 2;<br>}<br><br>const triangle = [3, 4, 5];<br>console.log(area(triangle)); // → 6<br>```<br><br>&gt; **Note:** The third argument (`hypotenuse`) is not named in the function because it's not needed.<br></pre></md></sn>","topic_id":596,"last_visited":"2024-12-10T07:03:37.775Z"},{"topic_name":"08.Removing duplicate elements","topic_html":"<sn><md data-rr=\"true\"><pre>### Removing Duplicate Elements<br><br>#### Using `Array.prototype.filter`<br>Starting with ES5.1, you can use the `filter` method to remove duplicate elements from an array. The callback function checks if the current value's index matches its first occurrence in the array. If not, it is considered a duplicate and excluded.<br><br>```javascript<br>// Version ≥ 5.1<br>var uniqueArray = ['a', 1, 'a', 2, '1', 1].filter(function(value, index, self) {<br>  return self.indexOf(value) === index;<br>});<br>console.log(uniqueArray); // → ['a', 1, 2, '1']<br>```<br><br>---<br><br>#### Using `Set` for Unique Values<br>In ES6 and later, the `Set` object can be used to store unique values of any type. You can convert the `Set` back to an array using the spread operator (`...`).<br><br>```javascript<br>// Version ≥ 6<br>var uniqueArray = [...new Set(['a', 1, 'a', 2, '1', 1])];<br>console.log(uniqueArray); // → ['a', 1, 2, '1']<br>```<br></pre></md></sn>","topic_id":597,"last_visited":"2024-12-10T07:14:31.054Z"},{"topic_name":"09.Array Comparison","topic_html":"<sn><md data-rr=\"true\"><pre>### Array Comparison<br><br>#### Simple Array Comparison Using `JSON.stringify`<br>You can compare arrays by converting them to JSON strings using `JSON.stringify` and comparing the resulting strings.<br><br>```javascript<br>const array1 = [1, 2, 3];<br>const array2 = [1, 2, 3];<br><br>console.log(JSON.stringify(array1) === JSON.stringify(array2)); // → true<br>```<br><br>**Note**:  <br>- This approach only works for arrays that are JSON-serializable and do not contain cyclic references.  <br>- If the arrays have cyclic references, it will throw an error:  <br>  `TypeError: Converting circular structure to JSON`.<br><br>---<br><br>#### Recursive Function for Array Comparison<br>For a more robust solution, you can use a recursive function to compare arrays element by element.<br><br>```javascript<br>function compareArrays(array1, array2) {<br>  const isA1 = Array.isArray(array1);<br>  const isA2 = Array.isArray(array2);<br><br>  if (isA1 !== isA2) {<br>    // One is an array and the other is not<br>    return false;<br>  }<br><br>  if (!(isA1 &amp;&amp; isA2)) {<br>    // Both are not arrays, compare using strict equality<br>    return array1 === array2;<br>  }<br><br>  if (array1.length !== array2.length) {<br>    // Arrays have different lengths<br>    return false;<br>  }<br><br>  // Compare elements recursively<br>  for (let i = 0; i &lt; array1.length; i++) {<br>    if (!compareArrays(array1[i], array2[i])) {<br>      return false;<br>    }<br>  }<br><br>  return true; // Arrays are equal<br>}<br>```<br><br>---<br><br>#### Example Usage<br><br>```javascript<br>const arr1 = [1, [2, 3], 4];<br>const arr2 = [1, [2, 3], 4];<br>const arr3 = [1, [2, 4], 4];<br><br>console.log(compareArrays(arr1, arr2)); // → true<br>console.log(compareArrays(arr1, arr3)); // → false<br>```<br><br>---<br><br>#### Warning: Cyclic References<br>If either array contains cyclic references (a reference to itself), the recursive function may cause a stack overflow error.<br><br>```javascript<br>const a = [0];<br>a[1] = a; // a contains a reference to itself<br>const b = [0, a];<br><br>try {<br>  console.log(compareArrays(a, b));<br>} catch (err) {<br>  console.error(err); // → RangeError: Maximum call stack size exceeded<br>}<br>```<br><br>**Note**:  <br>The function uses strict equality (`===`) to compare non-array elements. For example:<br><br>```javascript<br>console.log(compareArrays({ a: 0 }, { a: 0 })); // → false<br>```</pre></md></sn>","topic_id":598,"last_visited":"2024-12-10T07:37:31.195Z"},{"topic_name":"10.Reversing Arrays","topic_html":"<sn><md data-rr=\"true\"><pre>### Reversing Arrays<br><br>#### Using `.reverse()`<br>The `.reverse()` method reverses the order of elements in an array **in place**.<br><br>##### Example:<br>```javascript<br>const arr = [1, 2, 3, 4];<br>console.log(arr.reverse()); // → [4, 3, 2, 1]<br>```<br><br>**Note**:  <br>- `.reverse()` modifies the original array instead of creating a new one.  <br>- The same reversed array is returned.<br><br>---<br><br>#### Example of In-Place Reversal:<br>```javascript<br>const arr1 = [11, 22, 33];<br>const arr2 = arr1.reverse();<br><br>console.log(arr2); // → [33, 22, 11]<br>console.log(arr1); // → [33, 22, 11]<br>```<br><br>---<br><br>#### Deep Reversal of Nested Arrays<br>If an array contains nested arrays, you can reverse it **deeply** using a custom function.<br><br>##### Function Definition:<br>```javascript<br>function deepReverse(arr) {<br>  arr.reverse().forEach(elem =&gt; {<br>    if (Array.isArray(elem)) {<br>      deepReverse(elem);<br>    }<br>  });<br>  return arr;<br>}<br>```<br><br>---<br><br>##### Example:<br>```javascript<br>const nestedArr = [1, 2, 3, [1, 2, 3, ['a', 'b', 'c']]];<br>deepReverse(nestedArr);<br><br>console.log(nestedArr);<br>// → [[['c', 'b', 'a'], 3, 2, 1], 3, 2, 1]<br>```<br><br>**Explanation**:  <br>- The outer array and all its nested arrays are reversed recursively.</pre></md></sn>","topic_id":599,"last_visited":"2024-12-10T07:51:48.742Z"},{"topic_name":"11.Shallow Cloning an Array","topic_html":"<sn><md data-rr=\"true\"><pre>### Shallow Cloning an Array  <br><br>Sometimes, you need to work with an array while ensuring you don't modify the original. Instead of a `clone` method, arrays have a `slice` method that lets you perform a shallow copy of any part of an array. Keep in mind:  <br><br>- This only clones the **first level**.  <br>- It works well with **primitive types** (e.g., numbers, strings) but not with objects.  <br><br>#### One-liner for Shallow Cloning  <br>To create a new array instance with the same elements, you can use the following:  <br>```javascript<br>var clone = arrayToClone.slice();<br>```<br><br>This calls the built-in `Array.prototype.slice` method. If you pass arguments to `slice`, you can clone specific parts of the array. However, calling `slice()` without arguments creates a shallow copy of the entire array.<br><br>---<br><br>### Methods for Cloning Arrays  <br><br>#### For ECMAScript Versions ≥ 6  <br>```javascript<br>let arrayToClone = [1, 2, 3, 4, 5];<br><br>let clone1 = Array.from(arrayToClone);<br>let clone2 = Array.of(...arrayToClone);<br>let clone3 = [...arrayToClone]; // the shortest way<br>```<br><br>#### For ECMAScript Versions ≤ 5.1  <br>```javascript<br>var arrayToClone = [1, 2, 3, 4, 5];<br><br>var clone1 = Array.prototype.slice.call(arrayToClone);<br>var clone2 = [].slice.call(arrayToClone);<br>```</pre></md></sn>","topic_id":600,"last_visited":"2024-12-10T08:01:10.310Z"},{"topic_name":"12.Concatenating Arrays","topic_html":"<sn><md data-rr=\"true\"><pre>### Concatenating Arrays  <br><br>#### Concatenating Two Arrays  <br>```javascript<br>var array1 = [1, 2];<br>var array2 = [3, 4, 5];<br>```<br><br>- **Version ≥ 3**  <br>  ```javascript<br>  var array3 = array1.concat(array2); // returns a new array<br>  ```<br><br>- **Version ≥ 6**  <br>  ```javascript<br>  var array3 = [...array1, ...array2];<br>  ```<br><br>**Results in a new array:**  <br>```javascript<br>[1, 2, 3, 4, 5]<br>```<br><br>---<br><br>#### Concatenating Multiple Arrays  <br>```javascript<br>var array1 = [\"a\", \"b\"],<br>    array2 = [\"c\", \"d\"],<br>    array3 = [\"e\", \"f\"],<br>    array4 = [\"g\", \"h\"];<br>```<br><br>- **Version ≥ 3**  <br>  Provide more array arguments to `array.concat()`:<br>  ```javascript<br>  var arrConc = array1.concat(array2, array3, array4);<br>  ```<br><br>- **Version ≥ 6**  <br>  Provide more arguments using the spread operator:<br>  ```javascript<br>  var arrConc = [...array1, ...array2, ...array3, ...array4];<br>  ```<br><br>**Results in a new array:**  <br>```javascript<br>[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]<br>```<br><br>---<br><br>#### Concatenating Without Copying the First Array  <br>```javascript<br>var longArray = [1, 2, 3, 4, 5, 6, 7, 8],<br>    shortArray = [9, 10];<br>```<br><br>- **Version ≥ 3**  <br>  Use `Function.prototype.apply` to pass the elements of `shortArray` as parameters:<br>  ```javascript<br>  longArray.push.apply(longArray, shortArray);<br>  ```<br><br>- **Version ≥ 6**  <br>  Use the spread operator to pass the elements as separate arguments:<br>  ```javascript<br>  longArray.push(...shortArray);<br>  ```<br><br>**The value of `longArray` is now:**  <br>```javascript<br>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>```<br><br>**Note:** If the second array is too long (&gt;100,000 entries), you may get a stack overflow error (due to how `apply` works). To be safe, you can iterate through `shortArray` and push elements manually:<br>```javascript<br>shortArray.forEach(function (elem) {<br>    longArray.push(elem);<br>});<br>```<br><br>---<br><br>#### Concatenating Arrays and Non-Array Values  <br>```javascript<br>var array = [\"a\", \"b\"];<br>```<br><br>- **Version ≥ 3**  <br>  You can concatenate non-array values directly:<br>  ```javascript<br>  var arrConc = array.concat(\"c\", \"d\");<br>  ```<br><br>- **Version ≥ 6**  <br>  Use the spread operator:<br>  ```javascript<br>  var arrConc = [...array, \"c\", \"d\"];<br>  ```<br><br>**Results in a new array:**  <br>```javascript<br>[\"a\", \"b\", \"c\", \"d\"]<br>```<br><br>You can also mix arrays with non-arrays:  <br>```javascript<br>var arr1 = [\"a\", \"b\"];<br>var arr2 = [\"e\", \"f\"];<br>var arrConc = arr1.concat(\"c\", \"d\", arr2);<br>```<br><br>**Results in a new array:**  <br>```javascript<br>[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]<br>```</pre></md></sn>","topic_id":601,"last_visited":"2024-12-10T08:17:12.295Z"},{"topic_name":"13.Merge two array as key value pair","topic_html":"<sn><md data-rr=\"true\"><pre>### Merging Two Arrays as Key-Value Pairs  <br><br>When you have two separate arrays and want to create a key-value pair from them, you can use the `reduce` function of arrays. Here's how you can do it:<br><br>```javascript<br>var columns = [\"Date\", \"Number\", \"Size\", \"Location\", \"Age\"];<br>var rows = [\"2001\", \"5\", \"Big\", \"Sydney\", \"25\"];<br><br>var result = rows.reduce(function(result, field, index) {<br>    result[columns[index]] = field;<br>    return result;<br>}, {});<br><br>console.log(result);<br>```<br><br>**Output:**<br>```javascript<br>{<br>    Date: \"2001\",<br>    Number: \"5\",<br>    Size: \"Big\",<br>    Location: \"Sydney\",<br>    Age: \"25\"<br>}<br>```  <br><br>This code creates a new object where each element from the `rows` array is mapped to the corresponding key from the `columns` array, forming key-value pairs.</pre></md></sn>","topic_id":602,"last_visited":"2024-12-10T08:30:04.278Z"},{"topic_name":"14.Array Spread Rest","topic_html":"<sn><md data-rr=\"true\"><pre>### Array Spread / Rest  <br><br>#### Spread Operator<br><br>**Version ≥ 6**  <br>With ES6, you can use the spread operator to separate individual elements into a comma-separated syntax:<br><br>```javascript<br>let arr = [1, 2, 3, ...[4, 5, 6]]; // [1, 2, 3, 4, 5, 6]<br>```<br><br>In ES &lt; 6, the equivalent operations would be:<br><br>```javascript<br>arr = [1, 2, 3];<br>arr.push(4, 5, 6);<br>```<br><br>The spread operator also works with strings, separating each character into individual string elements. Using an array function to convert these characters into integers:<br><br>```javascript<br>let arr = [1, 2, 3, ...[...\"456\"].map(x =&gt; parseInt(x))]; // [1, 2, 3, 4, 5, 6]<br>```<br><br>Or, with a single string, this can be simplified to:<br><br>```javascript<br>let arr = [...\"123456\"].map(x =&gt; parseInt(x)); // [1, 2, 3, 4, 5, 6]<br>```<br><br>If no mapping is performed, the result will be:<br><br>```javascript<br>let arr = [...\"123456\"]; // [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]<br>```<br><br>The spread operator can also be used to spread arguments into a function:<br><br>```javascript<br>function myFunction(a, b, c) { }<br>let args = [0, 1, 2];<br>myFunction(...args); // equivalent to myFunction(0, 1, 2)<br>```<br><br>In ES &lt; 6, this would be equivalent to:<br><br>```javascript<br>myFunction.apply(null, args);<br>```<br><br>---<br><br>#### Rest Operator<br><br>The rest operator does the opposite of the spread operator by collecting several elements into a single one:<br><br>```javascript<br>[a, b, ...rest] = [1, 2, 3, 4, 5, 6]; // rest is assigned [3, 4, 5, 6]<br>```<br><br>It can also be used to collect arguments in a function:<br><br>```javascript<br>function myFunction(a, b, ...rest) { <br>    console.log(rest); <br>}<br><br>myFunction(0, 1, 2, 3, 4, 5, 6); // rest is [2, 3, 4, 5, 6]<br>```</pre></md></sn>","topic_id":603,"last_visited":"2024-12-10T08:50:09.013Z"},{"topic_name":"15.Filtering Values","topic_html":"<sn><md data-rr=\"true\"><pre>### **Filtering Values**<br><br>The `filter()` method creates an array filled with all elements that pass a test provided as a function.<br><br>---<br><br>#### **Basic Example: Filtering Values Greater Than 2**<br><br>- **Version ≥ 5.1:**<br>  ```javascript<br>  [1, 2, 3, 4, 5].filter(function(value, index, arr) {<br>      return value &gt; 2;<br>  });<br>  ```<br><br>- **Version ≥ 6:**<br>  ```javascript<br>  [1, 2, 3, 4, 5].filter(value =&gt; value &gt; 2);<br>  ```<br><br>**Resulting Array:**<br>```javascript<br>[3, 4, 5]<br>```<br><br>---<br><br>#### **Filter Falsy Values**<br><br>- **Version ≥ 5.1:**<br>  ```javascript<br>  var filtered = [0, undefined, {}, null, '', true, 5].filter(Boolean);<br>  ```<br><br>**Explanation:**<br>The `Boolean` function is used to evaluate each element. It returns `true` for truthy values and `false` for falsy values.  <br>Here's how each value is evaluated:<br><br>1. `Boolean(0)` → `false`  <br>2. `Boolean(undefined)` → `false`  <br>3. `Boolean({})` → `true` → Added to the result array  <br>4. `Boolean(null)` → `false`  <br>5. `Boolean('')` → `false`  <br>6. `Boolean(true)` → `true` → Added to the result array  <br>7. `Boolean(5)` → `true` → Added to the result array  <br><br>**Resulting Array:**<br>```javascript<br>[{}, true, 5]<br>```<br><br>---<br><br>#### **Another Example: Filtering Words Starting with \"A\"**<br><br>This example demonstrates passing a custom function to the `filter()` method.<br><br>- **Version ≥ 5.1:**<br>  ```javascript<br>  function startsWithLetterA(str) {<br>      if (str &amp;&amp; str[0].toLowerCase() == 'a') {<br>          return true;<br>      }<br>      return false;<br>  }<br><br>  var str = 'Since Boolean is a native javascript function/constructor that takes [one optional parameter] and the filter method also takes a function and passes it the current array item as a parameter, you could read it like the following';<br>  var strArray = str.split(\" \");<br>  var wordsStartsWithA = strArray.filter(startsWithLetterA);<br>  ```<br><br>**Resulting Array:**<br>```javascript<br>[\"a\", \"and\", \"also\", \"a\", \"and\", \"array\", \"as\"]<br>```</pre></md></sn>","topic_id":604,"last_visited":"2024-12-10T11:06:30.526Z"},{"topic_name":"16.Searching an Array","topic_html":"<sn><md data-rr=\"true\"><pre>### **Searching an Array**<br><br>---<br><br>#### **Using `Array.prototype.find` (Recommended, Since ES5)**<br><br>The `find()` method returns the first element in the array that satisfies the provided testing function.<br><br>- **Example 1 (Concise):**<br>  ```javascript<br>  let people = [<br>      { name: \"bob\" },<br>      { name: \"john\" }<br>  ];<br>  let bob = people.find(person =&gt; person.name === \"bob\");<br>  ```<br><br>- **Example 2 (Verbose):**<br>  ```javascript<br>  let bob = people.find(function(person) {<br>      return person.name === \"bob\";<br>  });<br>  ```<br><br>---<br><br>#### **Using a `for` Loop (Works in Any JavaScript Version)**<br><br>A `for` loop can also be used to search an array manually.<br><br>```javascript<br>for (var i = 0; i &lt; people.length; i++) {<br>    if (people[i].name === \"bob\") {<br>        break; // we found bob<br>    }<br>}<br>```<br><br>---<br><br>#### **Using `Array.prototype.findIndex`**<br><br>The `findIndex()` method returns the index of the first element in the array that satisfies the provided testing function. If no element is found, it returns `-1`.<br><br>- **Example:**<br>  ```javascript<br>  let array = [<br>      { value: 1 },<br>      { value: 2 },<br>      { value: 3 },<br>      { value: 4 },<br>      { value: 5 }<br>  ];<br><br>  var index = array.findIndex(item =&gt; item.value === 3); // 2<br>  var index = array.findIndex(item =&gt; item.value === 12); // -1<br>  ```<br></pre></md></sn>","topic_id":605,"last_visited":"2024-12-10T11:12:59.648Z"},{"topic_name":"17.String to Array","topic_html":"<sn><md data-rr=\"true\"><pre>### **Convert a String to an Array**<br><br>---<br><br>#### **Using `.split()` Method**<br><br>The `.split()` method splits a string into an array of substrings based on the specified delimiter.<br><br>- **Default Behavior:**  <br>  By default, `.split()` breaks the string into substrings on spaces (`\" \"`), equivalent to calling `.split(\" \")`.<br><br>- **Custom Delimiter:**  <br>  You can pass a character or regular expression to specify how the string should be split.<br><br>- **Example: Split by Empty String (`\"\"`):**  <br>  To split a string into individual characters, use an empty string as the delimiter.  <br>  **Important Note:** This works for most characters in the Unicode lower range (e.g., English and most European languages). It may not work correctly for 3- or 4-byte Unicode characters used in some other languages.<br><br>  ```javascript<br>  var strArray = \"StackOverflow\".split(\"\");<br>  // strArray = [\"S\", \"t\", \"a\", \"c\", \"k\", \"O\", \"v\", \"e\", \"r\", \"f\", \"l\", \"o\", \"w\"]<br>  ```<br><br>---<br><br>#### **Using the Spread Operator (`...`)**<br><br>The spread operator can also be used to convert a string into an array of characters.<br><br>- **Example:**<br>  ```javascript<br>  var strArray = [...\"sky is blue\"];<br>  // strArray = [\"s\", \"k\", \"y\", \" \", \"i\", \"s\", \" \", \"b\", \"l\", \"u\", \"e\"]<br>  ```</pre></md></sn>","topic_id":606,"last_visited":"2024-12-10T11:19:14.451Z"},{"topic_name":"18.Removing Items from an Array","topic_html":"<sn><md data-rr=\"true\"><pre>### **Removing Items from an Array**<br><br>---<br><br>#### **1. `shift()` Method**<br><br>The `shift()` method removes the **first item** from an array.<br><br>- **Example:**<br>  ```javascript<br>  var array = [1, 2, 3, 4];<br>  array.shift();<br>  // array = [2, 3, 4]<br>  ```<br><br>- **Note:** This method returns the removed item.<br><br>---<br><br>#### **2. `pop()` Method**<br><br>The `pop()` method removes the **last item** from an array.<br><br>- **Example:**<br>  ```javascript<br>  var array = [1, 2, 3];<br>  array.pop();<br>  // array = [1, 2]<br>  ```<br><br>- **Note:** This method also returns the removed item.<br><br>---<br><br>#### **3. `splice()` Method**<br><br>The `splice()` method removes a series of elements from an array.<br><br>- **Parameters:**<br>  - Starting index (required)<br>  - Number of elements to delete (optional)  <br>    If omitted, `splice()` removes all elements from the starting index to the end of the array.<br><br>- **Example 1: Removing Specific Items**<br>  ```javascript<br>  var array = [1, 2, 3, 4];<br>  array.splice(1, 2);<br>  // array = [1, 4]<br>  // Returned value = [2, 3]<br>  ```<br><br>- **Example 2: Omitting Second Parameter**<br>  ```javascript<br>  var array = [1, 2, 3, 4];<br>  array.splice(2);<br>  // array = [1, 2]<br>  // Returned value = [3, 4]<br>  ```<br><br>---<br><br>#### **4. `delete` Operator**<br><br>The `delete` operator removes an item from the array **without altering the array's length**.<br><br>- **Example:**<br>  ```javascript<br>  var array = [1, 2, 3, 4, 5];<br>  console.log(array.length); // 5<br><br>  delete array[2];<br>  console.log(array); // [1, 2, undefined, 4, 5]<br>  console.log(array.length); // 5<br>  ```<br><br>---<br><br>#### **5. Modifying `Array.prototype.length`**<br><br>You can directly set the `length` property of an array to truncate it.<br><br>- **Example:**<br>  ```javascript<br>  var array = [1, 2, 3, 4, 5];<br>  array.length = 2;<br>  console.log(array); // [1, 2]<br>  ```</pre></md></sn>","topic_id":607,"last_visited":"2024-12-10T11:26:35.174Z"},{"topic_name":"19.Removing all elements","topic_html":"<sn><md data-rr=\"true\"><pre>### **Removing All Elements from an Array**<br><br>---<br><br>#### **Method 1: Overwriting with a New Array**<br><br>You can create a new array and overwrite the existing array reference.<br><br>- **Example:**<br>  ```javascript<br>  var arr = [1, 2, 3, 4];<br>  arr = [];<br>  ```<br><br>- **Important Note:**  <br>  This method does not actually delete elements from the original array. If the original array is referenced elsewhere (e.g., in a closure), it remains in memory, potentially causing memory leaks.  <br><br>  **Memory Leak Example:**<br>  ```javascript<br>  var count = 0;<br>  function addListener(arr) { // `arr` is closed over<br>      var b = document.body.querySelector(\"#foo\" + (count++));<br>      b.addEventListener(\"click\", function(e) {<br>          // do something but does not need `arr`<br>      });<br>  }<br><br>  arr = [\"big data\"];<br>  var i = 100;<br>  while (i &gt; 0) {<br>      addListener(arr); // `arr` is passed to the function<br>      arr = [];         // only removes the reference; original array remains<br>      arr.push(\"some large data\"); // allocates more memory<br>      i--;<br>  }<br>  ```<br><br>  **Outcome:**  <br>  - 100 arrays are closed over, each referencing a different array.  <br>  - No items are actually deleted, leading to memory leaks.<br><br>---<br><br>#### **Method 2: Setting `length` to 0**<br><br>This method deletes all elements from the array by resetting its `length` property to 0.  <br><br>- **Example:**<br>  ```javascript<br>  var arr = [1, 2, 3, 4];<br>  arr.length = 0;<br>  ```<br><br>- **Benefits:**  <br>  - Keeps the reference to the original array.  <br>  - Most efficient way to clear an array and dereference its items.<br><br>---<br><br>#### **Method 3: Using `splice()`**<br><br>The `splice()` method can remove all elements from an array.  <br><br>- **Example:**<br>  ```javascript<br>  var arr = [1, 2, 3, 4];<br>  arr.splice(0);<br>  ```<br><br>- **When to Use:**  <br>  - Only use this method if you need a new array containing the removed elements.  <br>  - If you don’t need the removed items, this method is inefficient because it creates a new array only to dereference it.<br><br>- **Example with Retained Items:**<br>  ```javascript<br>  var keepArr = arr.splice(0); <br>  // `arr` is now empty<br>  // `keepArr` contains the removed elements<br>  ```<br><br>---<br><br>#### **Recommended Approach**<br><br>- **Use Method 2 (`arr.length = 0`)** for efficiency and to avoid memory leaks.  <br>- Avoid Method 1 if the original array is referenced elsewhere.<br></pre></md></sn>","topic_id":608,"last_visited":"2024-12-10T11:46:20.450Z"},{"topic_name":"20.Finding the minimum or maximum element","topic_html":"<sn><md data-rr=\"true\"><pre>### **Finding the Minimum or Maximum Element**<br><br>---<br><br>#### **1. Using `Math.min.apply` and `Math.max.apply`**<br><br>If your array contains only numeric values, you can use `Math.min.apply` or `Math.max.apply`.<br><br>- **Example:**<br>  ```javascript<br>  var myArray = [1, 2, 3, 4];<br>  Math.min.apply(null, myArray); // 1<br>  Math.max.apply(null, myArray); // 4<br>  ```<br><br>---<br><br>#### **2. Using the Spread Operator (`...`)** (Version ≥ 6)<br><br>With ES6, you can use the spread operator to pass array elements to `Math.min` or `Math.max`.<br><br>- **Example:**<br>  ```javascript<br>  var myArray = [1, 2, 3, 4, 99, 20];<br>  var maxValue = Math.max(...myArray); // 99<br>  var minValue = Math.min(...myArray); // 1<br>  ```<br><br>---<br><br>#### **3. Using a `for` Loop**<br><br>A `for` loop can iterate through the array to determine the minimum or maximum value.<br><br>- **Example:**<br>  ```javascript<br>  var maxValue = myArray[0];<br>  for (var i = 1; i &lt; myArray.length; i++) {<br>      var currentValue = myArray[i];<br>      if (currentValue &gt; maxValue) {<br>          maxValue = currentValue;<br>      }<br>  }<br>  ```<br><br>---<br><br>#### **4. Using `Array.prototype.reduce`** (Version ≥ 5.1)<br><br>The `reduce()` method can find the minimum or maximum value in an array.<br><br>- **Example:**<br>  ```javascript<br>  var myArray = [1, 2, 3, 4];<br><br>  myArray.reduce(function(a, b) {<br>      return Math.min(a, b);<br>  }); // 1<br><br>  myArray.reduce(function(a, b) {<br>      return Math.max(a, b);<br>  }); // 4<br>  ```<br><br>- **With Arrow Functions (Version ≥ 6):**<br>  ```javascript<br>  myArray.reduce((a, b) =&gt; Math.min(a, b)); // 1<br>  myArray.reduce((a, b) =&gt; Math.max(a, b)); // 4<br>  ```<br><br>---<br><br>#### **5. Generalizing `reduce` for Edge Cases**<br><br>To handle edge cases, such as an empty array, pass an initial value to `reduce()`.<br><br>- **Generalized Function:**<br>  ```javascript<br>  function myMax(array) {<br>      return array.reduce(function(maxSoFar, element) {<br>          return Math.max(maxSoFar, element);<br>      }, -Infinity);<br>  }<br><br>  myMax([3, 5]); // 5<br>  myMax([]); // -Infinity<br>  ```<br><br>- **Important Note:**  <br>  Calling `Math.max.apply(null, [])` directly will also return `-Infinity`.<br><br>---<br><br>#### **Recommended Approach**<br><br>- Use the **spread operator** for simplicity if supported (`Math.max(...myArray)`).<br>- Use `reduce()` with an initial value for generalized scenarios.<br></pre></md></sn>","topic_id":609,"last_visited":"2024-12-10T11:59:55.594Z"},{"topic_name":"21.Standard Array Initialization","topic_html":"<sn><md data-rr=\"true\"><pre>### **Standard Array Initialization**<br><br>---<br><br>#### **1. Using Array Literals**<br><br>The most common way to create an array is by using array literals.<br><br>- **Example:**<br>  ```javascript<br>  var arr = [1, 2, 3, 4];<br>  ```<br><br>---<br><br>#### **2. Using the `Array` Constructor**<br><br>You can also use the `Array` constructor to create arrays.<br><br>- **Example:**<br>  ```javascript<br>  var arr2 = new Array(1, 2, 3, 4);<br>  ```<br><br>- **Without Arguments:**  <br>  If the `Array` constructor is called without any arguments, an empty array is created.<br>  ```javascript<br>  var arr3 = new Array();<br>  // arr3 = []<br>  ```<br><br>- **With One Numeric Argument:**  <br>  If called with a single numeric argument, it creates an array of the specified length, filled with `undefined`.<br>  ```javascript<br>  var arr4 = new Array(4);<br>  // arr4 = [undefined, undefined, undefined, undefined]<br>  ```<br><br>- **With One Non-Numeric Argument:**  <br>  If the single argument is non-numeric, the array contains the value as its first element.<br>  ```javascript<br>  var arr5 = new Array(\"foo\");<br>  // arr5 = [\"foo\"]<br>  ```<br><br>---<br><br>#### **3. Using `Array.of`** (Version ≥ 6)<br><br>The `Array.of()` method creates a new array instance from its arguments.<br><br>- **Example:**<br>  ```javascript<br>  Array.of(21, \"Hello\", \"World\");<br>  // Result: [21, \"Hello\", \"World\"]<br>  ```<br><br>- **Key Difference:**  <br>  Unlike the `Array` constructor, `Array.of(23)` creates `[23]` instead of an array with a length of 23.<br><br>---<br><br>#### **4. Using `Array.from`**<br><br>The `Array.from()` method creates a new array from an array-like or iterable object. You can also provide a mapping function to initialize values.<br><br>- **Example:**<br>  ```javascript<br>  var newArray = Array.from({ length: 5 }, (_, index) =&gt; Math.pow(index, 4));<br>  // Result: [0, 1, 16, 81, 256]<br>  ```<br><br>---<br><br>#### **Summary of Array Initialization Methods**<br><br>| **Method**            | **Description**                                                    | **Example**                           | **Result**                                  |<br>|------------------------|--------------------------------------------------------------------|---------------------------------------|---------------------------------------------|<br>| **Array Literal**      | Creates a new array with specified elements.                      | `[1, 2, 3, 4]`                        | `[1, 2, 3, 4]`                              |<br>| **Array Constructor**  | Creates an array based on arguments or length.                   | `new Array(4)`                        | `[undefined, undefined, undefined, undefined]` |<br>| **Array.of()**         | Creates an array with given arguments, even a single number.      | `Array.of(23)`                        | `[23]`                                      |<br>| **Array.from()**       | Creates an array from an iterable or array-like object.           | `Array.from({ length: 5 })`           | `[0, 1, 2, 3, 4]`                           |<br><br></pre></md></sn>","topic_id":610,"last_visited":"2024-12-10T12:02:04.869Z"},{"topic_name":"22.Array to String","topic_html":"<sn><md data-rr=\"true\"><pre>### **Joining Array Elements into a String**<br><br>---<br><br>#### **Using the `join()` Method**<br><br>The `join()` method is used to concatenate all elements of an array into a single string. A specified separator is placed between each element in the resulting string.<br><br>---<br><br>#### **Examples**<br><br>1. **Joining with No Separator**  <br>   ```javascript<br>   console.log([\"Hello\", \" \", \"world\"].join(\"\")); <br>   // Output: \"Hello world\"<br>   ```<br><br>2. **Joining with a Hyphen**  <br>   ```javascript<br>   console.log([1, 800, 555, 1234].join(\"-\")); <br>   // Output: \"1-800-555-1234\"<br>   ```<br><br>---<br><br>#### **Key Notes**<br>- **Automatic Conversion:**  <br>  Elements that are not strings are automatically converted to strings before joining.<br>  - Example: Numbers in the second example are converted to strings before being concatenated.<br><br>- **Default Separator:**  <br>  If no separator is provided, a comma (`,`) is used by default.<br>  ```javascript<br>  console.log([\"apple\", \"banana\", \"cherry\"].join()); <br>  // Output: \"apple,banana,cherry\"<br>  ```</pre></md></sn>","topic_id":611,"last_visited":"2024-12-10T12:19:11.751Z"},{"topic_name":"23.Removing or adding element using splice","topic_html":"<sn><md data-rr=\"true\"><pre>### **Removing/Adding Elements Using `splice()`**<br><br>---<br><br>#### **Removing Elements**<br><br>The `splice()` method can be used to remove elements from an array.  <br>- **Example:** Remove the first occurrence of `3` from the array.<br>  ```javascript<br>  var values = [1, 2, 3, 4, 5, 3];<br>  var i = values.indexOf(3);<br>  if (i &gt;= 0) {<br>      values.splice(i, 1);<br>  }<br>  console.log(values); <br>  // Output: [1, 2, 4, 5, 3]<br>  ```<br><br>---<br><br>#### **Adding Elements**<br><br>The `splice()` method can also be used to insert elements into an array.  <br>- **Example:** Insert `6`, `7`, and `8` at the end of the array.<br>  ```javascript<br>  var values = [1, 2, 4, 5, 3];<br>  var i = values.length;<br>  values.splice(i, 0, 6, 7, 8);<br>  console.log(values); <br>  // Output: [1, 2, 4, 5, 3, 6, 7, 8]<br>  ```<br><br>---<br><br>#### **Key Parameters of `splice()`**<br><br>1. **First Argument:**  <br>   The index at which to start removing or inserting elements.<br><br>2. **Second Argument:**  <br>   The number of elements to remove from the array.  <br>   - Set to `0` if no elements should be removed.<br><br>3. **Third and Subsequent Arguments:**  <br>   The elements to add to the array at the specified index.<br><br>---<br><br>#### **Summary**<br><br>| **Operation** | **Description**                    | **Example**                                      | **Result**                           |<br>|---------------|------------------------------------|------------------------------------------------|--------------------------------------|<br>| **Remove**    | Remove the first occurrence of `3` | `values.splice(i, 1)`                           | `[1, 2, 4, 5, 3]`                   |<br>| **Add**       | Add `6`, `7`, `8` at the end       | `values.splice(values.length, 0, 6, 7, 8)`      | `[1, 2, 4, 5, 3, 6, 7, 8]`          |<br></pre></md></sn>","topic_id":612,"last_visited":"2024-12-10T12:25:00.913Z"},{"topic_name":"24.The entries method","topic_html":"<sn><md data-rr=\"true\"><pre>### **The `entries()` Method**<br><br>---<br><br>#### **Overview**<br><br>The `entries()` method returns a new `Array Iterator` object containing the key/value pairs for each index in the array.<br><br>---<br><br>#### **Version Support**<br><br>- **Introduced in:** ECMAScript 6 (ES6)  <br>- **Note:** This method is **not supported** in Internet Explorer.<br><br>---<br><br>#### **Example Usage**<br><br>Using a `for...of` loop to iterate through the key/value pairs:<br><br>```javascript<br>var letters = ['a', 'b', 'c'];<br><br>for (const [index, element] of letters.entries()) {<br>    console.log(index, element);<br>}<br>```<br><br>**Result:**  <br>```<br>0 \"a\"  <br>1 \"b\"  <br>2 \"c\"<br>```<br><br>---<br><br>#### **Key Notes**<br><br>- The `entries()` method is particularly useful when you need both the index and the element while iterating through an array.<br>- It simplifies access to index-element pairs compared to traditional iteration methods.<br><br>---<br><br>#### **References**<br><br>Portions of this content are derived from `Array.prototype.entries` by Mozilla Contributors, licensed under **CC-by-SA 2.5**.<br></pre></md></sn>","topic_id":613,"last_visited":"2024-12-10T12:26:28.321Z"},{"topic_name":"25.Remove Value from Array","topic_html":"<sn><md data-rr=\"true\"><pre>###  **Remove Value from Array**<br><br>---<br><br>#### **Removing a Specific Value (Without Modifying the Original Array)**<br><br>To remove a specific value from an array and create a new array without that value, you can use the `filter()` method:<br><br>```javascript<br>array.filter(function(val) { return val !== to_remove; });<br>```<br><br>- **Note:** This approach **does not** modify the original array. It returns a new array with the value removed.<br><br>---<br><br>#### **Modifying the Original Array**<br><br>If you need to modify the array directly (e.g., within a function that manipulates the array), use a `while` loop with `indexOf()` and `splice()`:<br><br>```javascript<br>while (index = array.indexOf(3) !== -1) {<br>    array.splice(index, 1);<br>}<br>```<br><br>- This loop will continue removing all occurrences of `3` until none remain.<br><br>---<br><br>#### **Removing Only the First Occurrence**<br><br>If you want to remove only the first occurrence of the value found, you can simplify the process by eliminating the `while` loop:<br><br>```javascript<br>var index = array.indexOf(to_remove);<br>if (index !== -1) {<br>    array.splice(index, 1);<br>}<br>```<br><br>- This snippet will only remove the first occurrence of `to_remove` and will stop after that.<br><br>---<br><br>### **Summary**<br><br>| **Approach**                             | **Effect**                                        |<br>|------------------------------------------|--------------------------------------------------|<br>| **Using `filter()`**                     | Creates a new array without the value (non-destructive). |<br>| **Using `while` + `splice()`**           | Removes all occurrences of the value (destructive). |<br>| **Using `indexOf()` + `splice()` once** | Removes only the first occurrence of the value (destructive). |<br></pre></md></sn>","topic_id":614,"last_visited":"2024-12-10T12:50:15.024Z"},{"topic_name":"26.Flattening Arrays","topic_html":"<sn><md data-rr=\"true\"><pre>### **Flattening Arrays**<br><br>---<br><br>#### **Flattening 2-Dimensional Arrays**<br><br>---<br><br>##### **Version ≥ 6 (ES6)**<br><br>In ES6, you can flatten a 2D array using the spread operator `...`:<br><br>```javascript<br>function flattenES6(arr) {<br>    return [].concat(...arr);<br>}<br><br>var arrL1 = [1, 2, [3, 4]];<br>console.log(flattenES6(arrL1)); // [1, 2, 3, 4]<br>```<br><br>- The spread operator `...` expands the nested arrays into individual elements.<br><br>---<br><br>##### **Version ≥ 5 (ES5)**<br><br>In ES5, you can achieve the same result using `.apply()`:<br><br>```javascript<br>function flatten(arr) {<br>    return [].concat.apply([], arr);<br>}<br><br>var arrL1 = [1, 2, [3, 4]];<br>console.log(flatten(arrL1)); // [1, 2, 3, 4]<br>```<br><br>- The `.apply()` method calls `concat()` on an empty array and passes in the elements of the nested array.<br><br>---<br><br>#### **Flattening Higher-Dimensional Arrays**<br><br>For more deeply nested arrays, such as:<br><br>```javascript<br>var deeplyNested = [4, [5, 6, [7, 8], 9]];<br>```<br><br>You can flatten it using the following method:<br><br>```javascript<br>console.log(String(deeplyNested).split(',').map(Number));<br>// Output: [4, 5, 6, 7, 8, 9]<br>```<br><br>Or:<br><br>```javascript<br>const flatten = deeplyNested.toString().split(',').map(Number);<br>console.log(flatten);<br>// Output: [4, 5, 6, 7, 8, 9]<br>```<br><br>- **Note:** These methods only work when the array consists exclusively of numbers.<br><br>---<br><br>#### **Limitations**<br><br>- These methods do not work for multi-dimensional arrays of objects. They will only correctly flatten arrays of numbers.<br></pre></md></sn>","topic_id":615,"last_visited":"2024-12-10T12:55:29.177Z"},{"topic_name":"27.Append or Prepend items to Array","topic_html":"<sn><md data-rr=\"true\"><pre>### **Append / Prepend Items to Array**<br><br>---<br><br>#### **Unshift: Prepend Items**<br><br>The `.unshift()` method is used to add one or more items to the beginning of an array:<br><br>```javascript<br>var array = [3, 4, 5, 6];<br>array.unshift(1, 2);<br>console.log(array); // [1, 2, 3, 4, 5, 6]<br>```<br><br>- **Result:** The items `1` and `2` are added to the start of the array.<br>- **Return value:** The new array length after the operation.<br><br>---<br><br>#### **Push: Append Items**<br><br>The `.push()` method is used to add one or more items to the end of an array:<br><br>```javascript<br>var array = [1, 2, 3];<br>array.push(4, 5, 6);<br>console.log(array); // [1, 2, 3, 4, 5, 6]<br>```<br><br>- **Result:** The items `4`, `5`, and `6` are added to the end of the array.<br>- **Return value:** The new array length after the operation.<br><br>---<br><br>Both `.unshift()` and `.push()` modify the original array and return the new length of the array.</pre></md></sn>","topic_id":616,"last_visited":"2024-12-10T12:56:12.659Z"},{"topic_name":"28.Object to Array","topic_html":"<sn><md data-rr=\"true\"><pre>### **Object Keys and Values to Array**<br><br>You can convert an object's keys and values into an array of key-value pairs using a `for...in` loop. Here's how:<br><br>```javascript<br>var object = {<br>    key1: 10,<br>    key2: 3,<br>    key3: 40,<br>    key4: 20<br>};<br><br>var array = [];<br>for (var people in object) {<br>    array.push([people, object[people]]);<br>}<br>```<br><br>**Resulting Array:**<br><br>```javascript<br>[<br>    [\"key1\", 10],<br>    [\"key2\", 3],<br>    [\"key3\", 40],<br>    [\"key4\", 20]<br>]<br>```<br><br>- Each element in the array is a sub-array, where the first value is the key and the second value is the corresponding value from the object.<br></pre></md></sn>","topic_id":617,"last_visited":"2024-12-10T13:07:32.501Z"},{"topic_name":"29.Logical Connective of Values","topic_html":"<sn><md data-rr=\"true\"><pre>### **Logical Connective of Values**<br><br>The `.some()` and `.every()` methods allow for logical connections of array values:<br><br>- **`.some()`** combines the return values with **OR** (returns `true` if at least one value is `true`).<br>- **`.every()`** combines the return values with **AND** (returns `true` only if all values are `true`).<br><br>---<br><br>#### **Examples for `.some()`**<br><br>```javascript<br>[false, false].some(function(value) {<br>    return value;<br>});<br>// Result: false<br><br>[false, true].some(function(value) {<br>    return value;<br>});<br>// Result: true<br><br>[true, true].some(function(value) {<br>    return value;<br>});<br>// Result: true<br>```<br><br>- `.some()` returns `true` if at least one element in the array satisfies the condition.<br><br>---<br><br>#### **Examples for `.every()`**<br><br>```javascript<br>[false, false].every(function(value) {<br>    return value;<br>});<br>// Result: false<br><br>[false, true].every(function(value) {<br>    return value;<br>});<br>// Result: false<br><br>[true, true].every(function(value) {<br>    return value;<br>});<br>// Result: true<br>```<br><br>- `.every()` returns `true` only if all elements in the array satisfy the condition.<br><br>---<br><br>These methods are useful for performing logical checks on arrays of boolean values.<br></pre></md></sn>","topic_id":618,"last_visited":"2024-12-10T13:11:51.805Z"},{"topic_name":"30.Checking if an Object is an Array","topic_html":"<sn><md data-rr=\"true\"><pre>### **Checking if an Object is an Array**<br><br>To check if an object is an array, you can use the `Array.isArray()` method, which returns `true` if the object is an array and `false` otherwise.<br><br>---<br><br>#### **Using `Array.isArray()`**<br><br>```javascript<br>Array.isArray([]); // true<br>Array.isArray([1, 2, 3]); // true<br>Array.isArray({}); // false<br>Array.isArray(1); // false<br>```<br><br>- `Array.isArray()` reliably checks if an object is an array.<br><br>---<br><br>#### **Using `instanceof`**<br><br>In most cases, you can also use `instanceof` to check if an object is an array:<br><br>```javascript<br>[] instanceof Array; // true<br>{} instanceof Array; // false<br>```<br><br>- `instanceof` works for most cases but has limitations when the prototype of the array is modified.<br><br>---<br><br>#### **Advantages of `Array.isArray()`**<br><br>- `Array.isArray()` is more robust than `instanceof` because it will return `true` even if the prototype of the array has been modified. It will also return `false` if a non-array object’s prototype is changed to the array prototype.<br><br>Example:<br><br>```javascript<br>var arr = [];<br>Object.setPrototypeOf(arr, null);<br>Array.isArray(arr); // true<br>arr instanceof Array; // false<br>```<br><br>- `Array.isArray()` can handle edge cases where the prototype of an object has been altered.<br></pre></md></sn>","topic_id":619,"last_visited":"2024-12-10T13:18:07.830Z"},{"topic_name":"31.Insert an item into an array at a specific index","topic_html":"<sn><md data-rr=\"true\"><pre>### Insert an Item into an Array at a Specific Index<br><br>**Simple item insertion** can be done using the `Array.prototype.splice` method:<br><br>```javascript<br>arr.splice(index, 0, item);<br>```<br><br>**More advanced insertion** with support for multiple arguments and method chaining:<br><br>```javascript<br>/* Syntax:<br>array.insert(index, value1, value2, ..., valueN)<br>*/<br><br>Array.prototype.insert = function(index) {<br>  this.splice.apply(this, [index, 0].concat(<br>    Array.prototype.slice.call(arguments, 1)<br>  ));<br>  return this;<br>};<br><br>[\"a\", \"b\", \"c\", \"d\"].insert(2, \"X\", \"Y\", \"Z\").slice(1, 6); <br>// Output: [\"b\", \"X\", \"Y\", \"Z\", \"c\"]<br>```<br><br>---<br><br>**Insertion with array-type arguments merging and chaining support**:<br><br>```javascript<br>/* Syntax:<br>array.insert(index, value1, value2, ..., valueN)<br>*/<br><br>Array.prototype.insert = function(index) {<br>  index = Math.min(index, this.length);<br>  if (arguments.length &gt; 1) {<br>    this.splice.apply(this, [index, 0].concat([].pop.call(arguments)));<br>    this.insert.apply(this, arguments);<br>  }<br>  return this;<br>};<br><br>[\"a\", \"b\", \"c\", \"d\"].insert(2, \"V\", [\"W\", \"X\", \"Y\"], \"Z\").join(\"-\");<br>// Output: \"a-b-V-W-X-Y-Z-c-d\"<br>```</pre></md></sn>","topic_id":623,"last_visited":"2024-12-10T13:36:12.183Z"},{"topic_name":"32.Sorting multidimensional array","topic_html":"<sn><md data-rr=\"true\"><pre>### Sorting Multidimensional Array<br><br>Given the following array:<br><br>```javascript<br>var array = [<br>  [\"key1\", 10],<br>  [\"key2\", 3],<br>  [\"key3\", 40],<br>  [\"key4\", 20]<br>];<br>```<br><br>You can sort it by the number (second index) using the following method:<br><br>```javascript<br>array.sort(function(a, b) {<br>  return a[1] - b[1];<br>});<br>```<br><br>Or using the arrow function syntax:<br><br>```javascript<br>array.sort((a, b) =&gt; a[1] - b[1]);<br>```<br><br>This will output:<br><br>```javascript<br>[<br>  [\"key2\", 3],<br>  [\"key1\", 10],<br>  [\"key4\", 20],<br>  [\"key3\", 40]<br>]<br>```<br><br>---<br><br>**Important Note:**<br><br>The `sort()` method operates on the array in place, meaning it directly modifies the original array. Unlike most other array methods that return a new array while leaving the original intact, this behavior is important to note, especially if you're following a functional programming style and expect functions to avoid side effects.<br></pre></md></sn>","topic_id":622,"last_visited":"2024-12-10T13:35:11.524Z"},{"topic_name":"33.Test all Array item for equality","topic_html":"<sn><md data-rr=\"true\"><pre>### **Test All Array Items for Equality**<br><br>The `.every` method is used to test if all array elements pass a provided predicate test. <br><br>---<br><br>#### **Test for Equality (Primitive Values)**<br><br>To test if all array elements are equal to the first item in the array, you can use the following code snippets:<br><br>```javascript<br>[1, 2, 1].every(function(item, i, list) { return item === list[0]; }); // false<br>[1, 1, 1].every(function(item, i, list) { return item === list[0]; }); // true<br>```<br><br>In ES6 or higher, you can use arrow functions for the same check:<br><br>```javascript<br>[1, 1, 1].every((item, i, list) =&gt; item === list[0]); // true<br>```<br><br>---<br><br>#### **Test for Equality of Object Properties**<br><br>To check for property equality in objects, you can use the following approach:<br><br>```javascript<br>let data = [<br>  { name: \"alice\", id: 111 },<br>  { name: \"alice\", id: 222 }<br>];<br><br>data.every(function(item, i, list) { return item === list[0]; }); // false<br>data.every(function(item, i, list) { return item.name === list[0].name; }); // true<br>```<br><br>In ES6 or higher, you can use arrow functions:<br><br>```javascript<br>data.every((item, i, list) =&gt; item.name === list[0].name); // true<br>```</pre></md></sn>","topic_id":621,"last_visited":"2024-12-10T13:28:10.451Z"},{"topic_name":"34.Copy part of an Array","topic_html":"<sn><md data-rr=\"true\"><pre>### **Copy Part of an Array**<br><br>The `slice()` method is used to return a shallow copy of a portion of an array.<br><br>#### **Syntax:**<br><br>```javascript<br>arr.slice([begin[, end]])<br>```<br><br>- **`begin`**: The zero-based index at which to start the extraction (inclusive).<br>- **`end`**: The zero-based index at which to end the extraction (exclusive). If not provided, it slices until the end of the array. <br>- If `end` is a negative number, it is treated as `arr.length + end`.<br><br>---<br><br>#### **Example 1: Slicing a Portion of an Array**<br><br>```javascript<br>// Let's say we have this Array of Alphabets<br>var arr = [\"a\", \"b\", \"c\", \"d\"];<br><br>// I want an Array of the first two Alphabets<br>var newArr = arr.slice(0, 2); // newArr === [\"a\", \"b\"]<br>```<br><br>---<br><br>#### **Example 2: Slicing from a Specific Index to the End**<br><br>```javascript<br>// Let's say we have this Array of Numbers<br>var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];<br><br>// I want to slice this Array starting from number 5 to its end<br>var newArr = arr.slice(4); // newArr === [5, 6, 7, 8, 9]<br>```</pre></md></sn>","topic_id":620,"last_visited":"2024-12-10T13:24:03.222Z"}],"chapter_id":180},{"chapter_name":"13.Ojbects","topics":[{"topic_name":"00.Introduction","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **JavaScript Object Overview**\n\n#### **Definition**\nIn JavaScript, an object is a collection of key-value pairs, where keys are strings (or Symbols) and values can be of any type. Objects are used to store and manipulate data in a structured way.\n\n---\n\n#### **Syntax**\nObjects are defined using curly braces `{}` with properties written as `key: value` pairs.\n\n```javascript\n// Example of an object\nconst person = {\n  name: \"John\",\n  age: 30,\n  isStudent: false,\n};\n```\n\n---\n\n#### **Keywords**\n1. **`const`/`let`/`var`**: Used to declare the object.\n2. **`this`**: Refers to the current object instance, especially useful in object methods.\n3. **`Object`**: A global object used for creating and manipulating objects (e.g., `Object.keys()`, `Object.values()`).\n\n---\n\n#### **When to Use Objects**\n- When you need to group related data and functionality.\n- For creating complex data structures.\n- As a blueprint for reusable components using constructors or classes.\n- When you need to represent real-world entities with properties and behaviors.\n\n---\n\n#### **Importance**\n- **Data Structuring**: Helps organize data logically for better readability and maintainability.\n- **Flexibility**: Allows dynamic addition or modification of properties.\n- **OOP (Object-Oriented Programming)**: Forms the basis of JavaScript's prototype-based inheritance.\n- **Code Reusability**: Enables modular and reusable code through methods like classes and prototypes. \n\nIn short, objects are the backbone of JavaScript, enabling efficient coding practices and robust applications.</md></sn><sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">| **Property**   | **Description**                                                                 |\n|-----------------|---------------------------------------------------------------------------------|\n| `value`        | The value to assign to the property.                                            |\n| `writable`     | Whether the value of the property can be changed or not.                       |\n| `enumerable`   | Whether the property will be enumerated in `for...in` loops or not.            |\n| `configurable` | Whether it will be possible to redefine the property descriptor or not.        |\n| `get`          | A function to be called that will return the value of the property.            |\n| `set`          | A function to be called when the property is assigned a value.                |</md></sn><sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Dot Notation (`Object.property`)**\n- **When to Use:**  \n  Use dot notation when the property name is a valid JavaScript identifier (e.g., no spaces, special characters, or numbers at the start) and is known at the time of writing the code.\n\n- **Advantages:**  \n  - Easier to read and write.\n  - IDEs often provide autocomplete for known properties.\n\n- **Example:**\n  ```javascript\n  const person = { name: \"Alice\", age: 25 };\n  console.log(person.name); // Alice\n  console.log(person.age);  // 25\n  ```\n\n---\n\n### **Bracket Notation (`Object[property]`)**\n- **When to Use:**  \n  - When the property name is stored in a variable or dynamically determined.\n  - If the property name contains spaces, special characters, or is a number.\n  - When accessing properties with symbols.\n\n- **Advantages:**  \n  - Provides more flexibility for dynamic or unconventional property names.\n\n- **Example with a Variable:**\n  ```javascript\n  const key = \"name\";\n  const person = { name: \"Alice\", age: 25 };\n  console.log(person[key]); // Alice\n  ```\n\n- **Example with Special Characters or Spaces:**\n  ```javascript\n  const obj = { \"first name\": \"Alice\", age: 25 };\n  console.log(obj[\"first name\"]); // Alice\n  ```\n\n- **Example with a Symbol:**\n  ```javascript\n  const sym = Symbol(\"id\");\n  const obj = { [sym]: 123 };\n  console.log(obj[sym]); // 123\n  ```\n\n---\n\n### **Key Differences**\n| **Dot Notation**                 | **Bracket Notation**               |\n|-----------------------------------|------------------------------------|\n| Property name must be a valid identifier. | Works with dynamic, special, or invalid identifiers. |\n| Faster and cleaner for static properties. | More versatile for dynamic or unconventional properties. |\n| Throws an error if the property name is invalid. | Doesn't throw errors for invalid names but requires correct string/symbol syntax. |\n\nIn general, use dot notation when possible for simplicity, and bracket notation for dynamic or special cases.</md></sn><sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Example 1 (Incorrect Use of Dot Notation):**\n```javascript\nvar x = { name: 'emon', age: 21 };\nvar student = {};\n\nfor (var key in x) {\n  student.key = x.key; // Incorrect\n}\n\nconsole.log(student); // { key: undefined }\n```\n\n---\n\n### **Example 2 (Correct Use of Bracket Notation):**\n```javascript\nvar x = { name: 'emon', age: 21 };\nvar student = {};\n\nfor (var key in x) {\n  student[key] = x[key]; // Correct\n}\n\nconsole.log(student); // { name: 'emon', age: 21 }\n```</md></sn>","topic_id":745,"last_visited":"2025-02-17T08:54:28.577Z"},{"topic_name":"00.Multiple ways of creating an Object","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Creating Object in may ways**\n\n### 1. **Object Literal Syntax**  \nThe simplest and most common way:\n```javascript\nconst obj = {\n  key1: \"value1\",\n  key2: \"value2\",\n};\n```\n\n---\n\n### 2. **Using `Object.create()`**\nThis creates a new object with a specified prototype object:\n```javascript\nconst proto = { greet: \"Hello\" };\nconst obj = Object.create(proto);\n```\n\n---\n\n### 3. **Using a Constructor Function**\nBefore ES6 classes, this was the traditional way:\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nconst obj = new Person(\"John\", 30);\n```\n\n---\n\n### 4. **Using ES6 Classes**\nA modern and cleaner approach:\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\nconst obj = new Person(\"Jane\", 25);\n```\n\n---\n\n### 5. **Using the `new Object()` Method**\nRarely used but still valid:\n```javascript\nconst obj = new Object();\nobj.key1 = \"value1\";\n```\n\n---\n\n### 6. **Using Factory Functions**\nThis involves creating objects with reusable functions:\n```javascript\nfunction createPerson(name, age) {\n  return {\n    name,\n    age,\n    greet() {\n      return `Hello, my name is ${name}`;\n    },\n  };\n}\nconst obj = createPerson(\"Alice\", 20);\n```\n\n---\n\n### 7. **Using JSON.parse()**\nYou can create objects by parsing JSON strings:\n```javascript\nconst jsonString = '{\"key1\": \"value1\", \"key2\": \"value2\"}';\nconst obj = JSON.parse(jsonString);\n```\n\n---\n\n### 8. **Using Object.assign()**\nYou can create objects by merging properties:\n```javascript\nconst obj = Object.assign({}, { key1: \"value1\", key2: \"value2\" });\n```\n\n---\n\n### 9. **Using the Spread Operator (`...`)**\nA concise way to copy or create objects:\n```javascript\nconst obj = { ...{ key1: \"value1\", key2: \"value2\" } };\n```\n\n---\n\n### 10. **Singleton Pattern**\nUseful for creating a single instance:\n```javascript\nconst obj = new (function () {\n  this.key1 = \"value1\";\n})();\n```\n\n---\n\nEach of these methods has its own use cases. For example, `Object.create()` is great for prototypal inheritance, while factory functions and ES6 classes work well for creating multiple instances of similar objects. What area should we focus on?</md></sn>","topic_id":769,"last_visited":"2025-02-18T13:15:29.571Z"},{"topic_name":"01.Shallow Cloning","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Shallow Cloning**  \n**Version ≥ 6**  \n\n#### **1. Using `Object.assign()`**  \nES6's `Object.assign()` function can be used to copy all enumerable properties (including `Symbol` properties) from an existing object to a new one.  \n\n```javascript\nconst existing = { a: 1, b: 2, c: 3 };\nconst clone = Object.assign({}, existing);\n```\n\n---\n\n#### **2. Using Object Rest/Spread Destructuring**  \nObject rest/spread destructuring (a Stage 3 proposal) provides an even simpler way to create shallow clones of objects:\n\n```javascript\nconst existing = { a: 1, b: 2, c: 3 };\nconst { ...clone } = existing;\n```\n\n---\n\n#### **3. Supporting Older JavaScript Versions**  \nIf you need to support older versions of JavaScript, the most compatible way to clone an object is by manually iterating over its properties and filtering out inherited ones using `.hasOwnProperty()`.\n\n```javascript\nvar existing = { a: 1, b: 2, c: 3 };\nvar clone = {};\n\nfor (var prop in existing) {\n  if (existing.hasOwnProperty(prop)) {\n    clone[prop] = existing[prop];\n  }\n}\n``` </md></sn><sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">The **`hasOwnProperty`** check is used to ensure that only the object's own properties (directly defined on the object) are copied, and **not inherited properties** from the prototype chain. Here's why it's important:\n\n---\n\n### **Why Use `hasOwnProperty`?**\n1. **Prototype Inheritance:**\n   In JavaScript, objects can inherit properties and methods from their prototype. When using a `for...in` loop, it iterates over all enumerable properties, including those inherited from the prototype chain.\n\n   ```javascript\n   const existing = { a: 1, b: 2, c: 3 };\n   Object.prototype.d = 4; // Adds an inherited property\n\n   for (const prop in existing) {\n     console.log(prop); // Outputs: a, b, c, d\n   }\n   ```\n\n2. **Avoid Copying Inherited Properties:**\n   If inherited properties are not filtered out using `hasOwnProperty`, they will also be copied to the new object, which can lead to unintended results.\n\n---\n\n### **How the Code Works**\n\n```javascript\nvar existing = { a: 1, b: 2, c: 3 };\nvar clone = {};\n\nfor (var prop in existing) {\n  if (existing.hasOwnProperty(prop)) { \n    clone[prop] = existing[prop]; // Copies only own properties\n  }\n}\n```\n\n- **Step 1:** The `for...in` loop iterates over all enumerable properties of `existing`, including inherited ones.\n- **Step 2:** The `hasOwnProperty(prop)` check ensures that only properties directly defined on `existing` are processed.\n- **Step 3:** Only those properties are copied to the `clone` object.\n\n---\n\n### **Without `hasOwnProperty`:**\nIf `hasOwnProperty` is not used, inherited properties may be copied unintentionally.\n\n```javascript\nObject.prototype.d = 4; // Adds an inherited property\n\nvar existing = { a: 1, b: 2, c: 3 };\nvar clone = {};\n\nfor (var prop in existing) {\n  clone[prop] = existing[prop]; // Inherits 'd'\n}\n\nconsole.log(clone); // { a: 1, b: 2, c: 3, d: 4 }\n```\n\n---\n\n### **With `hasOwnProperty`:**\nUsing `hasOwnProperty` ensures only the own properties of `existing` are copied.\n\n```javascript\nObject.prototype.d = 4; // Adds an inherited property\n\nvar existing = { a: 1, b: 2, c: 3 };\nvar clone = {};\n\nfor (var prop in existing) {\n  if (existing.hasOwnProperty(prop)) {\n    clone[prop] = existing[prop]; // Copies only 'a', 'b', 'c'\n  }\n}\n\nconsole.log(clone); // { a: 1, b: 2, c: 3 }\n```\n\n---\n\n### **Conclusion:**\nUsing `hasOwnProperty` is essential in `for...in` loops to avoid unintentionally copying properties inherited from the prototype chain, ensuring only the object's own properties are handled.</md></sn>","topic_id":746,"last_visited":"2025-02-17T08:54:17.175Z"},{"topic_name":"02.object freeze","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object.freeze**  \n**Version ≥ 5**\n\n---\n\n#### **Description**  \n`Object.freeze` makes an object immutable by:  \n- Preventing the addition of new properties.  \n- Preventing the removal of existing properties.  \n- Disallowing changes to the enumerability, configurability, and writability of existing properties.  \n- Preventing changes to the values of existing properties.  \n\nHowever, **`Object.freeze` is not recursive**, meaning child objects are not frozen and can still be modified.  \n\n- **Silent Failures:**  \n  Operations attempting to modify the frozen object will fail silently unless the code is running in strict mode.  \n  - In **strict mode**, a `TypeError` will be thrown.\n\n---\n\n#### **Example**\n```javascript\nvar obj = {\n  foo: 'foo',\n  bar: [1, 2, 3],\n  baz: {\n    foo: 'nested-foo'\n  }\n};\n\nObject.freeze(obj);\n\n// Cannot add new properties\nobj.newProperty = true;\n\n// Cannot modify existing values or their descriptors\nobj.foo = 'not foo';\nObject.defineProperty(obj, 'foo', { writable: true });\n\n// Cannot delete existing properties\ndelete obj.foo;\n\n// Nested objects are not frozen\nobj.bar.push(4);        // Works: [1, 2, 3, 4]\nobj.baz.foo = 'new foo'; // Works: 'new foo'\n```\n\n---\n\n### **Key Takeaway**  \nWhile `Object.freeze` prevents modifications to the top-level object, child objects remain mutable unless they are explicitly frozen as well.</md></sn>","topic_id":747,"last_visited":"2025-02-17T10:03:51.090Z"},{"topic_name":"03.Object Cloning","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object Cloning**\n\n---\n\n#### **Description**  \nWhen you want a **complete copy** of an object, including its properties and the values inside those properties, it is called **deep cloning**.\n\n---\n\n#### **Version ≥ 5.1**\n\n##### **Using JSON Methods for Deep Cloning**  \nIf an object can be serialized to JSON, you can create a deep clone using `JSON.parse` and `JSON.stringify`:\n\n```javascript\nvar existing = { a: 1, b: { c: 2 } };\nvar copy = JSON.parse(JSON.stringify(existing));\nexisting.b.c = 3; // copy.b.c will not change\n```\n\n**Note:**  \n- `JSON.stringify` converts `Date` objects to ISO-format string representations.\n- `JSON.parse` does not convert the string back into a `Date`.\n\n---\n\n#### **Limitations of Deep Cloning**\n\nThere is **no built-in function** in JavaScript for deep cloning due to various challenges:\n- Non-enumerable and hidden properties cannot be detected.\n- Object getters and setters cannot be copied.\n- Objects can have cyclic structures.\n- Function properties may depend on hidden state.\n\nHowever, if the object contains only **primitive values**, **dates**, **arrays**, or other simple objects, you can use the following recursive function for deep cloning:\n\n---\n\n#### **Custom Deep Clone Function**\n\n```javascript\nfunction deepClone(obj) {\n  function clone(obj, traversedObjects) {\n    var copy;\n\n    // Handle primitive types\n    if (obj === null || typeof obj !== \"object\") {\n      return obj;\n    }\n\n    // Detect cycles\n    for (var i = 0; i &lt; traversedObjects.length; i++) {\n      if (traversedObjects[i] === obj) {\n        throw new Error(\"Cannot clone circular object.\");\n      }\n    }\n\n    // Handle Date objects\n    if (obj instanceof Date) {\n      copy = new Date();\n      copy.setTime(obj.getTime());\n      return copy;\n    }\n\n    // Handle Arrays\n    if (obj instanceof Array) {\n      copy = [];\n      for (var i = 0; i &lt; obj.length; i++) {\n        copy.push(clone(obj[i], traversedObjects.concat(obj)));\n      }\n      return copy;\n    }\n\n    // Handle simple Objects\n    if (obj instanceof Object) {\n      copy = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          copy[key] = clone(obj[key], traversedObjects.concat(obj));\n        }\n      }\n      return copy;\n    }\n\n    throw new Error(\"Not a cloneable object.\");\n  }\n  \n  return clone(obj, []);\n}\n```\n\n---\n\n### **Key Takeaways**\n- **Deep cloning** creates an independent copy of an object and its nested structures.\n- **Limitations**: Some objects, such as those with non-enumerable properties, cyclic structures, or functions with hidden states, cannot be cloned easily.\n- The custom `deepClone` function works for \"nice\" objects and can detect cyclic references to avoid errors.</md></sn>","topic_id":748,"last_visited":"2025-02-17T10:04:00.325Z"},{"topic_name":"04.Object Properties Iteration","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object Properties Iteration**\n\n---\n\n#### **Description**  \nYou can access and iterate over the properties of an object using the `for...in` loop.\n\n##### **Using `for...in` Loop**\n```javascript\nfor (var property in object) {\n  // Always check if an object has a property\n  if (object.hasOwnProperty(property)) {\n    // Do something with the property\n  }\n}\n```\n\n- **Why use `hasOwnProperty`?**\n  - Objects may have inherited properties from their prototype chain.\n  - **`hasOwnProperty`** ensures you're only working with the object's own properties, avoiding errors from inherited ones.\n\n---\n\n#### **Alternative: Using `Object.keys()`**\n\nYou can also use **`Object.keys()`** to retrieve an array of an object's own properties and then iterate over it using **`Array.map`** or **`Array.forEach`**.\n\n```javascript\nvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\nObject.keys(obj).map(function(key) {\n  console.log(key);\n});\n// Output: 0, 1, 2\n```\n\n- **`Object.keys()`** returns an array of the object's own enumerable property names (excluding inherited properties).\n\n---\n\n### **Key Takeaways**\n- **`for...in`** allows you to loop through all enumerable properties, but ensure to use `hasOwnProperty` to avoid inherited properties.\n- **`Object.keys()`** provides a clean way to access only the object's own properties, and can be used with array iteration methods like `map` or `forEach`.</md></sn>","topic_id":749,"last_visited":"2025-02-17T10:16:02.410Z"},{"topic_name":"05.Object Assign","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object.assign**\n\n---\n\n#### **Description**  \nThe **`Object.assign()`** method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It returns the target object.\n\n---\n\n#### **Use Cases**\n\n##### **Assign Values to an Existing Object**\n```javascript\nvar user = {\n  firstName: \"John\"\n};\nObject.assign(user, { lastName: \"Doe\", age: 39 });\nconsole.log(user); // Logs: { firstName: \"John\", lastName: \"Doe\", age: 39 }\n```\n\n- **Explanation:**  \n  This example shows how to add new properties or update existing ones on the `user` object.\n\n---\n\n##### **Create a Shallow Copy of an Object**\n```javascript\nvar obj = Object.assign({}, user);\nconsole.log(obj); // Logs: { firstName: \"John\", lastName: \"Doe\", age: 39 }\n```\n\n- **Explanation:**  \n  A shallow copy of `user` is created using `Object.assign()`. Changes to the copied object won't affect the original one.\n\n---\n\n##### **Merge Multiple Objects**\n```javascript\nvar obj1 = { a: 1 };\nvar obj2 = { b: 2 };\nvar obj3 = { c: 3 };\nvar obj = Object.assign(obj1, obj2, obj3);\nconsole.log(obj);  // Logs: { a: 1, b: 2, c: 3 }\nconsole.log(obj1); // Logs: { a: 1, b: 2, c: 3 }\n```\n\n- **Explanation:**  \n  Properties from `obj2` and `obj3` are merged into `obj1`. The target object (`obj1`) is modified directly.\n\n---\n\n##### **Handling Primitives**\n```javascript\nvar var_1 = 'abc';\nvar var_2 = true;\nvar var_3 = 10;\nvar var_4 = Symbol('foo');\nvar obj = Object.assign({}, var_1, null, var_2, undefined, var_3, var_4);\nconsole.log(obj); // Logs: { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n```\n\n- **Explanation:**  \n  Primitives are converted to objects. `null` and `undefined` are ignored in the process. Only string wrappers (`var_1`) can have enumerable properties.\n\n---\n\n#### **Using `Object.assign()` as a Reducer (Merge an Array into an Object)**\n```javascript\nreturn users.reduce((result, user) =&gt; Object.assign({}, { [user.id]: user }));\n```\n\n- **Explanation:**  \n  The `reduce()` method is used to merge an array of `user` objects into a single object, where each `user`'s `id` is the key.\n\n---\n\n### **Key Takeaways**\n- **`Object.assign()`** allows you to assign values to an existing object, create a shallow copy, or merge multiple objects.\n- It handles primitive values by wrapping them, but ignores `null` and `undefined`.\n- Be mindful of its **shallow copy** behavior — nested objects are not cloned.</md></sn>","topic_id":750,"last_visited":"2025-02-17T10:27:43.460Z"},{"topic_name":"06.Object Rest Spread","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object Rest/Spread (...)**\n\n---\n\n#### **Description**  \n**Object spreading** is a syntactic sugar for `Object.assign({}, obj1, ..., objn)`. It allows you to copy properties from one or more objects into a new object using the `...` operator.\n\n---\n\n#### **Version &gt; 7**\n\n##### **Using Spread Operator**\n```javascript\nlet obj = { a: 1 };\nlet obj2 = { ...obj, b: 2, c: 3 };\nconsole.log(obj2); // Logs: { a: 1, b: 2, c: 3 }\n```\n\n- **Explanation:**  \n  In this example, `obj2` is created by spreading the properties of `obj` and adding new properties (`b` and `c`).\n\n---\n\n##### **Shallow Merging**\n```javascript\nlet obj3 = { ...obj, b: { c: 2 } };\nconsole.log(obj3); // Logs: { a: 1, b: { c: 2 } }\n```\n\n- **Explanation:**  \n  The spread operator performs a **shallow merge**, so if the object contains nested objects (like `b`), they are not deeply cloned, and the reference is copied.\n\n---\n\n### **Key Takeaways**\n- The **spread operator** (`...`) is a concise way to copy properties from one or more objects into a new object.\n- It only performs a **shallow merge**, meaning nested objects are not deeply cloned.</md></sn>","topic_id":751,"last_visited":"2025-02-17T11:03:14.870Z"},{"topic_name":"07.defineProperty","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object.defineProperty**\n\n---\n\n#### **Description**  \n**`Object.defineProperty()`** allows you to define a property in an existing object using a **property descriptor**.\n\n---\n\n#### **Version ≥ 5**\n\n##### **Basic Usage**\n```javascript\nvar obj = {};\nObject.defineProperty(obj, 'foo', { value: 'foo' });\nconsole.log(obj.foo); // Logs: 'foo'\n```\n\n- **Explanation:**  \n  In this example, the `foo` property is defined in the `obj` object with a value of `'foo'`.\n\n---\n\n#### **Property Descriptor Options**\nYou can define a property with various options using the **property descriptor**:\n\n```javascript\nObject.defineProperty(obj, 'nameOfTheProperty', {\n  value: valueOfTheProperty,\n  writable: true,        // If false, the property is read-only\n  configurable: true,    // If true, the property can be changed later\n  enumerable: true       // If true, the property can be enumerated (e.g., in a for..in loop)\n});\n```\n\n- **Options:**\n  - **value:** The value of the property.\n  - **writable:** If `false`, the property is read-only.\n  - **configurable:** If `true`, the property can be redefined.\n  - **enumerable:** If `true`, the property can be enumerated in loops.\n\n---\n\n#### **Defining Multiple Properties**\nYou can also define multiple properties at once using **`Object.defineProperties()`**:\n\n```javascript\nvar obj = {};\nObject.defineProperties(obj, {\n  property1: {\n    value: true,\n    writable: true\n  },\n  property2: {\n    value: 'Hello',\n    writable: false\n  }\n});\n```\n\n- **Explanation:**  \n  This example defines two properties, `property1` (which is writable) and `property2` (which is read-only).\n\n---\n\n### **Key Takeaways**\n- **`Object.defineProperty()`** is used to define a single property with customizable descriptors.\n- **`Object.defineProperties()`** allows defining multiple properties at once.\n- These methods provide control over property attributes such as **writability**, **configurability**, and **enumerability**.</md></sn>","topic_id":752,"last_visited":"2025-02-17T11:03:04.217Z"},{"topic_name":"08.get set","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Accessor Properties (get and set)**\n\n---\n\n#### **Description**  \nAccessor properties allow you to treat a property as a combination of two functions: one to **get** the value and another to **set** the value.\n\n---\n\n#### **Version ≥ 5**\n\n##### **Using `get` and `set`**\n\n- **`get`**: A function that will be called to retrieve the value of the property.\n- **`set`**: A function that will be called when the property is assigned a new value. The new value is passed as an argument.\n\nYou cannot assign a `value` or `writable` to a descriptor that already has a `get` or `set`.\n\n##### **Example: Using Accessor Properties**\n```javascript\nvar person = { name: \"John\", surname: \"Doe\" };\n\nObject.defineProperty(person, 'fullName', {\n  get: function () {\n    return this.name + \" \" + this.surname;\n  },\n  set: function (value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n});\n\nconsole.log(person.fullName); // Logs: \"John Doe\"\nperson.surname = \"Hill\";\nconsole.log(person.fullName); // Logs: \"John Hill\"\nperson.fullName = \"Mary Jones\";\nconsole.log(person.name); // Logs: \"Mary\"\n```\n\n- **Explanation:**  \n  - The `fullName` property is dynamically calculated using the `get` and `set` functions.\n  - The `get` function combines `name` and `surname` into `fullName`, while the `set` function splits `fullName` and assigns values to `name` and `surname`.\n\n---\n\n### **Key Takeaways**\n- **Accessor properties** allow you to manage property values dynamically using **`get`** and **`set`** methods.\n- You cannot define both a **`get`** and a **`set`** method if the property has a `value` or `writable` descriptor.</md></sn>","topic_id":753,"last_visited":"2025-02-17T11:23:50.621Z"},{"topic_name":"09.Dynamic Property names","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Dynamic / Variable Property Names**\n\n---\n\n#### **Description**  \nIn some situations, you may need to store a property name in a variable. This allows you to dynamically access or set the property of an object.\n\n---\n\n#### **Example: Looking Up a Word in a Dictionary**\n\n```javascript\nvar dictionary = {\n  lettuce: 'a veggie',\n  banana: 'a fruit',\n  tomato: 'it depends on who you ask',\n  apple: 'a fruit',\n  Apple: 'Steve Jobs rocks!' // Properties are case-sensitive\n};\n\nvar word = prompt('What word would you like to look up today?');\nvar definition = dictionary[word];\nalert(word + '\\n\\n' + definition);\n```\n\n- **Explanation:**  \n  - The user is prompted to enter a word, and the corresponding definition is retrieved from the `dictionary` object using **bracket notation**. This allows for dynamic property names.\n  - Note that **case sensitivity** matters, as `Apple` and `apple` are treated as different properties.\n\n---\n\n#### **Bracket Notation vs Dot Notation**\n\n```javascript\nconsole.log(dictionary.word);  // Doesn't work because 'word' is taken literally\nconsole.log(dictionary.apple); // Works because 'apple' is a literal property\nconsole.log(dictionary[word]); // Works because 'word' is a variable\nconsole.log(dictionary[apple]); // Error! 'apple' is not defined as a variable\n```\n\n- **Explanation:**  \n  - Using **dot notation** treats the property name as a literal string, so `dictionary.word` is not valid unless `word` is an actual property name.\n  - **Bracket notation** allows you to use variables to dynamically reference properties.\n\n---\n\n#### **Setting Dynamic Properties**\n\nYou can also **set** dynamic properties using bracket notation:\n\n```javascript\nvar property = \"test\";\nvar obj = {\n  [property]: 1\n};\nconsole.log(obj.test); // Logs: 1\n```\n\n- **Explanation:**  \n  - The value of `property` (`\"test\"`) is used as the key for the object `obj`.\n  - This is equivalent to the following:\n\n```javascript\nvar property = \"test\";\nvar obj = {};\nobj[property] = 1;\nconsole.log(obj.test); // Logs: 1\n```\n\n---\n\n### **Key Takeaways**\n- **Dynamic property names** are used when you want to store the property name in a variable.\n- **Bracket notation** is essential for accessing and setting properties dynamically, while **dot notation** is used for fixed property names.</md></sn>","topic_id":754,"last_visited":"2025-02-17T11:42:17.251Z"},{"topic_name":"10.Arrays are objecs","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Arrays are Objects**\n\n---\n\n#### **Disclaimer**\nCreating array-like objects is generally not recommended. However, understanding how they work is important, especially when working with the DOM. This helps explain why regular array operations do not work on DOM objects returned by many DOM functions like `querySelectorAll` and `form.elements`.\n\n---\n\n#### **Example: Creating Array-like Objects**\n\n```javascript\nvar anObject = {\n  foo: 'bar',\n  length: 'interesting',\n  '0': 'zero!',\n  '1': 'one!'\n};\n```\n\nNow, create an actual array:\n\n```javascript\nvar anArray = ['zero.', 'one.'];\n```\n\nYou can inspect both the object and the array in a similar way:\n\n```javascript\nconsole.log(anArray[0], anObject[0]); // outputs: zero. zero!\nconsole.log(anArray[1], anObject[1]); // outputs: one. one!\nconsole.log(anArray.length, anObject.length); // outputs: 2 interesting\nconsole.log(anArray.foo, anObject.foo); // outputs: undefined bar\n```\n\n---\n\n#### **Array as an Object**\n\nSince `anArray` is actually an object (just like `anObject`), you can even add custom properties to it:\n\n```javascript\nanArray.foo = 'it works!';\nconsole.log(anArray.foo); // outputs: it works!\n```\n\n---\n\n#### **Making an Object Array-like**\n\nYou can make `anObject` behave like an array by adding a `length` property:\n\n```javascript\nanObject.length = 2;\n```\n\nNow, you can use the C-style `for` loop to iterate over `anObject` just as if it were an array. However, note that `anObject` is still an array-like object, not a true array.\n\n---\n\n#### **Key Differences Between Arrays and Array-like Objects**\n\n- **Array-like objects** are similar to arrays but do not have access to array methods such as `push` and `forEach`, which are available on true arrays.\n- DOM functions like `querySelectorAll` and `form.elements` return array-like objects that cannot use array methods unless converted to true arrays.\n\n---\n\n#### **Testing the Type and Instance**\n\n```javascript\nconsole.log(typeof anArray == 'object', typeof anObject == 'object'); // outputs: true true\nconsole.log(anArray instanceof Object, anObject instanceof Object); // outputs: true true\nconsole.log(anArray instanceof Array, anObject instanceof Array); // outputs: true false\nconsole.log(Array.isArray(anArray), Array.isArray(anObject)); // outputs: true false\n```\n\n- `anArray` is an instance of `Array`, while `anObject` is not. \n- Use `Array.isArray()` to check whether an object is a true array.</md></sn>","topic_id":755,"last_visited":"2025-02-17T12:51:54.584Z"},{"topic_name":"11.Object seal","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object.seal**\n\n---\n\n#### **Description**\n`Object.seal` prevents the addition or removal of properties from an object. Once an object is sealed, its property descriptors cannot be converted to another type. However, unlike `Object.freeze`, sealed objects allow modification of existing properties.\n\n---\n\n#### **Behavior**\n- **Adding or Removing Properties:** Prevented.\n- **Modifying Properties:** Allowed if the property is writable.\n- **Changing Property Descriptors:** Not allowed.\n\n---\n\n#### **Example 1: Sealing an Object**\n\n```javascript\nvar obj = { \n  foo: 'foo', \n  bar: function () { return 'bar'; } \n};\n\nObject.seal(obj);\n\n// Cannot add new properties\nobj.newFoo = 'newFoo'; \nconsole.log(obj.newFoo); // undefined\n\n// Can modify existing properties\nobj.bar = function () { return 'foo'; };\nconsole.log(obj.bar()); // 'foo'\n\n// Cannot redefine a property\nObject.defineProperty(obj, 'foo', {\n  get: function () { return 'newFoo'; }\n}); // TypeError\n\n// Cannot change writable to false\nObject.defineProperty(obj, 'foo', {\n  writable: false\n}); // TypeError\n\n// Modifying property value (if writable)\nobj.foo = 'newFoo';\nconsole.log(obj.foo); // 'foo'\n```\n\n---\n\n#### **Example 2: Strict Mode**\n\nIn strict mode, attempts to add or modify properties on a sealed object throw a `TypeError` instead of failing silently.\n\n```javascript\n(function () {\n  'use strict';\n\n  var obj = { foo: 'foo' };\n  Object.seal(obj);\n\n  obj.newFoo = 'newFoo'; // TypeError\n})();\n```\n\n---\n\n#### **Key Notes**\n1. **Sealed Properties:** Existing properties can still be modified unless their `writable` attribute is `false`.\n2. **Silent Failures:** Operations like adding new properties fail silently unless strict mode is enabled.\n3. **Immutability:** To make an object immutable, use `Object.freeze` instead of `Object.seal`.</md></sn>","topic_id":756,"last_visited":"2025-02-17T12:51:39.364Z"},{"topic_name":"12.Object Values to Array","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Convert Object's Values to an Array**\n\n---\n\n#### **Example**\n\nGiven the following object:\n\n```javascript\nvar obj = {\n  a: \"hello\",\n  b: \"this is\",\n  c: \"javascript!\",\n};\n```\n\nYou can convert its values to an array by using `Object.keys` combined with `map`:\n\n```javascript\nvar array = Object.keys(obj).map(function (key) {\n  return obj[key];\n});\n\nconsole.log(array); // [\"hello\", \"this is\", \"javascript!\"]\n```\n\n---\n\n#### **Explanation**\n1. **`Object.keys(obj)`**: Retrieves an array of the object's keys: `['a', 'b', 'c']`.\n2. **`map`**: Loops through each key and returns the corresponding value from the object.\n\nThis approach effectively transforms the values of the object into an array.</md></sn>","topic_id":757,"last_visited":"2025-02-17T12:58:52.812Z"},{"topic_name":"13.Retrieving properties from an object","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Retrieving Properties from an Object**\n\n---\n\n#### **Characteristics of Properties**\n\nProperties in an object can have the following characteristics:  \n1. **Enumerable**  \n2. **Non-Enumerable**  \n3. **Own**  \n\n- **Own Properties**: Properties that exist directly on the object and not on its prototype chain (`__proto__`).  \n- **Enumerable Properties**: Properties that are set to be enumerable can be retrieved using certain methods (e.g., `for..in`). Properties added without `Object.defineProperty` are enumerable by default.\n\n---\n\n#### **Purpose of Enumerability**\n\nThe main purpose of setting a property's enumerability is to control its visibility when retrieving it programmatically using methods like `for..in`, `Object.keys`, etc.\n\n---\n\n#### **Methods to Retrieve Properties**\n\n##### **1. `for..in` Loop**\n- Retrieves **enumerable** properties, both own and inherited (via prototype chain).  \n- Stops traversing the prototype chain when `prototype === null`.\n\n**Examples**  \n- **Simple data**  \n  ```javascript\n  var x = { a: 10, b: 3 }, props = [];\n  for (prop in x) {\n    props.push(prop);\n  }\n  console.log(props); // [\"a\", \"b\"]\n  ```\n\n- **Enumerable properties in the prototype chain**  \n  ```javascript\n  var x = { a: 10, __proto__: { b: 10 } }, props = [];\n  for (prop in x) {\n    props.push(prop);\n  }\n  console.log(props); // [\"a\", \"b\"]\n  ```\n\n- **Non-enumerable properties**  \n  ```javascript\n  var x = { a: 10 }, props = [];\n  Object.defineProperty(x, \"b\", { value: 5, enumerable: false });\n  for (prop in x) {\n    props.push(prop);\n  }\n  console.log(props); // [\"a\"]\n  ```\n\n---\n\n##### **2. `Object.keys()` Function**\n- Retrieves **enumerable own properties**.  \n- Part of ECMAScript 5.\n\n**Examples**  \n- **Simple data**  \n  ```javascript\n  var x = { a: 10, b: 3 };\n  console.log(Object.keys(x)); // [\"a\", \"b\"]\n  ```\n\n- **Enumerable properties in the prototype chain**  \n  ```javascript\n  var x = { a: 10, __proto__: { b: 10 } };\n  console.log(Object.keys(x)); // [\"a\"]\n  ```\n\n- **Non-enumerable properties**  \n  ```javascript\n  var x = { a: 10 };\n  Object.defineProperty(x, \"b\", { value: 5, enumerable: false });\n  console.log(Object.keys(x)); // [\"a\"]\n  ```\n\n---\n\n##### **3. `Object.getOwnPropertyNames()` Function**\n- Retrieves **both enumerable and non-enumerable own properties**.  \n- Part of ECMAScript 5.\n\n**Examples**  \n- **Simple data**  \n  ```javascript\n  var x = { a: 10, b: 3 };\n  console.log(Object.getOwnPropertyNames(x)); // [\"a\", \"b\"]\n  ```\n\n- **Enumerable properties in the prototype chain**  \n  ```javascript\n  var x = { a: 10, __proto__: { b: 10 } };\n  console.log(Object.getOwnPropertyNames(x)); // [\"a\"]\n  ```\n\n- **Non-enumerable properties**  \n  ```javascript\n  var x = { a: 10 };\n  Object.defineProperty(x, \"b\", { value: 5, enumerable: false });\n  console.log(Object.getOwnPropertyNames(x)); // [\"a\", \"b\"]\n  ```\n\n---\n\n#### **Miscellaneous: Retrieving All Properties**\n\nTo retrieve all properties (own, enumerable, non-enumerable, and inherited), use recursion:\n\n```javascript\nfunction getAllProperties(obj, props = []) {\n  return obj == null\n    ? props\n    : getAllProperties(\n        Object.getPrototypeOf(obj),\n        props.concat(Object.getOwnPropertyNames(obj))\n      );\n}\n\nvar x = { a: 10, __proto__: { b: 5, c: 15 } };\nObject.defineProperty(x.__proto__, \"d\", { value: 20, enumerable: false });\n\nconsole.log(getAllProperties(x));\n// [\"a\", \"b\", \"c\", \"d\", \"...other default core props...\"]\n```\n\n**Note**: Supported by browsers implementing ECMAScript 5.\n</md></sn>","topic_id":758,"last_visited":"2025-02-17T13:19:36.048Z"},{"topic_name":"14.Read Only Property","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Read-Only Property**\n\n---\n\n#### **Making a Property Read-Only**\n\nUsing property descriptors, you can make a property **read-only** by setting its `writable` attribute to `false`.  \n- Any attempt to change the value of such a property will fail silently in non-strict mode, and the value will remain unchanged.  \n- In strict mode, a `TypeError` will be thrown when attempting to modify a read-only property.\n\n---\n\n#### **Example**\n\n```javascript\nvar a = {};\nObject.defineProperty(a, 'foo', { value: 'original', writable: false });\n\na.foo = 'new'; // Attempt to change the value\nconsole.log(a.foo); // Output: \"original\"\n```</md></sn>","topic_id":759,"last_visited":"2025-02-17T13:35:53.249Z"},{"topic_name":"15.Non enumerable Property","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Non-Enumerable Property**\n\n---\n\n#### **Making a Property Non-Enumerable**\n\nThe `enumerable` attribute in a property descriptor determines whether a property will appear in `for (... in ...)` loops or `Object.keys()` method results.\n\n- **Enumerable Properties**: Visible during enumeration.  \n- **Non-Enumerable Properties**: Hidden during enumeration but still accessible directly.\n\n---\n\n#### **Example**\n\n```javascript\nvar obj = {};\n\n// Define an enumerable property\nObject.defineProperty(obj, \"foo\", { value: 'show', enumerable: true });\n\n// Define a non-enumerable property\nObject.defineProperty(obj, \"bar\", { value: 'hide', enumerable: false });\n\nfor (var prop in obj) {\n  console.log(obj[prop]);\n}\n```\n\n---\n\n- Only the `foo` property is logged because it is enumerable.  \n- The `bar` property is non-enumerable and does not appear in the loop, but it can still be accessed directly using `obj.bar`.</md></sn>","topic_id":760,"last_visited":"2025-02-17T13:28:27.361Z"},{"topic_name":"16.Lock Property Description","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Lock Property Description**\n\n---\n\n#### **Locking a Property Descriptor**\n\nThe `configurable` attribute in a property descriptor determines whether the descriptor itself can be changed. By setting it to `false`, you lock the property descriptor, preventing further modifications to its attributes.\n\n- **Locked Descriptor**: The property descriptor cannot be redefined.  \n- **Writable Attribute**: The property value can still be assigned if `writable` is `true`.  \n\n---\n\n#### **Example**\n\n```javascript\nvar obj = {};\n\n// Define 'foo' as read-only and lock the descriptor\nObject.defineProperty(obj, \"foo\", {\n  value: \"original value\",\n  writable: false,\n  configurable: false,\n});\n\n// Attempting to redefine the property descriptor\nObject.defineProperty(obj, \"foo\", { writable: true }); // Throws an error\n\n// The property remains read-only\nobj.foo = \"new value\";\nconsole.log(obj.foo); // \"original value\"\n```\n\n---\n\n#### **Error Example**\n\nWhen attempting to redefine a locked descriptor:\n\n```\nTypeError: Cannot redefine property: foo\n```</md></sn>","topic_id":761,"last_visited":"2025-02-17T13:35:40.150Z"},{"topic_name":"17.getOwnPropertyDescriptor","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object.getOwnPropertyDescriptor**\n\n---\n\n#### **Description**\n\nThe `Object.getOwnPropertyDescriptor` method retrieves the property descriptor of a specific property within an object. This includes information about the property's attributes like `value`, `writable`, `enumerable`, and `configurable`.\n\n---\n\n#### **Syntax**\n\n```javascript\nObject.getOwnPropertyDescriptor(object, propertyName);\n```\n\n- **`object`**: The object containing the property.  \n- **`propertyName`**: The name of the property whose descriptor is being retrieved.\n\n---\n\n#### **Example**\n\n```javascript\nvar sampleObject = {\n  hello: 'world',\n};\n\nvar descriptor = Object.getOwnPropertyDescriptor(sampleObject, 'hello');\nconsole.log(descriptor);\n// Output:\n// {\n//   value: \"world\",\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n```\n</md></sn>","topic_id":762,"last_visited":"2025-02-17T13:42:01.415Z"},{"topic_name":"18.Descriptors and Named Properties","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Descriptors and Named Properties**\n\n---\n\n#### **Overview**\n\nProperties are members of an object. Each named property is a combination of:\n\n1. **Name**: A string used to access the property (via dot notation `object.propertyName` or square brackets `object['propertyName']`).\n2. **Descriptor**: A set of fields defining the property's behavior when accessed or modified.\n\n---\n\n#### **Types of Properties**\n\n1. **Data Property**: Associates a name with a value.\n2. **Accessor Property**: Associates a name with one or two accessor functions (`get` and/or `set`).\n\n---\n\n#### **Demonstration**\n\n```javascript\n// Data Property\nobj.propertyName1 = 5;\n// Behind the scenes:\n// For data properties, assigns 5 to the `value` field (if writable: true)\n// For accessor properties, calls the set function with 5 as a parameter\n```\n\nThe type of the property is determined by its descriptor fields, and a property cannot be both types.\n\n---\n\n#### **Descriptors**\n\n1. **Data Descriptor**\n   - Required Fields: `value` or `writable`, or both.\n   - Optional Fields: `configurable`, `enumerable`.\n   - Example:\n\n     ```javascript\n     {\n       value: 10,\n       writable: true\n     }\n     ```\n\n2. **Accessor Descriptor**\n   - Required Fields: `get` or `set`, or both.\n   - Optional Fields: `configurable`, `enumerable`.\n   - Example:\n\n     ```javascript\n     {\n       get: function () {\n         return 10;\n       },\n       enumerable: true\n     }\n     ```\n\n---\n\n#### **Descriptor Fields and Defaults**\n\n| **Field**       | **Default**    | **Description**                                                                 |\n|------------------|----------------|---------------------------------------------------------------------------------|\n| **`configurable`** | `false`        | Determines if the descriptor can be changed or the property deleted.           |\n| **`enumerable`**  | `false`        | Determines if the property appears in enumeration (e.g., `for...in`).           |\n| **`writable`**    | `false`        | Allows the property value to be changed.                                        |\n| **`get`**         | `undefined`    | A getter function for the property.                                             |\n| **`set`**         | `undefined`    | A setter function for the property.                                             |\n| **`value`**       | `undefined`    | The value associated with the property. Can be any valid JavaScript value.      |\n\n---\n\n#### **Example: Data and Accessor Descriptors**\n\n```javascript\nvar obj = { propertyName1: 1 }; \n// The pair is ('propertyName1', { \n//   value: 1, writable: true, enumerable: true, configurable: true \n// })\n\nObject.defineProperty(obj, 'propertyName2', {\n  get: function () {\n    console.log('Accessing propertyName2');\n  },\n  set: function () {\n    console.log('Setting propertyName2');\n  }\n});\n\n// propertyName1: Data property\nobj.propertyName1 = 3;\nconsole.log(obj.propertyName1); // Output: 3\n\n// propertyName2: Accessor property\nobj.propertyName2 = 3; // Logs: \"Setting propertyName2\"\nconsole.log(obj.propertyName2); // Logs: \"Accessing propertyName2\"\n```\n\n---\n\nThis example shows how `propertyName1` is a **data property** and `propertyName2` is an **accessor property**. The respective descriptors define their behavior.</md></sn>","topic_id":763,"last_visited":"2025-02-17T13:54:52.682Z"},{"topic_name":"19.Object Keys","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object.keys**\n\n---\n\n#### **Object.keys Overview**\n\n`Object.keys(obj)` returns an array of a given object's **enumerable** own property names.\n\n---\n\n#### **Example**\n\n```javascript\nvar obj = {\n  a: \"hello\",\n  b: \"this is\",\n  c: \"javascript!\"\n};\n\nvar keys = Object.keys(obj);\nconsole.log(keys); // [\"a\", \"b\", \"c\"]\n```\n\n---\n\n### **Example: Data and Accessor Properties**\n\n#### **Demonstration**\n\n```javascript\nvar obj = { propertyName1: 1 }; \n// This is equivalent to ('propertyName1', { \n//   value: 1, writable: true, enumerable: true, configurable: true \n// })\n\nObject.defineProperty(obj, 'propertyName2', {\n  get: function () {\n    console.log('This will be logged every time propertyName2 is accessed to get its value');\n  },\n  set: function () {\n    console.log('This will be logged every time propertyName2\\'s value is tried to be set');\n  }\n  // By default, enumerable: false, configurable: false\n});\n\n// propertyName1: Data property\nobj.propertyName1 = 3;\nconsole.log(obj.propertyName1); // Output: 3\n\n// propertyName2: Accessor property\nobj.propertyName2 = 3; // Logs: \"This will be logged every time propertyName2's value is tried to be set\"\nconsole.log(obj.propertyName2); // Logs: \"This will be logged every time propertyName2 is accessed to get its value\"\n``` \n\n--- \n\nThis example demonstrates how `propertyName1` (data property) and `propertyName2` (accessor property) behave based on their descriptors.</md></sn>","topic_id":764,"last_visited":"2025-02-17T14:02:06.975Z"},{"topic_name":"20.Reserved Word","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Properties with Special Characters or Reserved Words**\n\n---\n\n#### **Properties with Special Characters**\n\nWhen creating object properties, the dot notation (`myObject.property`) is limited to names consisting of letters, numbers, and underscores. To include special characters (e.g., spaces, emojis, or user-provided content), use bracket notation.\n\n---\n\n#### **Example: Special Characters**\n\n```javascript\nvar myObject = {};\n\nmyObject['special property ☺'] = 'it works!';\nconsole.log(myObject['special property ☺']); // Output: \"it works!\"\n```\n\n---\n\n#### **Properties with All-Digits**\n\nProperties that are numeric (e.g., `123`) also require bracket notation. JavaScript automatically converts numeric property names to strings.\n\n---\n\n#### **Example: All-Digit Properties**\n\n```javascript\nvar myObject = {};\n\nmyObject[123] = 'hi!'; // Number 123 is automatically converted to a string\nconsole.log(myObject['123']); // Output: \"hi!\"\nconsole.log(myObject['12' + '3']); // String concatenation, Output: \"hi!\"\nconsole.log(myObject[120 + 3]); // Arithmetic, still results in 123, Output: \"hi!\"\nconsole.log(myObject[123.0]); // Floating-point number, treated as 123, Output: \"hi!\"\n\n// This does NOT work:\nconsole.log(myObject['123.0']); // Undefined, because '123' != '123.0'\n```\n\n---\n\n#### **Caution: Leading Zeros**\n\nUsing leading zeros in numeric property names is not recommended as JavaScript interprets them as octal notation.\n</md></sn>","topic_id":765,"last_visited":"2025-02-17T14:06:30.307Z"},{"topic_name":"21.Iterable Object","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Creating an Iterable Object**\n\n---\n\n#### **Introduction**\n\nTo create an iterable object in JavaScript (introduced in version ≥ 6), you must define a method at the `Symbol.iterator` key. This method must return an iterator object that implements the `next()` method.\n\n---\n\n#### **Example: Creating an Iterable Object**\n\n```javascript\nvar myIterableObject = {};\n\n// Define the Symbol.iterator method\nmyIterableObject[Symbol.iterator] = function () {\n  // Return the Iterator object\n  return {\n    // Implement the next() method\n    next: function () {\n      if (!this.iterated) {\n        this.iterated = true;\n        // Return the IteratorResult object\n        return {\n          done: false, // iteration is not complete\n          value: 'One' // value of the current iteration\n        };\n      }\n      // When iteration is complete, just return the done property\n      return {\n        done: true\n      };\n    },\n    iterated: false\n  };\n};\n\n// Iterate over the object using a for...of loop\nfor (var c of myIterableObject) {\n  console.log(c); // Output: One\n}\n```\n\n---\n\n#### **Explanation**\n\n1. **Symbol.iterator**: This defines the iterator method on the object.\n2. **Iterator object**: The object returned by the iterator method should have a `next()` function.\n3. **IteratorResult**: The result of each `next()` call is an object with two properties:\n   - `value`: The value of the current iteration.\n   - `done`: A boolean indicating if the iteration is complete.</md></sn>","topic_id":766,"last_visited":"2025-02-17T14:13:49.846Z"},{"topic_name":"22.Object Entries","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Iterating Over Object Entries - `Object.entries()`**\n\n---\n\n#### **Introduction**\n\nThe `Object.entries()` method (introduced in version ≥ 8) returns an array of key-value pairs from the given object. Unlike `Array.prototype.entries()`, it does not return an iterator, but the array returned by `Object.entries()` can still be iterated over.\n\n---\n\n#### **Example: Using `Object.entries()`**\n\n```javascript\nconst obj = {\n  one: 1,\n  two: 2,\n  three: 3\n};\n\n// Calling Object.entries() on the object\nconst entries = Object.entries(obj);\n\nconsole.log(entries);\n// Output: [[\"one\", 1], [\"two\", 2], [\"three\", 3]]\n```\n\n---\n\n#### **Iterating Over Object Entries**\n\nYou can iterate over the key-value pairs of an object using a `for...of` loop with `Object.entries()`.\n\n```javascript\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(key); // \"one\", \"two\", \"three\"\n  console.log(value); // 1, 2, 3\n}\n```\n\n---\n\n#### **Explanation**\n\n- `Object.entries(obj)` returns an array of arrays, where each sub-array contains a key-value pair from the object.\n- The `for...of` loop destructures each entry into `key` and `value`, allowing you to access and manipulate them in the loop body.</md></sn>","topic_id":767,"last_visited":"2025-02-17T14:18:55.065Z"},{"topic_name":"23.Object Values","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Object.values()**\n\n---\n\n#### **Introduction**\n\nThe `Object.values()` method (introduced in version ≥ 8) returns an array of a given object's own enumerable property values, in the same order as they appear in a `for...in` loop. However, a `for...in` loop also enumerates properties in the prototype chain, whereas `Object.values()` only considers the object's own properties.\n\n---\n\n#### **Example: Using `Object.values()`**\n\n```javascript\nvar obj = { 0: 'a', 1: 'b', 2: 'c' };\nconsole.log(Object.values(obj)); // Output: ['a', 'b', 'c']\n```\n</md></sn>","topic_id":768,"last_visited":"2025-02-17T14:23:16.322Z"}],"chapter_id":197},{"chapter_name":"19.Functions","topics":[{"topic_name":"00.Introduction","topic_html":"<sn><h3>Chapter 19 : Functions<br></h3><p>Functions in JavaScript provide organized, reusable code to perform a set of actions. Functions simplify the coding process, prevent redundant logic, and make code easier to follow. This topic describes the declaration and utilization of functions, arguments, parameters, return statements and scope in JavaScript</p><p><a target=\"_blank\" href=\"https://chatgpt.com/c/67838409-805c-8008-bd7b-b4c0e025ca75\">chatGpt Chat\n</a>&nbsp;&nbsp;&nbsp;<a target=\"_blank\" href=\"https://chatgpt.com/share/6783b231-292c-8008-a472-47cce184a519\">ShareLink\n</a></p></sn><sn><h5>Topic List :<br></h5></sn>","topic_id":631,"last_visited":"2025-01-12T08:57:11.558Z"},{"topic_name":"01.Function Scoping","topic_html":"<sn><md data-rr=\"true\"><pre>### Function Scoping<br><br>#### **1. Function Scope**<br>When you define a function, it creates a scope. Everything defined within the function is not accessible by code outside the function. Only code within this scope can see the entities defined inside it.<br><br>```javascript<br>function foo() {<br>  var a = 'hello';<br>  console.log(a); // =&gt; 'hello'<br>}<br><br>console.log(a); // ReferenceError: a is not defined<br>```<br><br>---<br><br>#### **2. Nested Functions**<br>Nested functions are possible in JavaScript, and the same scoping rules apply.<br><br>```javascript<br>function foo() {<br>  var a = 'hello';<br><br>  function bar() {<br>    var b = 'world';<br>    console.log(a); // =&gt; 'hello'<br>    console.log(b); // =&gt; 'world'<br>  }<br><br>  console.log(a); // =&gt; 'hello'<br>  console.log(b); // ReferenceError: b is not defined<br>}<br><br>console.log(a); // ReferenceError: a is not defined<br>console.log(b); // ReferenceError: b is not defined<br>```<br><br>---<br><br>#### **3. Scope Resolution and Reference Climbing**<br>When JavaScript tries to resolve a reference or variable, it starts looking for it in the current scope. If it cannot find the declaration, it climbs up one scope and continues until the declaration is found. If it reaches the global scope and still cannot find the reference, a `ReferenceError` is thrown.<br><br>```javascript<br>var a = 'hello';<br><br>function foo() {<br>  var b = 'world';<br><br>  function bar() {<br>    var c = '!!';<br>    console.log(a); // =&gt; 'hello'<br>    console.log(b); // =&gt; 'world'<br>    console.log(c); // =&gt; '!!'<br>    console.log(d); // ReferenceError: d is not defined<br>  }<br><br>  bar();<br>}<br>```<br><br>---<br><br>#### **4. Variable Shadowing**<br>Scoping can result in \"shadowing,\" where an inner scope's variable with the same name as an outer scope's variable takes precedence.<br><br>```javascript<br>var a = 'hello';<br><br>function foo() {<br>  var a = 'world';<br><br>  function bar() {<br>    console.log(a); // =&gt; 'world'<br>  }<br><br>  bar();<br>}<br>```<br><br>---<br><br>#### **5. `const` and Scoping (ES6 and Above)**<br>The way JavaScript resolves scoping also applies to the `const` keyword. Declaring a variable with `const` means its value cannot be reassigned, but creating a `const` inside a function creates a new scope and a new variable.<br><br>```javascript<br>function foo() {<br>  const a = true;<br><br>  function bar() {<br>    const a = false; // New variable<br>    console.log(a); // =&gt; false<br>  }<br><br>  bar();<br><br>  const a = false; // SyntaxError: Identifier 'a' has already been declared<br>  a = false;       // TypeError: Assignment to constant variable<br>  console.log(a);  // =&gt; true<br>}<br>```<br><br>---<br><br>#### **6. Block Scoping with `let` and `const`**<br>Functions are not the only blocks that create a scope when using `let` or `const`. These declarations have a scope limited to the nearest block statement.<br><br></pre></md></sn>","topic_id":630,"last_visited":"2025-01-12T09:11:57.094Z"},{"topic_name":"02.Currying","topic_html":"<sn><md data-rr=\"true\"><pre>### Currying<br><br>#### **1. What is Currying?**<br>Currying is the transformation of a function with `n` arguments into a sequence of `n` functions, each taking only one argument.<br><br>---<br><br>#### **2. Use Cases of Currying**<br>Currying can be useful in the following scenarios:<br>- When the value of an argument almost never changes (e.g., a conversion factor) but you want to maintain flexibility instead of hardcoding the value as a constant.<br>- When the result of a curried function is useful even before all the functions in the sequence have been executed.<br>- To validate that functions are executed in a specific sequence.<br><br>---<br><br>#### **3. Example: Volume of a Rectangular Prism**<br>The volume of a rectangular prism depends on three factors: length (`l`), width (`w`), and height (`h`).<br><br>##### **Standard Function (Without Currying):**<br>```javascript<br>var prism = function(l, w, h) {<br>  return l * w * h;<br>};<br>```<br><br>##### **Curried Version:**<br>```javascript<br>function prism(l) {<br>  return function(w) {<br>    return function(h) {<br>      return l * w * h;<br>    };<br>  };<br>}<br>```<br><br>##### **ECMAScript 6+ Syntax (Concise Arrow Functions):**<br>```javascript<br>var prism = l =&gt; w =&gt; h =&gt; l * w * h;<br>```<br><br>##### **Calling the Curried Function:**<br>You can calculate the volume by calling:<br>```javascript<br>prism(2)(3)(5); // =&gt; 30<br>```<br><br>---<br><br>#### **4. Currying Limitations in JavaScript**<br>Currying in JavaScript (ES5/6) has limited syntactical flexibility due to the lack of placeholder values. While you can partially apply a function, such as:<br>```javascript<br>var a = prism(2)(3); // Creates a partially applied function<br>```<br>You **cannot** use syntax like:<br>```javascript<br>prism()(3)(5); // This will not work<br>```</pre></md></sn>","topic_id":632,"last_visited":"2025-01-12T09:19:17.120Z"},{"topic_name":"03.IIFE","topic_html":"<sn><md data-rr=\"true\"><pre>### Immediately Invoked Function Expressions (IIFE)<br><br>#### **1. What is an IIFE?**<br>An **Immediately Invoked Function Expression (IIFE)** is a self-executing anonymous function. These functions:<br>- Have access to the surrounding scope.<br>- Are not stored as variables, making their contents and internal variables inaccessible from outside.<br><br>---<br><br>#### **2. Characteristics of IIFE**<br>- IIFE functions **are not hoisted** like standard functions.<br>- They cannot be called by the name they are declared with, even if named.<br><br>---<br><br>#### **3. Examples of IIFE**<br><br>##### **Basic IIFE:**<br>```javascript<br>(function() {<br>  alert(\"I've run - but can't be run again because I'm immediately invoked at runtime, leaving behind only the result I generate\");<br>}());<br>```<br><br>##### **Alternative Syntax:**<br>The closing parenthesis can also be placed directly after the curly brace:<br>```javascript<br>(function() {<br>  alert(\"This is IIFE too.\");<br>})();<br>```<br><br>---<br><br>#### **4. Passing Parameters to an IIFE**<br>You can pass arguments into an IIFE just like any other function:<br>```javascript<br>(function(message) {<br>  alert(message);<br>}(\"Hello World!\"));<br>```<br><br>---<br><br>#### **5. Returning Values from an IIFE**<br>An IIFE can return values to the surrounding scope:<br>```javascript<br>var example = (function() {<br>  return 42;<br>}());<br>console.log(example); // =&gt; 42<br>```<br><br>---<br><br>#### **6. Named IIFE**<br>Though less common, you can name an IIFE. This allows:<br>- Easier debugging (the name appears in the call stack).<br>- Recursion within the IIFE itself.<br><br>```javascript<br>(function namedIIFE() {<br>  throw new Error(\"An error occurred!\"); // The call stack shows 'namedIIFE()'<br>}());<br>```<br><br>---<br><br>#### **7. Expression Conciseness**<br>In contexts where an expression is expected, IIFE notation can be simplified:<br>```javascript<br>var a = function() { return 42 }();<br>console.log(a); // =&gt; 42<br>```<br><br>---<br><br>#### **8. IIFE with Arrow Functions (ES6+):**<br>IIFE can also be written using arrow function syntax:<br>```javascript<br>(() =&gt; console.log(\"Hello!\"))(); // =&gt; Hello!<br>```<br></pre></md></sn><sn><md data-rr=\"true\"><pre>### When to Use an IIFE (Immediately Invoked Function Expression)<br><br>IIFEs are particularly useful in the following scenarios:<br><br>---<br><br>#### **1. Avoiding Global Scope Pollution**<br>If you want to execute code without exposing variables or functions to the global scope, an IIFE ensures that all variables stay private.<br><br>**Example:**<br>```javascript<br>(function() {<br>  var privateVar = \"I won't pollute the global scope!\";<br>  console.log(privateVar);<br>})();<br>console.log(typeof privateVar); // =&gt; undefined<br>```<br><br>---<br><br>#### **2. Initializing Code Once**<br>IIFEs are ideal for running setup or initialization code that only needs to execute once.<br><br>**Example:**<br>```javascript<br>(function() {<br>  console.log(\"Initialization logic runs once!\");<br>})();<br>```<br><br>---<br><br>#### **3. Creating Private Variables**<br>IIFEs can create private variables or methods that are not accessible outside the function, providing encapsulation.<br><br>**Example:**<br>```javascript<br>var counter = (function() {<br>  var count = 0;<br>  return {<br>    increment: function() { count++; },<br>    getCount: function() { return count; }<br>  };<br>})();<br>counter.increment();<br>console.log(counter.getCount()); // =&gt; 1<br>```<br><br>---<br><br>#### **4. Avoiding Variable Collisions**<br>When working in shared environments (e.g., libraries or frameworks), using IIFEs can prevent variable name conflicts by isolating your code.<br><br>**Example:**<br>```javascript<br>(function() {<br>  var $ = \"myLibrary\"; // $ is not jQuery here<br>  console.log($);<br>})();<br>```<br><br>---<br><br>#### **5. Passing Data into a Scope**<br>You can pass data (e.g., configuration or dependency values) into an IIFE to initialize it without modifying external variables.<br><br>**Example:**<br>```javascript<br>(function(config) {<br>  console.log(`Environment: ${config.env}`);<br>})({ env: \"production\" });<br>```<br><br>---<br><br>#### **6. Polyfills and Browser Compatibility**<br>IIFEs are often used to define polyfills or ensure compatibility across different browser environments.<br><br>**Example:**<br>```javascript<br>(function() {<br>  if (!Array.prototype.myCustomMethod) {<br>    Array.prototype.myCustomMethod = function() {<br>      console.log(\"Custom method added!\");<br>    };<br>  }<br>})();<br>```<br><br>---<br><br>#### **7. Event Handlers or Listeners**<br>When attaching event handlers, IIFEs can be used to create a local scope to isolate variables and avoid conflicts.<br><br>**Example:**<br>```javascript<br>document.getElementById(\"btn\").addEventListener(\"click\", (function() {<br>  var counter = 0;<br>  return function() {<br>    counter++;<br>    console.log(`Button clicked ${counter} times`);<br>  };<br>})());<br>```<br><br>---<br><br>In summary, use IIFEs whenever you need **encapsulation**, **privacy**, or **one-time initialization** without polluting the global scope. They are especially helpful in modular code and scenarios requiring controlled variable scopes.</pre></md></sn>","topic_id":633,"last_visited":"2025-01-12T11:53:04.602Z"},{"topic_name":"04.Named Function","topic_html":"<sn><md data-rr=\"true\"><pre>### Named Functions<br><br>#### **1. Named vs Anonymous Functions**<br>Functions in JavaScript can either be **named** or **anonymous**. <br><br>##### **Examples:**<br>```javascript<br>// Named function<br>var namedSum = function sum(a, b) {<br>  return a + b;<br>};<br><br>// Anonymous function<br>var anonSum = function(a, b) {<br>  return a + b;<br>};<br><br>console.log(namedSum(1, 3)); // =&gt; 4<br>console.log(anonSum(1, 3));  // =&gt; 4<br>```<br><br>Even when a function is named, its name is private to its own scope:<br>```javascript<br>var sumTwoNumbers = function sum(a, b) {<br>  return a + b;<br>};<br>console.log(sum(1, 3)); // Uncaught ReferenceError: sum is not defined<br>```<br><br>---<br><br>#### **2. Key Differences Between Named and Anonymous Functions**<br>1. **Debugging:**<br>   - Named functions appear in error messages or stack traces, making debugging easier.<br>   <br>2. **Hoisting:**<br>   - Named functions are hoisted, so they can be called before their declaration.<br>   - Anonymous functions cannot be called before their assignment.<br><br>3. **Recursion:**<br>   - Named functions are better suited for recursion because the function's name can be used within its scope.<br>   - Anonymous functions rely on their outer variable binding, which can lead to errors if reassigned.<br><br>4. **Name Property:**<br>   - ES6 introduced consistent behavior for the `name` property of functions.<br><br>---<br><br>#### **3. Hoisting Comparison**<br><br>##### **Anonymous Function Example:**<br>```javascript<br>foo();<br>var foo = function() {<br>  console.log('bar');<br>};<br>// Uncaught TypeError: foo is not a function<br>```<br><br>##### **Named Function Example:**<br>```javascript<br>foo();<br>function foo() {<br>  console.log('bar');<br>}<br>// Output: 'bar'<br>```<br><br>---<br><br>#### **4. Named Functions in Recursive Scenarios**<br><br>##### **Recursive Anonymous Function:**<br>```javascript<br>var say = function(times) {<br>  if (times &gt; 0) {<br>    console.log('Hello!');<br>    say(times - 1);<br>  }<br>};<br><br>var sayHelloTimes = say;<br>sayHelloTimes(2);<br>// Output:<br>// Hello!<br>// Hello!<br>```<br><br>**Problem:**<br>If the outer variable is reassigned, recursion will break:<br>```javascript<br>var say = function(times) {<br>  if (times &gt; 0) {<br>    console.log('Hello!');<br>    say(times - 1);<br>  }<br>};<br><br>var sayHelloTimes = say;<br>say = \"oops\";<br>sayHelloTimes(2);<br>// Output:<br>// Hello!<br>// Uncaught TypeError: say is not a function<br>```<br><br>##### **Using a Named Function for Recursion:**<br>```javascript<br>var say = function say(times) {<br>  if (times &gt; 0) {<br>    console.log('Hello!');<br>    say(times - 1);<br>  }<br>};<br><br>var sayHelloTimes = say;<br>say = \"oops\";<br>sayHelloTimes(2);<br>// Output:<br>// Hello!<br>// Hello!<br>```<br><br>---<br><br>#### **5. Preventing Reassignment with Named Functions**<br>Named functions cannot be set to `undefined` even from within the function itself:<br>```javascript<br>var say = function say(times) {<br>  say = undefined; // This does nothing<br>  if (times &gt; 0) {<br>    console.log('Hello!');<br>    say(times - 1);<br>  }<br>};<br><br>var sayHelloTimes = say;<br>say = \"oops\";<br>sayHelloTimes(2);<br>// Output:<br>// Hello!<br>// Hello!<br>```<br><br>---<br><br>#### **6. Function `name` Property**<br><br>- **Before ES6:**  <br>  - Named functions had their `name` property set to the function name.  <br>  - Anonymous functions had an empty string as their `name`.<br><br>```javascript<br>var foo = function() {};<br>console.log(foo.name); // Outputs: ''<br>function foo() {}<br>console.log(foo.name); // Outputs: 'foo'<br>```<br><br>- **Post ES6:**  <br>  - Both named and anonymous functions set the `name` property:<br>```javascript<br>var foo = function() {};<br>console.log(foo.name); // Outputs: 'foo'<br><br>var foo = function bar() {};<br>console.log(foo.name); // Outputs: 'bar'<br>```<br></pre></md></sn>","topic_id":634,"last_visited":"2025-01-12T10:09:45.918Z"},{"topic_name":"05.Binding this and arguments","topic_html":"<sn><md data-rr=\"true\"><pre>### Binding `this` and Arguments<br><br>#### **1. The Problem with `this` in JavaScript**<br>When you take a reference to a method (a property that is a function), it usually **forgets the object it was originally attached to**. If the method needs to use `this`, it won't work as expected unless explicitly bound.<br><br>**Example:**<br>```javascript<br>var monitor = {<br>  threshold: 5,<br>  check: function(value) {<br>    if (value &gt; this.threshold) {<br>      this.display(\"Value is too high!\");<br>    }<br>  },<br>  display: function(message) {<br>    alert(message);<br>  }<br>};<br><br>monitor.check(7); // Works: `this` refers to `monitor`<br><br>var badCheck = monitor.check;<br>badCheck(15); // Fails: `this` refers to the global object (window), and `this.threshold` is undefined<br>```<br><br>---<br><br>#### **2. Using `.bind()` to Solve the Problem**<br>The `.bind()` method creates a **new function** with `this` bound to the specified value.<br><br>**Example:**<br>```javascript<br>var check = monitor.check.bind(monitor);<br>check(15); // Works: `this` is explicitly bound to `monitor`<br>```<br><br>You can also bind arguments along with `this`:<br>```javascript<br>var check8 = monitor.check.bind(monitor, 8);<br>check8(); // `value` is fixed to 8, and `this` is bound to `monitor`<br>```<br><br>---<br><br>#### **3. `this` in Strict Mode**<br>- **Non-strict Mode:**  <br>  By default, `this` refers to the global object (e.g., `window` in browsers).<br><br>  ```javascript<br>  window.x = 12;<br>  function example() {<br>    return this.x;<br>  }<br>  console.log(example()); // 12<br>  ```<br><br>- **Strict Mode:**  <br>  `this` is `undefined` by default.<br><br>  ```javascript<br>  window.x = 12;<br>  function example() {<br>    \"use strict\";<br>    return this.x;<br>  }<br>  console.log(example()); // Uncaught TypeError: Cannot read property 'x' of undefined<br>  ```<br><br>---<br><br>#### **4. Bind Operator (`::`)**<br>Introduced in ES7, the **double colon bind operator (`::`)** provides a shorthand for binding `this`.<br><br>**Examples:**<br>```javascript<br>// Long version<br>var log = console.log.bind(console);<br><br>// Short version<br>const log = ::console.log;<br><br>// Calling methods<br>foo.bar.call(foo);         // Long version<br>foo::bar();                // Short version<br><br>foo.bar.call(foo, arg1);   // Long version<br>foo::bar(arg1);            // Short version<br><br>foo.bar.apply(foo, args);  // Long version<br>foo::bar(...args);         // Short version<br>```<br><br>This syntax makes code cleaner and avoids repetitive binding of `this`.<br><br>---<br><br>#### **5. Binding Console Functions**<br>You can bind `console.log` or other methods to ensure `this` points to the console object.<br><br>**Example:**<br>```javascript<br>var log = console.log.bind(console);<br>log(\"Hello\", \"world\"); // Output: Hello world<br>```<br><br>**Why Bind Console Functions?**<br>- Useful for creating a consistent logging mechanism.<br>- Allows integration with custom loggers at runtime.<br><br>**Example Use Case:**<br>```javascript<br>var logger = require(\"appLogger\");<br>var log = logToServer ? logger.log : console.log.bind(console);<br>log(\"This message is either logged locally or sent to the server.\");<br>```<br></pre></md></sn>","topic_id":635,"last_visited":"2025-01-12T10:32:27.343Z"},{"topic_name":"11.Passing Arguments by reference or value","topic_html":"<sn><md data-rr=\"true\"><pre>### Passing Arguments by Reference or Value<br><br>In JavaScript, all arguments are passed **by value**, which means that when a function assigns a new value to an argument variable, the change will **not** be visible to the caller.<br><br>#### **1. Passing by Value (Primitive Types)**<br><br>When a function modifies a primitive type (such as a number or string), the changes do **not** affect the original value:<br><br>```javascript<br>var obj = {a: 2};<br>function myfunc(arg) {<br>  arg = {a: 5};  // Note: This is an assignment to the parameter variable itself<br>}<br>myfunc(obj);<br>console.log(obj.a);  // Output: 2<br>```<br><br>In the example above, assigning a new object to `arg` inside the function doesn't change the original `obj` because the argument is passed by value.<br><br>---<br><br>#### **2. Modifying Properties of Objects (Reference Types)**<br><br>However, when the argument is an object, changes to its properties will be visible to the caller:<br><br>```javascript<br>var obj = {a: 2};<br>function myfunc(arg) {<br>  arg.a = 5;  // Assignment to a property of the argument<br>}<br>myfunc(obj);<br>console.log(obj.a);  // Output: 5<br>```<br><br>Here, the **nested properties** of the object can be modified. This can be seen as a call by reference, since although the function cannot assign a new object to the argument, it can mutate the original object by modifying its properties.<br><br>---<br><br>#### **3. Immutable Primitive Types**<br><br>Primitive values like numbers or strings are immutable, meaning a function cannot mutate them directly:<br><br>```javascript<br>var s = 'say';<br>function myfunc(arg) {<br>  arg += ' hello';  // Assignment to the parameter variable itself<br>}<br>myfunc(s);<br>console.log(s);  // Output: 'say'<br>```<br><br>In this case, the string `s` remains unchanged, because strings are passed by value and cannot be modified directly within the function.<br><br>---<br><br>#### **4. Avoiding Mutation of Caller’s Object**<br><br>If a function wants to mutate an object passed as an argument but doesn't want to actually mutate the caller's object, it can create a copy of the object:<br><br>```javascript<br>var obj = {a: 2, b: 3};<br>function myfunc(arg) {<br>  arg = Object.assign({}, arg);  // Creating a shallow copy of the argument<br>  arg.a = 5;<br>}<br>myfunc(obj);<br>console.log(obj.a);  // Output: 2<br>```<br><br>In this example, `Object.assign()` is used to create a shallow copy of the original object. The original object (`obj`) remains unchanged.<br><br>---<br><br>#### **5. Returning a New Value Instead of Mutating**<br><br>As an alternative to in-place mutation, a function can create and return a new value, which the caller can then assign:<br><br>```javascript<br>var a = 2;<br>function myfunc(arg) {<br>  arg++;  // Increment the argument<br>  return arg;<br>}<br>a = myfunc(a);<br>console.log(a);  // Output: 3<br>```<br><br>In this case, the original variable `a` is updated with the returned value, allowing the caller to keep the new value without directly mutating the argument within the function.<br><br>---<br><br>### **Key Takeaways:**<br>- **Primitive types** (e.g., numbers, strings) are passed by value, and changes to them inside a function do not affect the caller.<br>- **Objects** are passed by reference, so changes to their properties inside a function are visible to the caller.<br>- To avoid mutating the caller’s object, a function can create a copy or return a new value based on the argument.</pre></md></sn>","topic_id":642,"last_visited":"2025-01-12T12:01:58.291Z"},{"topic_name":"12.Function Arguments","topic_html":"<sn><md data-rr=\"true\"><pre>### Function Arguments, \"arguments\" Object, Rest and Spread Parameters<br><br>Functions in JavaScript can take inputs in the form of arguments, which are variables that can be used and assigned inside the function's scope. Below is an example of a simple function that takes two numeric values and returns their sum:<br><br>```javascript<br>function addition(argument1, argument2) {<br>  return argument1 + argument2;<br>}<br>console.log(addition(2, 3)); // Output: 5<br>```<br><br>---<br><br>#### **1. Arguments Object**<br><br>The `arguments` object contains all the function's parameters that are passed to the function, even if they are not explicitly declared. It is an array-like object, but not a real array.<br><br>Example:<br><br>```javascript<br>(function() { <br>  console.log(arguments); <br>})(0, 'str', [2, {3}]); <br>// Output: [0, \"str\", Array[2]]<br>```<br><br>When printing the `arguments` object, the output resembles an array, but it is actually an object:<br><br>```javascript<br>(function() { <br>  console.log(typeof arguments); <br>})(); <br>// Output: object<br>```<br><br>---<br><br>#### **2. Rest Parameters (`...parm`)**<br><br>In ES6, the `...` syntax in a function's parameter list allows you to capture all remaining arguments as an array. This provides the flexibility to invoke a function with an unlimited number of arguments, which are then stored in the variable.<br><br>Example:<br><br>```javascript<br>(function(a, ...b) {<br>  console.log(typeof b + ': ' + b[0] + b[1] + b[2]);<br>})(0, 1, '2', [3], {i: 4});<br>// Output: object: 123<br>```<br><br>In this example:<br>- `a` captures the first argument.<br>- `b` captures all remaining arguments as an array.<br><br>---<br><br>#### **3. Spread Parameters (`...varb`)**<br><br>The `...` syntax can also be used when invoking a function. This allows elements of an array or object to be passed into the function as individual arguments.<br><br>Example:<br><br>```javascript<br>let nums = [2, 42, -1];<br>console.log(...['a', 'b', 'c'], Math.max(...nums)); <br>// Output: a b c 42<br>```<br><br>Here, the spread operator:<br>- Expands `['a', 'b', 'c']` into individual arguments.<br>- Passes the elements of the `nums` array into the `Math.max()` function.<br><br>---<br><br>### **Key Concepts:**<br>- **Arguments Object**: Contains all arguments passed to the function, even if not explicitly declared.<br>- **Rest Parameters**: Captures all remaining arguments as an array, allowing functions to handle any number of arguments.<br>- **Spread Parameters**: Expands arrays or objects into individual arguments when calling a function.</pre></md></sn>","topic_id":641,"last_visited":"2025-01-12T11:40:46.554Z"},{"topic_name":"13.Function Composition","topic_html":"<sn><md data-rr=\"true\"><pre>### Function Composition<br><br>Function composition is a common practice in functional programming where multiple functions are combined into one. This creates a pipeline where data can be passed through, getting modified step-by-step. Think of it as snapping pieces of a track together to form a continuous flow.<br><br>---<br><br>#### **1. Simple Functions for Composition**<br><br>Start by defining some single responsibility functions that can be easily composed:<br><br>```javascript<br>// Function to capitalize the first letter of a string<br>const capitalize = x =&gt; x.replace(/^\\w/, m =&gt; m.toUpperCase());<br><br>// Function to append a signature to the string<br>const sign = x =&gt; x + ',\\nmade with love';<br>```<br><br>---<br><br>#### **2. Composing Functions into a Pipeline**<br><br>Next, compose the functions into a transformation track using a utility function like `compose`:<br><br>```javascript<br>const formatText = compose(capitalize, sign);<br><br>// Using the composed function<br>console.log(formatText('this is an example'));<br>// Output: \"This is an example,\\nmade with love\"<br>```<br><br>In this example:<br>- `capitalize` capitalizes the first letter.<br>- `sign` adds a signature to the string.<br>- The result is a transformed string where both functions are applied in sequence.<br><br>---<br><br>#### **3. Implementing the `compose` Function**<br><br>Composition is typically done using a utility function called `compose`. Here's a simple implementation of `compose` in JavaScript:<br><br>```javascript<br>const compose = (...funs) =&gt;<br>  x =&gt; funs.reduce((ac, f) =&gt; f(ac), x);<br>```<br><br>This `compose` function:<br>- Takes multiple functions as arguments (`funs`).<br>- Uses `reduce` to apply each function in sequence to an initial value (`x`).<br><br>---<br><br>### **Key Takeaways**<br>- Function composition allows you to create complex transformations from simple, single-responsibility functions.<br>- Many JavaScript utility libraries, such as Lodash and Ramda, include `compose` functions, but you can implement your own as shown above.</pre></md></sn>","topic_id":640,"last_visited":"2025-01-12T11:15:37.424Z"},{"topic_name":"14.Get the name of a function object","topic_html":"<sn><md data-rr=\"true\"><pre>### Get the Name of a Function Object<br><br>You can retrieve the name of a function object in JavaScript using different methods based on the version of ECMAScript (ES) being used.<br><br>---<br><br>#### **1. Using ES6 (Version ≥ 6)**<br><br>In ES6, you can directly access the name of a function using the `.name` property.<br><br>```javascript<br>function myFunction() {}<br>console.log(myFunction.name); // Output: \"myFunction\"<br>```<br><br>**Key Points:**<br>- The `.name` property provides the function's name as a string.<br>- This feature is supported in Node.js and all major browsers, except Internet Explorer.<br><br>For more details, refer to the [MDN documentation on `.name`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name).<br><br>---<br><br>#### **2. Using ES5 (Version ≥ 5)**<br><br>In ES5, you can extract the function's name by analyzing its string representation. Here's an example:<br><br>```javascript<br>function functionName(func) {<br>  // Regex explanation:<br>  // - ^function\\s+ matches the word 'function' at the start, followed by whitespace<br>  // - ([\\w\\$]+) captures the function name (valid JS identifiers: letters, digits, $, and _)<br>  // - \\( ensures it's followed by an opening parenthesis<br>  var result = /^function\\s+([\\w\\$]+)\\(/.exec(func.toString());<br>  return result ? result[1] : '';<br>}<br><br>// Example usage:<br>function exampleFunc() {}<br>console.log(functionName(exampleFunc)); // Output: \"exampleFunc\"<br>```<br><br>**How It Works:**<br>- The `toString()` method converts the function into a string representation.<br>- A regular expression is used to extract the name from the string.<br><br>---<br><br>### **Key Points**<br>- Use the ES6 `.name` property when working in environments that support it (simpler and more reliable).<br>- The ES5 approach serves as a fallback for environments without `.name` support.<br>- This technique is useful for debugging or dynamically interacting with functions in your code.</pre></md></sn>","topic_id":639,"last_visited":"2025-01-12T11:09:42.268Z"},{"topic_name":"15.Recursive Function","topic_html":"<sn><md data-rr=\"true\"><pre>### Recursive Function<br><br>A **recursive function** is a function that calls itself within its definition. Recursive functions are useful for solving problems that can be divided into smaller, similar subproblems.<br><br>---<br><br>#### **1. Example: Calculating Factorial**<br>The factorial of a number `n` is the product of all positive integers less than or equal to `n`. A recursive approach to calculate the factorial is as follows:<br><br>```javascript<br>function factorial(n) {<br>  if (n &lt;= 1) {<br>    return 1; // Base case: stops recursion when n is 1 or less<br>  }<br>  return n * factorial(n - 1); // Recursive call<br>}<br><br>console.log(factorial(5)); // Output: 120<br>```<br><br>**How It Works:**<br>- The function repeatedly calls itself with `n - 1` until it reaches the base case (`n &lt;= 1`).<br>- The result of each recursive call is multiplied and returned back up the call stack.<br><br>---<br><br>#### **2. Example: Counting Even Numbers in an Array**<br>A recursive function can also process arrays, like finding the count of even numbers:<br><br>```javascript<br>function countEvenNumbers(arr) {<br>  // Base case: stops recursion when the array is empty<br>  if (arr.length &lt; 1) {<br>    return 0;<br>  }<br><br>  // Remove the first element from the array<br>  var value = arr.shift();<br><br>  // Check if the value is even and add 1 or 0<br>  return ((value % 2 === 0) ? 1 : 0) + countEvenNumbers(arr);<br>}<br><br>console.log(countEvenNumbers([1, 2, 3, 4, 5, 6])); // Output: 3<br>```<br><br>**How It Works:**<br>- The array is progressively reduced using the `shift()` method, which removes and returns the first element.<br>- If the removed value is even (`value % 2 === 0`), `1` is added to the result; otherwise, `0` is added.<br>- The function continues until the array is empty (`arr.length &lt; 1`), at which point it returns `0` to end the recursion.<br><br>---<br><br>#### **3. Importance of Base Cases**<br>Base cases, also known as **sentinel values**, are essential in recursion to prevent infinite loops. They define a stopping condition for the recursion.<br><br>**In the Examples Above:**<br>- **Factorial:** The recursion stops when `n &lt;= 1`.<br>- **Count Even Numbers:** The recursion stops when the array is empty (`arr.length &lt; 1`).<br><br>---<br><br>### **Key Points**<br>- Recursive functions solve problems by breaking them into smaller, similar subproblems.<br>- Each recursive call works on a smaller piece of the problem until reaching the base case.<br>- Properly defined base cases are crucial to prevent infinite recursion.<br>- Recursive solutions are often elegant but may not always be the most efficient for large inputs.</pre></md></sn>","topic_id":638,"last_visited":"2025-01-12T11:03:05.474Z"},{"topic_name":"16.Using the return statement","topic_html":"<sn><md data-rr=\"true\"><pre>### Using the Return Statement<br><br>The `return` statement is a powerful way to output a value from a function. It is particularly useful when the function's context of use is unknown or dynamic.  <br><br>---<br><br>#### **1. Basic Usage of the `return` Statement**<br>The `return` statement allows a function to output a value, which can be used elsewhere in the code.<br><br>```javascript<br>// Function to return the first character of a string<br>function firstChar(stringIn) {<br>  return stringIn.charAt(0);<br>}<br><br>// Using the function's output as an argument for another function<br>console.log(firstChar(\"Hello world\")); // Console output: H<br>```<br><br>---<br><br>#### **2. `return` Ends Function Execution**<br>The `return` statement terminates the execution of a function. Any code following the `return` statement within the same function will not be executed.<br><br>```javascript<br>function firstChar(stringIn) {<br>  console.log(\"The first action of the firstChar function\");<br>  return stringIn.charAt(0); // Function execution ends here<br>  console.log(\"This line will not execute\");<br>}<br><br>console.log(firstChar(\"JS\"));<br>// Console output:<br>// &gt; The first action of the firstChar function<br>// &gt; J<br>```<br><br>---<br><br>#### **3. Multi-Line `return` Statements**<br>While JavaScript typically allows splitting statements across multiple lines for readability, the `return` statement requires special handling.  <br><br>**Incorrect Usage:**<br>```javascript<br>return<br>\"Hi, my name is \" + name + \". \" +<br>\"I'm \" + age + \" years old.\";<br>```<br>Output: `undefined`<br><br>**Explanation:**  <br>In JavaScript, `return` is treated as a complete statement when it appears alone. The subsequent lines will not be considered part of the `return` statement.<br><br>**Correct Usage:**<br>```javascript<br>return \"Hi, my name is \" + name + \". \" +<br>       \"I'm \" + age + \" years old.\";<br>```<br><br>---<br><br>#### **4. Example of Multi-Line `return`:**<br>```javascript<br>var name = \"Bob\";<br>var age = 18;<br><br>function introduction() {<br>  return \"Hi, my name is \" + name + \". \" +<br>         \"I'm \" + age + \" years old.\";<br>}<br><br>console.log(introduction());<br>// Console output: Hi, my name is Bob. I'm 18 years old.<br>```<br><br>---<br><br>### **Key Points:**<br>- The `return` statement is useful for outputting a value from a function.<br>- It ends the function's execution immediately upon being called.<br>- To split a `return` statement across multiple lines, ensure the value begins on the same line as the `return` keyword.</pre></md></sn>","topic_id":637,"last_visited":"2025-01-12T10:52:02.462Z"},{"topic_name":"17.Function as a variable","topic_html":"<sn><md data-rr=\"true\"><pre>### Functions as a Variable<br><br>#### **1. Declaring Functions Normally**<br>A normal function declaration is accessible throughout its context by its name:<br>```javascript<br>function foo() {<br>  // Code<br>}<br>```<br><br>---<br><br>#### **2. Functions as References**<br>Functions can be treated like object references. This allows dynamic assignment based on conditions.  <br><br>**Example:**<br>```javascript<br>var name = 'Cameron';<br>var spouse;<br><br>if (name === 'Taylor') spouse = { name: 'Jordan' };<br>else if (name === 'Cameron') spouse = { name: 'Casey' };<br><br>var spouseName = spouse.name; // 'Casey'<br>```<br><br>Similarly, functions can be assigned to variables and called later:<br>```javascript<br>// Example 1<br>var hashAlgorithm = 'sha1';<br>var hash;<br><br>if (hashAlgorithm === 'sha1') hash = function(value) { /*...*/ };<br>else if (hashAlgorithm === 'md5') hash = function(value) { /*...*/ };<br><br>hash('Fred'); // Call the dynamically assigned function<br>```<br><br>---<br><br>#### **3. Using Named Functions as References**<br>Instead of using anonymous functions, you can assign references to named functions:<br><br>```javascript<br>// Example 2<br>var hashAlgorithm = 'sha1';<br>var hash;<br><br>if (hashAlgorithm === 'sha1') hash = sha1Hash;<br>else if (hashAlgorithm === 'md5') hash = md5Hash;<br><br>hash('Fred'); // Calls the assigned function<br><br>function md5Hash(value) {<br>  // Implementation<br>}<br><br>function sha1Hash(value) {<br>  // Implementation<br>}<br>```<br><br>---<br><br>#### **4. Using Object Properties for Function References**<br>You can store functions as object properties and retrieve them dynamically:<br><br>```javascript<br>// Example 3<br>var hashAlgorithms = {<br>  sha1: function(value) { /**/ },<br>  md5: function(value) { /**/ }<br>};<br><br>var hashAlgorithm = 'sha1';<br>var hash = hashAlgorithms[hashAlgorithm];<br><br>hash('Fred'); // Dynamically calls the appropriate function<br>```<br><br>---<br><br>#### **5. Assigning and Reassigning Function References**<br>Function references can be reassigned between variables, but take care not to confuse a function reference with its return value.<br><br>```javascript<br>// Example 4<br>var a = getValue;<br>var b = a;       // `b` is now a reference to `getValue`.<br>var c = b();     // `b` is invoked, so `c` holds the return value (41).<br><br>function getValue() {<br>  return 41;<br>}<br>```<br><br>---<br><br>#### **6. Returning Functions from Other Functions**<br>A function can return another function as its value. The returned function can be stored or invoked immediately.<br><br>```javascript<br>// Example 5<br>function getHashingFunction(algorithmName) {<br>  if (algorithmName === 'sha1') return function(value) { /**/ };<br>  else if (algorithmName === 'md5') return md5Hash;<br>}<br><br>var hash = getHashingFunction('sha1'); // `hash` holds the returned function<br>hash('Fred'); // Invokes the returned function<br><br>function md5Hash(value) {<br>  // Implementation<br>}<br>```<br><br>**Invoke Immediately:**<br>```javascript<br>// Example 6<br>var hashedValue = getHashingFunction('sha1')('Fred'); <br>```<br><br>---<br><br>#### **7. Hoisting in Function Variables**<br>Unlike normal function declarations, variables assigned to functions are not hoisted. This can cause runtime errors if the variable is used before assignment.<br><br>```javascript<br>// Example of hoisting<br>var functionVariable;<br><br>hoistedFunction();      // Works: Function is hoisted<br>functionVariable();     // Error: undefined is not a function<br><br>function hoistedFunction() {}<br>functionVariable = function() {};<br>```<br><br>**Key Point:** Regular function declarations are hoisted, making them immediately available. Function variables, however, are not hoisted.</pre></md></sn>","topic_id":636,"last_visited":"2025-01-12T10:45:06.084Z"}],"chapter_id":183},{"chapter_name":"21.Prototypes","topics":[{"topic_name":"02.Conversation with chatgpt","topic_html":"<sn><p class=\"text-end text-light\">how many ways an object can be created in javascipt</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">There are several ways to create objects in JavaScript. Here's a breakdown of the most common ones:\n\n### 1. **Object Literal Syntax**  \nThe simplest and most common way:\n```javascript\nconst obj = {\n  key1: \"value1\",\n  key2: \"value2\",\n};\n```\n\n---\n\n### 2. **Using `Object.create()`**\nThis creates a new object with a specified prototype object:\n```javascript\nconst proto = { greet: \"Hello\" };\nconst obj = Object.create(proto);\n```\n\n---\n\n### 3. **Using a Constructor Function**\nBefore ES6 classes, this was the traditional way:\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nconst obj = new Person(\"John\", 30);\n```\n\n---\n\n### 4. **Using ES6 Classes**\nA modern and cleaner approach:\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\nconst obj = new Person(\"Jane\", 25);\n```\n\n---\n\n### 5. **Using the `new Object()` Method**\nRarely used but still valid:\n```javascript\nconst obj = new Object();\nobj.key1 = \"value1\";\n```\n\n---\n\n### 6. **Using Factory Functions**\nThis involves creating objects with reusable functions:\n```javascript\nfunction createPerson(name, age) {\n  return {\n    name,\n    age,\n    greet() {\n      return `Hello, my name is ${name}`;\n    },\n  };\n}\nconst obj = createPerson(\"Alice\", 20);\n```\n\n---\n\n### 7. **Using JSON.parse()**\nYou can create objects by parsing JSON strings:\n```javascript\nconst jsonString = '{\"key1\": \"value1\", \"key2\": \"value2\"}';\nconst obj = JSON.parse(jsonString);\n```\n\n---\n\n### 8. **Using Object.assign()**\nYou can create objects by merging properties:\n```javascript\nconst obj = Object.assign({}, { key1: \"value1\", key2: \"value2\" });\n```\n\n---\n\n### 9. **Using the Spread Operator (`...`)**\nA concise way to copy or create objects:\n```javascript\nconst obj = { ...{ key1: \"value1\", key2: \"value2\" } };\n```\n\n---\n\n### 10. **Singleton Pattern**\nUseful for creating a single instance:\n```javascript\nconst obj = new (function () {\n  this.key1 = \"value1\";\n})();\n```\n\n---\n\nEach of these methods has its own use cases. For example, `Object.create()` is great for prototypal inheritance, while factory functions and ES6 classes work well for creating multiple instances of similar objects. What area should we focus on?</md></sn><sn><p class=\"text-end text-light\">so as i know every new object has two main things one is his own unique properties and second is his prototype is it true or are there something else outside this</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">Yes, you're correct in saying that every JavaScript object has two main aspects:\n\n1. **Own Properties**: These are the properties that are directly attached to the object itself. They are not inherited from any prototype. For example:\n\n   ```javascript\n   const obj = {\n     name: \"Alice\",\n     age: 30\n   };\n   ```\n\n   In this case, `name` and `age` are own properties of the `obj` object.\n\n2. **Prototype**: Every object in JavaScript also has a prototype, which is another object that it inherits properties and methods from. This allows objects to share behavior. Every object created from a constructor function or class has access to its prototype chain. The prototype itself is an object, and it may also have its own prototype, and so on, forming a chain of inheritance.\n\n   For example:\n   ```javascript\n   const obj = { name: \"Alice\" };\n   console.log(obj.__proto__); // This would show the prototype object (usually from Object.prototype)\n   ```\n\n---\n\n### Additional Considerations:\n\nThere are a few other things that can be present in an object:\n\n3. **Prototype Chain**: The prototype of an object can also have its own prototype, creating a chain. JavaScript objects inherit from their prototypes, which in turn inherit from other prototypes. The top of the chain is `Object.prototype`, which has basic methods like `toString()`, `hasOwnProperty()`, and `valueOf()`.\n\n   ```javascript\n   const obj = { name: \"Alice\" };\n   console.log(obj.__proto__.__proto__); // Object.prototype\n   ```\n\n4. **Internal Slots (Hidden Properties)**: JavaScript engines use hidden internal slots and methods that are not directly accessible from the code. For example, `[[Prototype]]`, `[[Class]]`, and `[[Scopes]]` are internal slots. These are part of the internal mechanisms that support features like prototypal inheritance, scopes, and the `this` keyword.\n\n5. **Getter/Setter Methods**: In addition to properties, objects can have **getter** and **setter** methods, which allow you to define custom behaviors when accessing or modifying an object's properties.\n\n   ```javascript\n   const obj = {\n     _name: \"Alice\",\n     get name() {\n       return this._name;\n     },\n     set name(value) {\n       this._name = value;\n     }\n   };\n   ```\n\n   Here, `name` acts like a property, but it's actually a getter/setter.\n\n6. **Non-enumerable Properties**: Objects also have properties that are non-enumerable, meaning they won't show up in loops like `for...in` or when using `Object.keys()`. These are used internally or to define private data.\n\n7. **Non-configurable Properties**: These properties cannot be deleted or modified. For example, properties defined using `Object.defineProperty()` with specific descriptors.\n\n---\n\nIn summary, yes, the two main things are the **own properties** and the **prototype**, but there's more under the hood that deals with inheritance, internal slots, and other JavaScript engine-specific mechanics. Does this help clarify the full picture of objects in JavaScript?</md></sn><sn><p class=\"text-end text-light\">does the own properties came from contructor function ,or not</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">Yes, **own properties** can indeed come from the constructor function, but it depends on how the object is created. Let's clarify:\n\n### When Object Own Properties Come From a Constructor Function:\n\nIf you're using a **constructor function** (or **class**) to create an object, the own properties of that object are typically defined within the constructor. These properties are then set on the instance of the object.\n\n#### Example with Constructor Function:\n```javascript\nfunction Person(name, age) {\n  this.name = name;  // own property\n  this.age = age;    // own property\n}\n\nconst person1 = new Person(\"Alice\", 30);\nconsole.log(person1.name); // \"Alice\"\nconsole.log(person1.age);  // 30\n```\n\nIn this case, `name` and `age` are **own properties** of the object `person1`, and they were created by the `Person` constructor.\n\n#### Example with Class Syntax (ES6):\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;  // own property\n    this.age = age;    // own property\n  }\n}\n\nconst person1 = new Person(\"Bob\", 25);\nconsole.log(person1.name); // \"Bob\"\nconsole.log(person1.age);  // 25\n```\n\nIn this example, `name` and `age` are also **own properties** of the object `person1`, and they are created by the `constructor` of the `Person` class.\n\n### When Own Properties Do NOT Come From a Constructor Function:\n\n- If you're creating an object **literally**, as with the object literal syntax, the own properties are directly defined in the object, not through a constructor.\n\n   ```javascript\n   const person = {\n     name: \"John\",\n     age: 35\n   };\n   ```\n\n   Here, `name` and `age` are **own properties**, but they weren't created by a constructor function; they were directly specified in the object literal.\n\n### Prototype vs Own Properties:\n\n- **Own properties** are defined directly on the object itself (either via a constructor function or a literal).\n- **Prototype properties** are inherited from the object's prototype, and they are not considered \"own\" properties. For example:\n\n   ```javascript\n   function Person(name) {\n     this.name = name;\n   }\n\n   Person.prototype.greet = function() {\n     return `Hello, my name is ${this.name}`;\n   };\n\n   const person1 = new Person(\"Alice\");\n   console.log(person1.name);    // own property\n   console.log(person1.greet()); // inherited from prototype\n   ```\n\nHere, `name` is an **own property** of `person1`, but `greet()` is not. It's inherited from the `Person.prototype`.\n\n### Summary:\n\n- **Yes**, own properties can come from a constructor function if you're using that function to create the object.\n- However, if you're creating an object via an **object literal** or other methods (like `Object.create()`), the own properties will be directly set on the object.\n  \nDoes this distinction between own properties and prototype properties make sense?</md></sn><sn><p class=\"text-end text-light\">in a case where newobj.name and newObj.age came from constructor function,what if later we create a newObj.group which is not intialized in contructor has any negative effect</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">No, adding new properties (like `group`) to an object after it’s created using a constructor function will **not have any negative effect**. JavaScript objects are **dynamic**, meaning you can add, modify, or delete properties at any time, regardless of whether they were initialized in the constructor function.\n\nLet’s break it down with an example:\n\n### Example:\n```javascript\nfunction Person(name, age) {\n  this.name = name;  // Initialized in constructor\n  this.age = age;    // Initialized in constructor\n}\n\nconst newObj = new Person(\"Alice\", 30);\n\n// Adding a new property after object creation\nnewObj.group = \"Admin\";  // This is a new property not initialized in constructor\n\nconsole.log(newObj.name);  // \"Alice\"\nconsole.log(newObj.age);   // 30\nconsole.log(newObj.group); // \"Admin\"\n```\n\n### Key Points:\n1. **No Negative Effects**: Adding `group` after the object is created doesn’t interfere with the existing properties (`name` and `age`). The object simply gains a new property. JavaScript doesn’t impose any restrictions on dynamically adding properties.\n   \n2. **Flexibility**: Objects in JavaScript are flexible, and you can always modify them. This dynamic nature is a fundamental characteristic of JavaScript.\n\n3. **Prototype Considerations**: The `group` property is **not inherited from the prototype** unless explicitly added to the prototype (e.g., `Person.prototype.group = \"Admin\";`), but in your case, it’s a property specific to `newObj`.\n\n4. **Constructor Function and New Properties**: The constructor function only initializes properties defined inside it, so `group` won't be part of the `Person` constructor’s default structure. But that’s fine—JavaScript objects can grow as needed.\n\n### Performance Impact:\n- **Small Impact**: If you are adding a large number of properties dynamically or using complex logic, it could have a minor performance cost. But for most typical scenarios, adding properties like this is efficient and doesn't pose a significant issue.\n  \nIn summary, **no negative effects** from adding new properties to an object after it has been created. This is the flexibility that JavaScript objects provide.</md></sn><sn><p class=\"text-end text-light\">so own property came from constructor function and later creation itsnt it</p><p></p><p>Yes, own properties are initially set by the constructor function, and you can add more later.</p><p></p></sn><sn><p class=\"text-end text-light\">now create a example of object own property came from constructor function by giving arugment or default setted and later creation own propery</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">Here's an example:\n\n```javascript\nfunction Person(name = \"Unknown\", age = 0) {\n  this.name = name; // Own property from constructor\n  this.age = age;   // Own property from constructor\n}\n\nconst person1 = new Person(\"Alice\", 25);\nperson1.group = \"Admin\";  // Later creation of own property\n\nconsole.log(person1.name);  // \"Alice\"\nconsole.log(person1.age);   // 25\nconsole.log(person1.group); // \"Admin\"\n```\n\nIn this example, `name` and `age` are set by the constructor, while `group` is added later.</md></sn><sn><p class=\"text-end text-light\">what is __proto__,what is prototype and what is [[prototype]] which to used with which object</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">Here’s a breakdown:\n\n1. **`__proto__`**:\n   - It’s a **legacy** property used to access or modify an object's internal prototype (the `[[Prototype]]`).\n   - Available in all objects, but **not recommended** for use in modern JavaScript.\n\n   Example:\n   ```javascript\n   const obj = {};\n   console.log(obj.__proto__);  // Object prototype (Object.prototype)\n   ```\n\n2. **`prototype`**:\n   - This is a property of **constructor functions** (like a class or function).\n   - It is used to define methods and properties that will be shared among all instances of the object created by that constructor.\n\n   Example:\n   ```javascript\n   function Person(name) {\n     this.name = name;\n   }\n   \n   Person.prototype.greet = function() {\n     return `Hello, ${this.name}`;\n   };\n\n   const person1 = new Person(\"Alice\");\n   console.log(person1.greet());  // \"Hello, Alice\"\n   ```\n\n3. **`[[Prototype]]`**:\n   - This is an **internal property** that represents the actual prototype of an object.\n   - It’s the underlying mechanism behind `__proto__`, and you usually don’t interact with it directly. Instead, you use `Object.getPrototypeOf()` to access it.\n\n   Example:\n   ```javascript\n   const obj = {};\n   console.log(Object.getPrototypeOf(obj));  // Object.prototype\n   ```\n\n### To summarize:\n- **`__proto__`**: Access or modify an object's prototype (legacy, not recommended).\n- **`prototype`**: Property of constructor functions to define shared methods for instances.\n- **`[[Prototype]]`**: Internal property (the actual prototype chain), accessed via `Object.getPrototypeOf()`.</md></sn><sn><p class=\"text-end text-light\">so any_obj.__proto__ is equal to any_obj [[Prototype]] is it</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">Yes, `any_obj.__proto__` is **effectively** the same as `any_obj.[[Prototype]]`, but the difference lies in how they're used:\n\n- `any_obj.__proto__` is an **explicit, accessible property** (though not recommended for use in modern JavaScript).\n- `any_obj.[[Prototype]]` is an **internal mechanism** that is not directly accessible, but it is what JavaScript uses under the hood.\n\nYou can interact with the prototype via `__proto__`, but it's generally better to use `Object.getPrototypeOf(any_obj)` for reading the prototype, as it's more standardized and avoids potential pitfalls.</md></sn><sn><p class=\"text-end text-light\">anyObj.__proto__ vs anyObj.constructor.prototype</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">Here’s the difference:\n\n1. **`anyObj.__proto__`**:\n   - Refers to the **prototype** of the object itself.\n   - It points to the object from which `anyObj` is inheriting properties (its prototype).\n   - For instance, if `anyObj` is created using a constructor, `anyObj.__proto__` will be the prototype of that constructor.\n\n   Example:\n   ```javascript\n   function Person(name) {\n     this.name = name;\n   }\n   \n   const person1 = new Person(\"Alice\");\n   console.log(person1.__proto__); // Person.prototype\n   ```\n\n2. **`anyObj.constructor.prototype`**:\n   - Refers to the **prototype** of the constructor function that created the object.\n   - If `anyObj` was created using `new SomeConstructor()`, `anyObj.constructor.prototype` will point to `SomeConstructor.prototype`.\n   - This can be used to check or modify the prototype of the constructor used to create the object.\n\n   Example:\n   ```javascript\n   console.log(person1.constructor.prototype); // Person.prototype\n   ```\n\n### Key Difference:\n- `anyObj.__proto__` gives the actual prototype of the object, which is **Person.prototype** in this case.\n- `anyObj.constructor.prototype` refers to the prototype object of the **constructor function**, which is also **Person.prototype** here.\n\nIn most cases, they point to the same thing, but **`anyObj.__proto__`** is more focused on the **object itself**, and **`anyObj.constructor.prototype`** is focused on the **constructor function** that created the object.</md></sn><sn><p class=\"text-end text-light\">okay eventually the prototype is a property of contructor function</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">Yes, that's correct! The **`prototype`** is a property of the **constructor function** (or class). It defines properties and methods that will be shared by all instances created by that constructor.\n\nFor example:\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hello, ${this.name}`;\n};\n\nconst person1 = new Person(\"Alice\");\nconsole.log(person1.greet());  // \"Hello, Alice\"\n```\n\nHere, `greet` is a method on `Person.prototype`, and all objects created by the `Person` constructor will inherit it.</md></sn><sn><p class=\"text-end text-light\">how all instances target the constructor prototype</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">All instances created by a constructor function (or class) automatically target the constructor's `prototype` because of the way JavaScript's **prototype chain** works. Here's how it happens:\n\n### When an instance is created:\n\n1. **Constructor Function**: When you create an object using a constructor (e.g., `new Person()`), the newly created object’s `[[Prototype]]` (or `__proto__`) is automatically set to the `prototype` property of the constructor function (`Person.prototype` in this case).\n\n2. **Prototype Chain**: The object looks up its methods and properties starting from its own properties. If it doesn't find a property, it looks up the prototype chain, which leads to the constructor's `prototype`.\n\n### Example:\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hello, ${this.name}`;\n};\n\nconst person1 = new Person(\"Alice\");\nconst person2 = new Person(\"Bob\");\n\nconsole.log(person1.greet());  // \"Hello, Alice\"\nconsole.log(person2.greet());  // \"Hello, Bob\"\n```\n\n### How it works:\n- **`person1.__proto__`** points to **`Person.prototype`**.\n- **`person2.__proto__`** points to **`Person.prototype`** as well.\n  \nSo, when you call `person1.greet()`, it doesn't find `greet` on `person1` itself, so it looks up to `person1.__proto__` (which is `Person.prototype`), where `greet` is found.\n\nThis allows all instances of `Person` to share methods (like `greet`) defined on the `Person.prototype`, which is memory-efficient.\n\n### Key Point:\nAll instances created by a constructor function automatically **target the constructor's `prototype`** through the `[[Prototype]]` (or `__proto__`) link.</md></sn><sn><p class=\"text-end text-light\">now lets take about construtor.prototype,as it is a object what properties does this object contain</p><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">The **`constructor.prototype`** is an object that is automatically created when you define a constructor function. It contains properties and methods that are shared by all instances of objects created with that constructor.\n\n### Key Properties of `constructor.prototype`:\n\n1. **`constructor`**:\n   - Every `prototype` object has a `constructor` property, which points back to the constructor function that created it.\n   \n   Example:\n   ```javascript\n   function Person(name) {\n     this.name = name;\n   }\n   \n   console.log(Person.prototype.constructor === Person);  // true\n   ```\n\n2. **Methods and Properties**:\n   - You can define properties and methods on the `constructor.prototype` object. These will be inherited by all instances created using the constructor.\n\n   Example:\n   ```javascript\n   function Person(name) {\n     this.name = name;\n   }\n   \n   Person.prototype.greet = function() {\n     return `Hello, ${this.name}`;\n   };\n\n   const person1 = new Person(\"Alice\");\n   console.log(person1.greet());  // \"Hello, Alice\"\n   ```\n\n### What Does `constructor.prototype` Contain?\n\n- **By default**, the `prototype` object is an empty object with a `constructor` property pointing to the constructor function. This is the base for all the instances created with the constructor.\n\n  Example:\n  ```javascript\n  function Person(name) {\n    this.name = name;\n  }\n\n  console.log(Person.prototype); // { constructor: [Function: Person] }\n  ```\n\n- **You can add methods and properties** to the `constructor.prototype`, and they will be shared by all instances. For example, adding `greet` on `Person.prototype` means every instance of `Person` can call `greet()`.\n\n### Summary:\n- **`constructor.prototype`** starts with a `constructor` property (pointing back to the constructor function).\n- You can **add methods and properties** to `constructor.prototype`, and they will be inherited by all instances created with the constructor.\n- `constructor.prototype` is the **prototype** of the objects created by the constructor function.\n\nLet me know if you want to dive deeper into any of these!</md></sn>","topic_id":769,"last_visited":"2025-02-18T13:15:13.155Z"},{"topic_name":"03.How class became the syntatic sugar","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">When you use **classes** in JavaScript, they essentially act as **syntactic sugar** to manage the behavior of constructor functions and their prototypes seamlessly. Let's break it down:\n\n---\n\n### **Constructor Functions and Prototypes Before Classes**\nIn traditional JavaScript, you had to:\n1. Define a constructor function to initialize object properties.\n2. Attach shared methods manually to the `prototype`.\n\nExample:\n```javascript\nfunction Person(name) {\n  this.name = name; // Initialize properties\n}\n\nPerson.prototype.greet = function() { // Shared method\n  return `Hello, ${this.name}`;\n};\n\nconst person1 = new Person(\"Alice\");\nconsole.log(person1.greet()); // \"Hello, Alice\"\n```\n\nThis approach splits object initialization (`constructor`) and shared behavior (`prototype`) into two separate steps.\n\n---\n\n### **How Classes Simplify This**\nThe `class` syntax in JavaScript combines these two steps:\n1. A `constructor` method is used to define how objects are initialized (like the traditional constructor function).\n2. Methods defined inside the class are automatically added to the **prototype** of the created object.\n\nExample:\n```javascript\nclass Person {\n  constructor(name) { // Constructor for initialization\n    this.name = name;\n  }\n\n  greet() { // Automatically added to the prototype\n    return `Hello, ${this.name}`;\n  }\n}\n\nconst person1 = new Person(\"Alice\");\nconsole.log(person1.greet()); // \"Hello, Alice\"\n```\n\n---\n\n### **What Happens Under the Hood**\nWhen you define a class, JavaScript does the following behind the scenes:\n1. Creates a **constructor function**:\n   ```javascript\n   function Person(name) {\n     this.name = name;\n   }\n   ```\n2. Defines the class methods as properties of the constructor's **prototype**:\n   ```javascript\n   Person.prototype.greet = function() {\n     return `Hello, ${this.name}`;\n   };\n   ```\n3. Ensures that the `constructor` property on the prototype points back to the class.\n\nSo, the above `class` example is effectively the same as writing:\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nPerson.prototype.greet = function() {\n  return `Hello, ${this.name}`;\n};\n```\n\n---\n\n### **Advantages of Classes**\n1. **Cleaner Syntax**:\n   - Combines constructor and prototype management into one structure.\n2. **`extends` Keyword**:\n   - Simplifies inheritance by managing the prototype chain for derived classes.\n3. **Immutability of Class Methods**:\n   - Methods defined in the class are **non-enumerable**, meaning they won’t appear in `for...in` loops, unlike manually added prototype methods.\n4. **Strict Mode by Default**:\n   - Classes automatically enable `strict mode`, reducing common JavaScript pitfalls.\n\n---\n\n### **Conclusion**\nClasses provide a more intuitive and cleaner syntax for working with constructor functions and prototypes. Under the hood, they:\n1. Create a constructor function for initialization.\n2. Automatically attach shared methods to the prototype.\nThis syntactic sugar hides the manual steps while retaining the power of prototype-based inheritance.</md></sn>","topic_id":770,"last_visited":"2025-02-19T04:14:51.381Z"},{"topic_name":"Prototype","topic_html":"<sn><h3>Prototype Concept</h3><p>To Understand prototype we have to understand object properties clearly.Every Object Properties can devided into two group(ownProperty,&lt;prototype&gt;). </p><ul><li>Own Properties</li><li>&lt;Prototype&gt;</li></ul></sn><sn><h3>Own Property</h3><p>Denotes object own&nbsp; properties which is came from either constructor or later craetion not from inheritence</p><p>Now object own property can be divided to 2 type</p><ul><li>Properties which came from constructor function by giving argument or default(set by constructor)</li><li>Later Creation</li></ul><pre data-v=\"javascript\">function Person(name,age,alive=true){\n\tthis.name = name\n\tthis.age = age\n\tthis.alive = alive\n\tthis.isDead = function(){\n\t   return !this.alive\n\t}\n}\n\nvar person1 = new Person('John',58)\nperson1.city = 'New york'\nperson1.height = 5.9\n\nconsole.log(person1)\n\nObject { name: \"John\", age: 58, alive: true, isDead: isDead(), city: \"New york\", height: 5.9 }\n\n//own properties\nproperties                   set by\nage: 58                      //constuctor from argument\nalive: true                  //constructor by default\ncity: \"New york\"             //later creation\nheight: 5.9                  //later creation \nisDead: function isDead()    //constructor default\nname: \"John\"                 //constuctor from argument \n\n//&lt;prototype&gt;\n&lt;prototype&gt;:Object { … }     //set by constructor\n</pre><h5>Summary</h5><p>So object own properties denote those properties which is set in the creation phase by the constructor(from aruement or default) or later creation </p></sn><sn><h3>&lt;Prototype&gt;</h3><p>There are some keyword related to prototype,these are </p><ul><li>instanceObject.__proto__</li><li>[[prototype]] or &lt;prototype&gt; of instance object refer chain prototype </li><li>ConstructorFunction.prototype</li></ul><h5>what is prototype ?</h5><p>In one line prototype is a property of a constructor function(like Person).It is an Object,by which all instances of constructor function inherited propertis from it </p><p>In our example function Person was the constructor function.As prototype is a property of constructor function lets check it up</p><pre data-v=\"javascript\">//prototype is a property of a constructor function\nPerson.prototype\n\tObject { … }\n\tconstructor: function Person(name, age, alive)\n\t&lt;prototype&gt;: Object { … } //later we will talk about this\n\n//here the prototype constructor property refer to the Person itself\nPerson.prototype.constructor === Person //true\n</pre><p></p><p>so the structure of ConstructorFunction.prototype is</p><pre data-v=\"javascript\">&gt; ConstructorFunction.prototype\n\tconstructor:ConstructorFunction\n\t&lt;prototype&gt; //ignore for now\n\tproperty1:...,\n\tproerty2:....,\n\tproerty3:()=&gt;{},\n\tproerty4:()=&gt;{},\n</pre><p></p><p>Any instance(person1) of ConstructorFunction(Person) can access these property from ConstructorFunction.prototype<br></p><p>Adding new method to Person.prototype ,which can be accessed by any instance of Person<br></p><pre data-v=\"javascript\">Person.prototype.greet = function(){\n  return `hello ${this.name}`\n}\n\nPerson.prototype\nObject { greet: greet(), … }\n\tconstructor: function Person(name, age, alive)\n\tgreet: function greet()\n\t&lt;prototype&gt;: Object { … }\n</pre><p></p><p>As person1 is an instance of Person so it can access greet method from Person.prototype</p><pre data-v=\"javascript\">person1.greet()\n\"hello John\" </pre><p></p></sn><sn><h3>__proto__</h3><p>If prototype is a property of a constructor function then what is &lt;prototype&gt; in a instance object like person1</p><p>Basically any Object &lt;prototype&gt; denote it constructorFunction.prototype.To check the protoype of instance object we have to use __proto__ property,by which we can prove that instance Object &lt;prototype&gt; === ConstructionFunction.prototype</p><pre data-v=\"javascript\">person1.__proto__ === Person.prototype\n//true </pre><h3 class=\"text-center text-light\">instanceObject&lt;prototype&gt; === constructorFunction.prototype</h3><p>So any object &lt;prototype&gt; reference to its ConstructorFunction.prototype</p><p>So the &lt;protoype&gt; in a object is a reference object,the main prototype is a property of a constructor function</p><pre data-v=\"javascript\">person1.__proto__ === Person.prototype\n//true\nperson1.__proto__ === person1.constructor.prototype\n//true </pre></sn><sn><h3>Summary</h3><ul><li>Object properties can be diveided into two group own properties and prototype properties</li><li>Own Properties came from constructor function by giving arugments or set by constructor default and later creation</li><li>&lt;Prototype&gt; properties came from object constructorFuncton.prototype property.</li><li>The prototype property use with ConstructorFunction and __proto__ property use with instanceObject</li><li>Object &lt;prototype&gt; reference to the ConstructorFunction.prototype</li><li>instanceObject&lt;prototype&gt; refer instanceObject.constructor.prototype</li><li>instanceObject.__proto__ === ConstructorFunction.prototype</li></ul><p>So when a object is created by ConstructorFunction it set a __proto__ to the instance object which connect the&nbsp; instance object with ConstructorFunction.prototype</p><p>We can imagine it like this the instance object come with some arugment and ask Constructor Function to create a object like him,the construction function set some unique proerties and told okay instance listen you need any help i give you this __proto__ by which you can access by prototype which give you more properties when you need</p></sn><sn><a target=\"_blank\" href=\"https://chatgpt.com/share/67b478ee-ae94-8008-8c88-0316f65366d6\">ChatGpt Link</a></sn>","topic_id":770,"last_visited":"2025-02-19T04:14:20.185Z"}],"chapter_id":198},{"chapter_name":"Lib","topics":[{"topic_name":"lib","topic_html":"","topic_id":662,"last_visited":"2025-02-02T15:39:15.372Z"},{"topic_name":"rough notation Lib","topic_html":"<sn><md data-rr=\"true\"><pre>To set up the **RoughNotation** library in JavaScript, follow these steps:<br><br>### 🔹 1. Install the Library  <br>You can either use a **CDN** or install it via **npm**.<br><br>#### ✅ Using CDN  <br>Add this script in your HTML file:  <br>```html<br>&lt;script src=\"https://unpkg.com/rough-notation/lib/rough-notation.iife.js\"&gt;&lt;/script&gt;<br>```<br><br>#### ✅ Using npm  <br>Run the following command:  <br>```sh<br>npm install rough-notation<br>```<br><br>---<br><br>### 🔹 2. Basic Usage  <br>#### ✅ Using CDN  <br>```html<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=\"en\"&gt;<br>&lt;head&gt;<br>    &lt;meta charset=\"UTF-8\"&gt;<br>    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;<br>    &lt;title&gt;RoughNotation Example&lt;/title&gt;<br>    &lt;script src=\"https://unpkg.com/rough-notation/lib/rough-notation.iife.js\"&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>    &lt;h1 id=\"highlight\"&gt;Hello, RoughNotation!&lt;/h1&gt;<br><br>    &lt;script&gt;<br>        const { annotate } = RoughNotation;<br>        const element = document.getElementById(\"highlight\");<br><br>        const annotation = annotate(element, { type: 'highlight', color: 'yellow', iterations: 2 });<br>        annotation.show();<br>    &lt;/script&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br>```<br><br>#### ✅ Using npm (ES Module)  <br>```javascript<br>import { annotate } from 'rough-notation';<br><br>const element = document.getElementById(\"highlight\");<br>const annotation = annotate(element, { type: 'underline', color: 'red' });<br>annotation.show();<br>```<br><br>---<br><br>### 🔹 3. Available Annotation Types  <br>- `underline`<br>- `box`<br>- `circle`<br>- `highlight`<br>- `strike-through`<br>- `bracket`<br><br>Let me know if you need advanced examples! 🚀</pre></md></sn><sn><pre data-v=\"javascript\">trigger('#test-btn',()=&gt;{\n    const { annotate } = RoughNotation;    \n    const e = document.querySelector('y');\n    const annotation = annotate(e, { type: 'underline' });\n    annotation.show();\n})</pre></sn>","topic_id":664,"last_visited":"2025-02-02T15:29:31.507Z"},{"topic_name":"Type Js Lib","topic_html":"<sn><md data-rr=\"true\"><pre>Here are **10 fully working examples** to master **Typed.js**! 🚀  <br><br>---<br><br>## **1️⃣ Basic Typing Animation**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"Hello, world!\"],<br>    typeSpeed: 50<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Types \"Hello, world!\" letter by letter.**<br><br>---<br><br>## **2️⃣ Typing with Deleting Effect**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"Welcome to Typed.js!\", \"Let's make animations!\"],<br>    typeSpeed: 50,<br>    backSpeed: 30,<br>    backDelay: 1000,<br>    loop: true<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Types, pauses, deletes, and loops.**<br><br>---<br><br>## **3️⃣ Delayed Typing Start**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"This starts after 2 seconds!\"],<br>    typeSpeed: 50,<br>    startDelay: 2000<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Delays typing for 2 seconds.**<br><br>---<br><br>## **4️⃣ Typing with Custom Cursor**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"Custom Cursor Example!\"],<br>    typeSpeed: 50,<br>    showCursor: true,<br>    cursorChar: \"✍\"<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Changes cursor to ✍ instead of `|`.**<br><br>---<br><br>## **5️⃣ Looping Animation**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"This loops forever!\", \"Endless typing effect!\"],<br>    typeSpeed: 50,<br>    backSpeed: 30,<br>    loop: true<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Repeats forever with smooth typing and deleting.**<br><br>---<br><br>## **6️⃣ Shuffle Text Order**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"Sentence 1\", \"Sentence 2\", \"Sentence 3\"],<br>    typeSpeed: 50,<br>    shuffle: true<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Randomizes the typing order.**<br><br>---<br><br>## **7️⃣ Typing HTML Inside Strings**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"This is &lt;strong&gt;bold&lt;/strong&gt;!\", \"This is &lt;em&gt;italic&lt;/em&gt;!\"],<br>    typeSpeed: 50,<br>    contentType: \"html\"<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Types text with bold and italic formatting.**<br><br>---<br><br>## **8️⃣ Trigger Typing on Button Click**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br>&lt;button onclick=\"startTyping()\"&gt;Start Typing&lt;/button&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  function startTyping() {<br>    var typed = new Typed(\".typing\", {<br>      strings: [\"You clicked the button!\"],<br>      typeSpeed: 50<br>    });<br>  }<br>&lt;/script&gt;<br>```<br>✅ **Typing starts when you click the button.**<br><br>---<br><br>## **9️⃣ Stop and Restart Animation**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br>&lt;button onclick=\"typed.stop()\"&gt;Stop&lt;/button&gt;<br>&lt;button onclick=\"typed.start()\"&gt;Start&lt;/button&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"You can stop and start this animation!\"],<br>    typeSpeed: 50,<br>    loop: true<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Allows stopping and restarting the typing animation.**<br><br>---<br><br>## **🔟 Fade Out Effect**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"This text will fade out before changing.\"],<br>    typeSpeed: 50,<br>    backSpeed: 30,<br>    fadeOut: true,<br>    loop: true<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Smooth fade-out before switching text.**<br><br>---<br><br>### **🔥 Bonus: Combining Everything**<br>```html<br>&lt;h1 class=\"typing\"&gt;&lt;/h1&gt;<br><br>&lt;script src=\"https://cdn.jsdelivr.net/npm/typed.js@2.0.12\"&gt;&lt;/script&gt;<br>&lt;script&gt;<br>  var typed = new Typed(\".typing\", {<br>    strings: [\"Master Typed.js!\", \"Make amazing animations!\", \"🚀 Try it now!\"],<br>    typeSpeed: 50,<br>    backSpeed: 30,<br>    backDelay: 1000,<br>    loop: true,<br>    showCursor: true,<br>    cursorChar: \"💡\"<br>  });<br>&lt;/script&gt;<br>```<br>✅ **Combines multiple effects into one smooth animation!**<br><br>---<br><br>### **💡 Summary**<br>✔ `typeSpeed`, `backSpeed` → Control typing &amp; deleting speed  <br>✔ `loop`, `loopCount` → Repeats animation  <br>✔ `cursorChar` → Customizes cursor  <br>✔ `startDelay` → Delays typing  <br>✔ `fadeOut` → Smooth effect before text change  <br>✔ `shuffle` → Randomizes text order  <br>✔ `onClick`, `stop()`, `start()` → User interactions  <br><br>With these **10+ examples**, you can **fully master Typed.js** and create **amazing text animations**! 🚀🔥</pre></md></sn>","topic_id":663,"last_visited":"2025-02-02T15:39:05.022Z"}],"chapter_id":188},{"chapter_name":"01.Getting Started With Javascript","topics":[{"topic_name":"00.What is Javascript","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Javascript**\n---\n**JavaScript** is a high-level, interpreted programming language primarily used to create interactive and dynamic content on websites. It runs on the client-side (in web browsers) and is a core technology of the web alongside **HTML** and **CSS**. JavaScript can also be used on the server-side (e.g., with **Node.js**).\n\n---\n\n#####  **Where JavaScript Is Used**\n\n| Use Case                          | Description                                                       |\n| --------------------------------- | ----------------------------------------------------------------- |\n| 🌐 Web Development                | Adds interactivity (e.g., forms, sliders, animations) to websites |\n| 🧠 Web Applications               | Powers single-page applications (SPAs) like Gmail, Trello, etc.   |\n| 🖥️ Server-Side Development       | Using Node.js for backend development                             |\n| 📱 Mobile App Development         | Frameworks like React Native or Ionic                             |\n| 🕹️ Game Development              | Used with libraries like Phaser or Babylon.js                     |\n| ⚙️ Automation/Scripting           | Automates tasks in browsers or servers                            |\n| 📊 Data Visualization             | Libraries like D3.js, Chart.js for creating charts                |\n| 🤖 Machine Learning (basic level) | Libraries like TensorFlow\\.js for ML in the browser               |\n\n---\n\n##### 📅 **JavaScript Versions Table (ECMAScript Evolution)**\n\n| Version         | Release Year | Major Features                                                              |\n| --------------- | ------------ | --------------------------------------------------------------------------- |\n| ES1             | 1997         | First edition of ECMAScript                                                 |\n| ES2             | 1998         | Editorial changes only                                                      |\n| ES3             | 1999         | Regular expressions, try/catch, switch, do-while                            |\n| ES4 (abandoned) | N/A          | Proposed major overhaul but never released                                  |\n| ES5             | 2009         | Strict mode, JSON support, Array methods (forEach, map, filter)             |\n| ES5.1           | 2011         | Standardization for global use                                              |\n| ES6 (ES2015)    | 2015         | `let/const`, arrow functions, classes, promises, template literals, modules |\n| ES7 (ES2016)    | 2016         | `Array.prototype.includes()`, exponentiation operator (`**`)                |\n| ES8 (ES2017)    | 2017         | `async/await`, Object.entries/values, string padding                        |\n| ES9 (ES2018)    | 2018         | Rest/spread for objects, async iteration, Promise.finally()                 |\n| ES10 (ES2019)   | 2019         | `flat()`, `flatMap()`, optional catch binding                               |\n| ES11 (ES2020)   | 2020         | Optional chaining (`?.`), nullish coalescing (`??`), dynamic import         |\n| ES12 (ES2021)   | 2021         | Logical assignment, numeric separators (`1_000`), Promise.any()             |\n| ES13 (ES2022)   | 2022         | Top-level await, class fields, error cause                                  |\n| ES14 (ES2023)   | 2023         | Array grouping (`groupBy`), new symbols, better error stacks                |\n| ES15 (ES2024)   | 2024         | (Expected) decorators, pattern matching (proposed), improvements in async   |\n\n</md></sn>","topic_id":1011,"last_visited":"2025-05-08T02:09:42.404Z"}],"chapter_id":268},{"chapter_name":"02.Javascript Variable","topics":[{"topic_name":"01.Defining a Variable","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">## **JavaScript Variables**\n\nVariables are what make up most of JavaScript. They store data such as numbers, text, and objects, and are essential for making dynamic and functional web applications.\n\n---\n\n### **Syntax Structure**\n\n| Component       | Description                                                                                         |\n| --------------- | --------------------------------------------------------------------------------------------------- |\n| `variable_name` | **(Required)** – The name of the variable, used to reference it later.                              |\n| `=`             | **(Optional)** – Assignment operator used to define a value for the variable.                       |\n| `value`         | **(Required when using assignment)** – The value assigned to the variable. *(default: `undefined`)* |\n\n---\n\n### **Defining a Variable**\n\n```javascript\nvar myVariable = \"This is a variable!\";\n```\n\nThis is an example of defining a variable using `var`.\nIn this case, the variable is storing a **string** because it contains ASCII characters like A-Z, 0-9, and symbols (!@#\\$, etc.).</md></sn>","topic_id":1012,"last_visited":"2025-05-08T02:21:53.173Z"},{"topic_name":"02.Using a Variable","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Using a Variable**\n\n```javascript\nvar number1 = 5;\nnumber1 = 3;\n```\n\nHere, we first define a variable named `number1` and assign it the value `5`. Then, we **update** its value to `3`.\n\n#### 📤 Displaying a Variable's Value\n\nYou can display the value of a variable using either the browser console or an alert:\n\n```javascript\nconsole.log(number1);     // Output: 3\nwindow.alert(number1);    // Displays: 3\n```\n\n#### ➕ Arithmetic Operations\n\nYou can perform basic arithmetic operations directly with variables:\n\n```javascript\nnumber1 = number1 + 5;     // 3 + 5 = 8\nnumber1 = number1 - 6;     // 8 - 6 = 2\nvar number2 = number1 * 10; // 2 * 10 = 20\nvar number3 = number2 / number1; // 20 / 2 = 10\n```\n\n#### 🔤 String Concatenation\n\nYou can also use the `+` operator to **concatenate strings**:\n\n```javascript\nvar myString = \"I am a \" + \"string!\"; // \"I am a string!\"\n```\n</md></sn>","topic_id":1013,"last_visited":"2025-05-08T02:25:51.145Z"},{"topic_name":"03.Types of Variable","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **JavaScript Data Types with Variables**\n\nJavaScript supports several data types. Here are examples of defining variables with common types:\n\n---\n\n#### 🔢 **Number Types**\n\n```javascript\nvar myInteger = 12;               // 32-bit integer: -2,147,483,648 to 2,147,483,647\nvar myLong = 9310141419482;       // 64-bit integer: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\nvar myFloat = 5.5;                // 32-bit floating-point number (decimal)\nvar myDouble = 9310141419482.22;  // 64-bit floating-point number\n```\n\n---\n\n#### ✅ **Boolean Type**\n\n```javascript\nvar myBoolean = true;   // true = 1\nvar myBoolean2 = false; // false = 0\n```\n\n---\n\n#### ❌ **NaN (Not a Number)**\n\n```javascript\nvar myNotANumber = NaN;\nvar NaN_Example = 0 / 0; // NaN: Division by zero is not allowed\n```\n\n---\n\n#### ⚠️ **Undefined Variable**\n\n```javascript\nvar notDefined; // undefined because no value is assigned\nwindow.alert(aRandomVariable); // undefined (if aRandomVariable is not declared)\n```\n\n---\n\n#### 🕳️ **Null Type**\n\n```javascript\nvar myNull = null; // explicitly no value\n```</md></sn>","topic_id":1014,"last_visited":"2025-05-08T02:29:35.152Z"},{"topic_name":"04.Arrays and Objects","topic_html":"<sn><md class=\"p-1 p-md-2 my-2\" data-rr=\"true\">### **Arrays and Objects**\n\n#### 📚 **Arrays**\n\nAn **array** is a list-like structure used to store multiple values in a single variable.\n\n```javascript\nvar myArray = []; // Empty array\n```\n\n##### 🧺 Example Arrays\n\n```javascript\nvar favoriteFruits = [\"apple\", \"orange\", \"strawberry\"];\nvar carsInParkingLot = [\"Toyota\", \"Ferrari\", \"Lexus\"];\nvar employees = [\"Billy\", \"Bob\", \"Joe\"];\nvar primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31];\nvar randomVariables = [2, \"any type works\", undefined, null, true, 2.51];\n```\n\n##### 🎯 Accessing Array Elements\n\n```javascript\nmyArray = [\"zero\", \"one\", \"two\"];\nwindow.alert(myArray[0]); // Output: \"zero\"\n\nmyArray = [\"John Doe\", \"Billy\"];\nvar elementNumber = 1;\nwindow.alert(myArray[elementNumber]); // Output: \"Billy\"\n```\n\n---\n\n#### 🧱 **Objects**\n\nAn **object** is a collection of key-value pairs, offering a more descriptive way to store and access data than arrays.\n\n```javascript\nvar myObject = {};\n```\n\n##### 🧑 Example Objects\n\n```javascript\nvar john = {\n  firstname: \"John\",\n  lastname: \"Doe\",\n  fullname: \"John Doe\"\n};\n\nvar billy = {\n  firstname: \"Billy\",\n  lastname: undefined,\n  fullname: \"Billy\"\n};\n```\n\n##### 🔍 Accessing Object Properties\n\n```javascript\nwindow.alert(john.fullname);      // Output: \"John Doe\"\nwindow.alert(billy.firstname);    // Output: \"Billy\"\n```\n\nUsing objects like `john.fullname` and `billy.fullname` is more descriptive and manageable than using array indexes like `myArray[0]`.</md></sn>","topic_id":1015,"last_visited":"2025-05-08T02:32:45.388Z"}],"chapter_id":269}],"author":{"login":"Nh-emon","id":146737722,"node_id":"U_kgDOCL8KOg","avatar_url":"https://avatars.githubusercontent.com/u/146737722?v=4","gravatar_id":"","url":"https://api.github.com/users/Nh-emon","html_url":"https://github.com/Nh-emon","followers_url":"https://api.github.com/users/Nh-emon/followers","following_url":"https://api.github.com/users/Nh-emon/following{/other_user}","gists_url":"https://api.github.com/users/Nh-emon/gists{/gist_id}","starred_url":"https://api.github.com/users/Nh-emon/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Nh-emon/subscriptions","organizations_url":"https://api.github.com/users/Nh-emon/orgs","repos_url":"https://api.github.com/users/Nh-emon/repos","events_url":"https://api.github.com/users/Nh-emon/events{/privacy}","received_events_url":"https://api.github.com/users/Nh-emon/received_events","type":"User","site_admin":false,"name":"Emon","company":null,"blog":"","location":null,"email":null,"hireable":null,"bio":null,"twitter_username":null,"public_repos":20,"public_gists":0,"followers":1,"following":1,"created_at":"2023-10-02T13:07:54Z","updated_at":"2024-08-06T16:33:13Z"},"created_on":"2024-12-07T01:25:54.291Z","is_private":false,"folder":"Programming","web_url":"https://qdock.free.nf","last_update_on":"2025-05-08T02:35:44.461Z"}