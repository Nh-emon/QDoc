{"subject_name":"Js Lib","subject_id":50,"chapters":[{"chapter_name":"markdownit","topics":[{"topic_name":"01.Overview","topic_html":"<sn><md>### **Markdownit**\n---\n`markdown-it` is a **JavaScript library** that parses and converts **Markdown** syntax into **HTML**. It's fast, pluggable, and commonly used in web apps that allow users to write formatted content using Markdown.\n\n### 🔧 Features:\n- **CommonMark** compliant (standard Markdown syntax)\n- Supports **GitHub Flavored Markdown (GFM)**\n- **Extensible** via plugins\n- Supports **syntax highlighting**\n- Written in **JavaScript**, works in both **Node.js** and **browsers**\n\n### 📦 Installation:\n```bash\nnpm install markdown-it\n```\n\n### 🚀 Usage Example:\n```javascript\nconst MarkdownIt = require('markdown-it');\nconst md = new MarkdownIt();\n\nconst result = md.render('# Hello **world**');\nconsole.log(result);\n// Outputs: &lt;h1&gt;Hello &lt;strong&gt;world&lt;/strong&gt;&lt;/h1&gt;\n```</md></sn>","topic_id":934,"last_visited":"2025-04-25T03:54:51.857Z"},{"topic_name":"02.Set Up","topic_html":"<sn><md>### **Set Up**\n---\n\n### 🌐 In the **Browser**:\n\n#### ✅ Option 1: Using CDN\n```html\n&lt;script src=\"https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  const md = window.markdownit();\n  const result = md.render('# Hello **Markdown-it**!');\n  document.body.innerHTML = result;\n&lt;/script&gt;\n```\n\n---\n\n### 🖥️ In **Node.js**:\n\n#### ✅ Step 1: Install via npm\n```bash\nnpm install markdown-it\n```\n\n#### ✅ Step 2: Use in your JS file\n```javascript\nconst MarkdownIt = require('markdown-it');\nconst md = new MarkdownIt();\n\nconst markdownText = '# Hello **Markdown-it**!';\nconst html = md.render(markdownText);\n\nconsole.log(html);\n// Output: &lt;h1&gt;Hello &lt;strong&gt;Markdown-it&lt;/strong&gt;&lt;/h1&gt;\n```</md></sn>","topic_id":935,"last_visited":"2025-04-25T03:56:13.641Z"},{"topic_name":"03.How it work","topic_html":"<sn><md>###  **⚙️ How `markdown-it` Works:**\n---\n1. **Input**: You provide Markdown text like:\n   ```\n   # Hello World\n   This is **bold** text.\n   ```\n\n2. **Tokenization**: The library breaks it into tokens:\n   ```js\n   [\n     { type: 'heading_open', tag: 'h1', ... },\n     { type: 'inline', content: 'Hello World', ... },\n     { type: 'heading_close', tag: 'h1', ... },\n     ...\n   ]\n   ```\n\n3. **Rendering**: It uses those tokens to generate HTML:\n   ```html\n   &lt;h1&gt;Hello World&lt;/h1&gt;\n   &lt;p&gt;This is &lt;strong&gt;bold&lt;/strong&gt; text.&lt;/p&gt;\n   ```\n\n---\n\n### 🧠 Internals (Simplified):\n- **Lexer**: Parses raw Markdown into a stream of inline/block tokens.\n- **Renderer**: Converts tokens into HTML.\n- **Plugins**: You can add custom rules or modify existing ones.\n\n---\n\n### 🔁 Flow:\n```plaintext\nMarkdown String\n      ↓\n[Parse]\n      ↓\nTokens\n      ↓\n[Render]\n      ↓\nHTML Output\n```</md></sn>","topic_id":936,"last_visited":"2025-04-25T04:08:08.836Z"},{"topic_name":"04.Dir","topic_html":"<sn><md>###   **markdown-it Library Directory Tree**\n---\n```bash\nmarkdown-it/\n├── bin/\n│   └── markdown-it.js\n├── lib/\n│   ├── index.js\n│   ├── parser_block.js\n│   ├── parser_core.js\n│   ├── parser_inline.js\n│   ├── renderer.js\n│   └── ...\n├── presets/\n│   ├── commonmark.js\n│   ├── default.js\n│   └── zero.js\n├── test/\n│   ├── fixtures/\n│   └── test.js\n├── docs/\n│   └── ...\n├── package.json\n├── README.md\n└── CHANGELOG.md\n```\n\n---\n\n### 📊 Explanation Table\n\n#### 📁 Root Level\n\n| File/Folder     | Description |\n|----------------|-------------|\n| `package.json` | Defines metadata and dependencies of the library |\n| `README.md`    | Documentation and usage instructions |\n| `CHANGELOG.md` | History of changes and versions |\n\n---\n\n#### 📁 `lib/` — 🔧 Core Parsing Logic\n\n| File               | Description |\n|--------------------|-------------|\n| `index.js`         | Main entry point — sets up the parser and renderer |\n| `parser_block.js`  | Parses block-level Markdown (e.g., headings, lists) |\n| `parser_inline.js` | Parses inline elements (e.g., bold, links) |\n| `parser_core.js`   | Manages parser rules and pipeline |\n| `renderer.js`      | Converts tokens into HTML output |\n\n---\n\n#### 📁 `bin/` — 🛠️ CLI Tool\n\n| File              | Description |\n|-------------------|-------------|\n| `markdown-it.js`  | Command-line interface for converting Markdown to HTML |\n\n---\n\n#### 📁 `presets/` — ⚙️ Parsing Modes\n\n| File             | Description |\n|------------------|-------------|\n| `default.js`     | Standard Markdown config |\n| `commonmark.js`  | CommonMark spec-compliant config |\n| `zero.js`        | Minimal config with all rules disabled |\n\n---\n\n#### 📁 `test/` — 🧪 Unit Tests\n\n| File/Folder       | Description |\n|-------------------|-------------|\n| `fixtures/`       | Sample test cases |\n| `test.js`         | Test runner and test definitions |\n\n---\n\n#### 📁 `docs/` — 📘 Documentation (if present)\n\n| Folder/File | Description |\n|-------------|-------------|\n| `...`       | Extra documentation or guide content |\n\n</md></sn>","topic_id":937,"last_visited":"2025-04-25T04:07:52.723Z"},{"topic_name":"05.readme","topic_html":"<sn><md># markdown-it &lt;!-- omit in toc --&gt;\n\n[![CI](https://github.com/markdown-it/markdown-it/actions/workflows/ci.yml/badge.svg)](https://github.com/markdown-it/markdown-it/actions/workflows/ci.yml)\n[![NPM version](https://img.shields.io/npm/v/markdown-it.svg?style=flat)](https://www.npmjs.org/package/markdown-it)\n[![Coverage Status](https://coveralls.io/repos/markdown-it/markdown-it/badge.svg?branch=master&amp;service=github)](https://coveralls.io/github/markdown-it/markdown-it?branch=master)\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/markdown-it/markdown-it)\n\n&gt; Markdown parser done right. Fast and easy to extend.\n\n__[Live demo](https://markdown-it.github.io)__\n\n- Follows the __[CommonMark spec](http://spec.commonmark.org/)__ + adds syntax extensions &amp; sugar (URL autolinking, typographer).\n- Configurable syntax! You can add new rules and even replace existing ones.\n- High speed.\n- [Safe](https://github.com/markdown-it/markdown-it/tree/master/docs/security.md) by default.\n- Community-written __[plugins](https://www.npmjs.org/browse/keyword/markdown-it-plugin)__ and [other packages](https://www.npmjs.org/browse/keyword/markdown-it) on npm.\n\n__Table of content__\n\n- [Install](#install)\n- [Usage examples](#usage-examples)\n  - [Simple](#simple)\n  - [Init with presets and options](#init-with-presets-and-options)\n  - [Plugins load](#plugins-load)\n  - [Syntax highlighting](#syntax-highlighting)\n  - [Linkify](#linkify)\n- [API](#api)\n- [Syntax extensions](#syntax-extensions)\n  - [Manage rules](#manage-rules)\n- [Benchmark](#benchmark)\n- [markdown-it for enterprise](#markdown-it-for-enterprise)\n- [Authors](#authors)\n- [References / Thanks](#references--thanks)\n\n## Install\n\n**node.js**:\n\n```bash\nnpm install markdown-it\n```\n\n**browser (CDN):**\n\n- [jsDeliver CDN](http://www.jsdelivr.com/#!markdown-it \"jsDelivr CDN\")\n- [cdnjs.com CDN](https://cdnjs.com/libraries/markdown-it \"cdnjs.com\")\n\n\n## Usage examples\n\nSee also:\n\n- __[API documentation](https://markdown-it.github.io/markdown-it/)__ - for more\n  info and examples.\n- [Development info](https://github.com/markdown-it/markdown-it/tree/master/docs) -\n  for plugins writers.\n\n\n### Simple\n\n```js\n// node.js\n// can use `require('markdown-it')` for CJS\nimport markdownit from 'markdown-it'\nconst md = markdownit()\nconst result = md.render('# markdown-it rulezz!');\n\n// browser with UMD build, added to \"window\" on script load\n// Note, there is no dash in \"markdownit\".\nconst md = window.markdownit();\nconst result = md.render('# markdown-it rulezz!');\n```\n\nSingle line rendering, without paragraph wrap:\n\n```js\nimport markdownit from 'markdown-it'\nconst md = markdownit()\nconst result = md.renderInline('__markdown-it__ rulezz!');\n```\n\n\n### Init with presets and options\n\n(*) presets define combinations of active rules and options. Can be\n`\"commonmark\"`, `\"zero\"` or `\"default\"` (if skipped). See\n[API docs](https://markdown-it.github.io/markdown-it/#MarkdownIt.new) for more details.\n\n```js\nimport markdownit from 'markdown-it'\n\n// commonmark mode\nconst md = markdownit('commonmark')\n\n// default mode\nconst md = markdownit()\n\n// enable everything\nconst md = markdownit({\n  html: true,\n  linkify: true,\n  typographer: true\n})\n\n// full options list (defaults)\nconst md = markdownit({\n  // Enable HTML tags in source\n  html:         false,\n\n  // Use '/' to close single tags (&lt;br /&gt;).\n  // This is only for full CommonMark compatibility.\n  xhtmlOut:     false,\n\n  // Convert '\\n' in paragraphs into &lt;br&gt;\n  breaks:       false,\n\n  // CSS language prefix for fenced blocks. Can be\n  // useful for external highlighters.\n  langPrefix:   'language-',\n\n  // Autoconvert URL-like text to links\n  linkify:      false,\n\n  // Enable some language-neutral replacement + quotes beautification\n  // For the full list of replacements, see https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.mjs\n  typographer:  false,\n\n  // Double + single quotes replacement pairs, when typographer enabled,\n  // and smartquotes on. Could be either a String or an Array.\n  //\n  // For example, you can use '«»„“' for Russian, '„“‚‘' for German,\n  // and ['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›'] for French (including nbsp).\n  quotes: '“”‘’',\n\n  // Highlighter function. Should return escaped HTML,\n  // or '' if the source string is not changed and should be escaped externally.\n  // If result starts with &lt;pre... internal wrapper is skipped.\n  highlight: function (/*str, lang*/) { return ''; }\n});\n```\n\n### Plugins load\n\n```js\nimport markdownit from 'markdown-it'\n\nconst md = markdownit\n  .use(plugin1)\n  .use(plugin2, opts, ...)\n  .use(plugin3);\n```\n\n\n### Syntax highlighting\n\nApply syntax highlighting to fenced code blocks with the `highlight` option:\n\n```js\nimport markdownit from 'markdown-it'\nimport hljs from 'highlight.js' // https://highlightjs.org\n\n// Actual default values\nconst md = markdownit({\n  highlight: function (str, lang) {\n    if (lang &amp;&amp; hljs.getLanguage(lang)) {\n      try {\n        return hljs.highlight(str, { language: lang }).value;\n      } catch (__) {}\n    }\n\n    return ''; // use external default escaping\n  }\n});\n```\n\nOr with full wrapper override (if you need assign class to `&lt;pre&gt;` or `&lt;code&gt;`):\n\n```js\nimport markdownit from 'markdown-it'\nimport hljs from 'highlight.js' // https://highlightjs.org\n\n// Actual default values\nconst md = markdownit({\n  highlight: function (str, lang) {\n    if (lang &amp;&amp; hljs.getLanguage(lang)) {\n      try {\n        return '&lt;pre&gt;&lt;code class=\"hljs\"&gt;' +\n               hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +\n               '&lt;/code&gt;&lt;/pre&gt;';\n      } catch (__) {}\n    }\n\n    return '&lt;pre&gt;&lt;code class=\"hljs\"&gt;' + md.utils.escapeHtml(str) + '&lt;/code&gt;&lt;/pre&gt;';\n  }\n});\n```\n\n### Linkify\n\n`linkify: true` uses [linkify-it](https://github.com/markdown-it/linkify-it). To\nconfigure linkify-it, access the linkify instance through `md.linkify`:\n\n```js\nmd.linkify.set({ fuzzyEmail: false });  // disables converting email to link\n```\n\n\n## API\n\n__[API documentation](https://markdown-it.github.io/markdown-it/)__\n\nIf you are going to write plugins, please take a look at\n[Development info](https://github.com/markdown-it/markdown-it/tree/master/docs).\n\n\n## Syntax extensions\n\nEmbedded (enabled by default):\n\n- [Tables](https://help.github.com/articles/organizing-information-with-tables/) (GFM)\n- [Strikethrough](https://help.github.com/articles/basic-writing-and-formatting-syntax/#styling-text) (GFM)\n\nVia plugins:\n\n- [subscript](https://github.com/markdown-it/markdown-it-sub)\n- [superscript](https://github.com/markdown-it/markdown-it-sup)\n- [footnote](https://github.com/markdown-it/markdown-it-footnote)\n- [definition list](https://github.com/markdown-it/markdown-it-deflist)\n- [abbreviation](https://github.com/markdown-it/markdown-it-abbr)\n- [emoji](https://github.com/markdown-it/markdown-it-emoji)\n- [custom container](https://github.com/markdown-it/markdown-it-container)\n- [insert](https://github.com/markdown-it/markdown-it-ins)\n- [mark](https://github.com/markdown-it/markdown-it-mark)\n- ... and [others](https://www.npmjs.org/browse/keyword/markdown-it-plugin)\n\n\n### Manage rules\n\nBy default all rules are enabled, but can be restricted by options. On plugin\nload all its rules are enabled automatically.\n\n```js\nimport markdownit from 'markdown-it'\n\n// Activate/deactivate rules, with currying\nconst md = markdownit()\n  .disable(['link', 'image'])\n  .enable(['link'])\n  .enable('image');\n\n// Enable everything\nconst md = markdownit({\n  html: true,\n  linkify: true,\n  typographer: true,\n});\n```\n\nYou can find all rules in sources:\n\n- [`parser_core.mjs`](lib/parser_core.mjs)\n- [`parser_block.mjs`](lib/parser_block.mjs)\n- [`parser_inline.mjs`](lib/parser_inline.mjs)\n\n\n## Benchmark\n\nHere is the result of readme parse at MB Pro Retina 2013 (2.4 GHz):\n\n```bash\nnpm run benchmark-deps\nbenchmark/benchmark.mjs readme\n\nSelected samples: (1 of 28)\n &gt; README\n\nSample: README.md (7774 bytes)\n &gt; commonmark-reference x 1,222 ops/sec ±0.96% (97 runs sampled)\n &gt; current x 743 ops/sec ±0.84% (97 runs sampled)\n &gt; current-commonmark x 1,568 ops/sec ±0.84% (98 runs sampled)\n &gt; marked x 1,587 ops/sec ±4.31% (93 runs sampled)\n```\n\n__Note.__ CommonMark version runs with [simplified link normalizers](https://github.com/markdown-it/markdown-it/blob/master/benchmark/implementations/current-commonmark/index.mjs)\nfor more \"honest\" compare. Difference is ≈1.5×.\n\nAs you can see, `markdown-it` doesn't pay with speed for its flexibility.\nSlowdown of \"full\" version caused by additional features not available in\nother implementations.\n\n\n## markdown-it for enterprise\n\nAvailable as part of the Tidelift Subscription.\n\nThe maintainers of `markdown-it` and thousands of other packages are working with Tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. Save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. [Learn more.](https://tidelift.com/subscription/pkg/npm-markdown-it?utm_source=npm-markdown-it&amp;utm_medium=referral&amp;utm_campaign=enterprise&amp;utm_term=repo)\n\n\n## Authors\n\n- Alex Kocharin [github/rlidwka](https://github.com/rlidwka)\n- Vitaly Puzrin [github/puzrin](https://github.com/puzrin)\n\n_markdown-it_ is the result of the decision of the authors who contributed to\n99% of the _Remarkable_ code to move to a project with the same authorship but\nnew leadership (Vitaly and Alex). It's not a fork.\n\n## References / Thanks\n\nBig thanks to [John MacFarlane](https://github.com/jgm) for his work on the\nCommonMark spec and reference implementations. His work saved us a lot of time\nduring this project's development.\n\n**Related Links:**\n\n- https://github.com/jgm/CommonMark - reference CommonMark implementations in C &amp; JS,\n  also contains latest spec &amp; online demo.\n- http://talk.commonmark.org - CommonMark forum, good place to collaborate\n  developers' efforts.\n\n**Ports**\n\n- [motion-markdown-it](https://github.com/digitalmoksha/motion-markdown-it) - Ruby/RubyMotion\n- [markdown-it-py](https://github.com/ExecutableBookProject/markdown-it-py)- Python\n</md></sn>","topic_id":938,"last_visited":"2025-04-25T04:26:32.397Z"},{"topic_name":"06.indexJs","topic_html":"<sn><pre data-v=\"javascript\" data-t=\"index.mjs\">// Main parser class\n\nimport * as utils from './common/utils.mjs'\nimport * as helpers from './helpers/index.mjs'\nimport Renderer from './renderer.mjs'\nimport ParserCore from './parser_core.mjs'\nimport ParserBlock from './parser_block.mjs'\nimport ParserInline from './parser_inline.mjs'\nimport LinkifyIt from 'linkify-it'\nimport * as mdurl from 'mdurl'\nimport punycode from 'punycode.js'\n\nimport cfg_default from './presets/default.mjs'\nimport cfg_zero from './presets/zero.mjs'\nimport cfg_commonmark from './presets/commonmark.mjs'\n\nconst config = {\n  default: cfg_default,\n  zero: cfg_zero,\n  commonmark: cfg_commonmark\n}\n\n//\n// This validator can prohibit more than really needed to prevent XSS. It's a\n// tradeoff to keep code simple and to be secure by default.\n//\n// If you need different setup - override validator method as you wish. Or\n// replace it with dummy function and use external sanitizer.\n//\n\nconst BAD_PROTO_RE = /^(vbscript|javascript|file|data):/\nconst GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/\n\nfunction validateLink (url) {\n  // url should be normalized at this point, and existing entities are decoded\n  const str = url.trim().toLowerCase()\n\n  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true\n}\n\nconst RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:']\n\nfunction normalizeLink (url) {\n  const parsed = mdurl.parse(url, true)\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) &gt;= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname)\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.encode(mdurl.format(parsed))\n}\n\nfunction normalizeLinkText (url) {\n  const parsed = mdurl.parse(url, true)\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) &gt;= 0) {\n      try {\n        parsed.hostname = punycode.toUnicode(parsed.hostname)\n      } catch (er) { /**/ }\n    }\n  }\n\n  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720\n  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%')\n}\n\n/**\n * class MarkdownIt\n *\n * Main parser/renderer class.\n *\n * ##### Usage\n *\n * ```javascript\n * // node.js, \"classic\" way:\n * var MarkdownIt = require('markdown-it'),\n *     md = new MarkdownIt();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // node.js, the same, but with sugar:\n * var md = require('markdown-it')();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // browser without AMD, added to \"window\" on script load\n * // Note, there are no dash.\n * var md = window.markdownit();\n * var result = md.render('# markdown-it rulezz!');\n * ```\n *\n * Single line rendering, without paragraph wrap:\n *\n * ```javascript\n * var md = require('markdown-it')();\n * var result = md.renderInline('__markdown-it__ rulezz!');\n * ```\n **/\n\n/**\n * new MarkdownIt([presetName, options])\n * - presetName (String): optional, `commonmark` / `zero`\n * - options (Object)\n *\n * Creates parser instanse with given config. Can be called without `new`.\n *\n * ##### presetName\n *\n * MarkdownIt provides named presets as a convenience to quickly\n * enable/disable active syntax rules and options for common use cases.\n *\n * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.mjs) -\n *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.mjs) -\n *   similar to GFM, used when no preset name given. Enables all available rules,\n *   but still without html, typographer &amp; autolinker.\n * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.mjs) -\n *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n *   For example, when you need only `bold` and `italic` markup and nothing else.\n *\n * ##### options:\n *\n * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n *   That's not safe! You may need external sanitizer to protect output from XSS.\n *   It's better to extend features via plugins, instead of enabling HTML.\n * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n *   (`&lt;br /&gt;`). This is needed only for full CommonMark compatibility. In real\n *   world you will need HTML output.\n * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `&lt;br&gt;`.\n * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n *   Can be useful for external highlighters.\n * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.mjs) +\n *   quotes beautification (smartquotes).\n * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement\n *   pairs, when typographer enabled and smartquotes on. For example, you can\n *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and\n *   `['«\\xA0', '\\xA0»', '‹\\xA0', '\\xA0›']` for French (including nbsp).\n * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n *   return empty string if the source was not changed and should be escaped\n *   externaly. If result starts with &lt;pre... internal wrapper is skipped.\n *\n * ##### Example\n *\n * ```javascript\n * // commonmark mode\n * var md = require('markdown-it')('commonmark');\n *\n * // default mode\n * var md = require('markdown-it')();\n *\n * // enable everything\n * var md = require('markdown-it')({\n *   html: true,\n *   linkify: true,\n *   typographer: true\n * });\n * ```\n *\n * ##### Syntax highlighting\n *\n * ```js\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang &amp;&amp; hljs.getLanguage(lang)) {\n *       try {\n *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;\n *       } catch (__) {}\n *     }\n *\n *     return ''; // use external default escaping\n *   }\n * });\n * ```\n *\n * Or with full wrapper override (if you need assign class to `&lt;pre&gt;` or `&lt;code&gt;`):\n *\n * ```javascript\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * // Actual default values\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang &amp;&amp; hljs.getLanguage(lang)) {\n *       try {\n *         return '&lt;pre&gt;&lt;code class=\"hljs\"&gt;' +\n *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +\n *                '&lt;/code&gt;&lt;/pre&gt;';\n *       } catch (__) {}\n *     }\n *\n *     return '&lt;pre&gt;&lt;code class=\"hljs\"&gt;' + md.utils.escapeHtml(str) + '&lt;/code&gt;&lt;/pre&gt;';\n *   }\n * });\n * ```\n *\n **/\nfunction MarkdownIt (presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options)\n  }\n\n  if (!options) {\n    if (!utils.isString(presetName)) {\n      options = presetName || {}\n      presetName = 'default'\n    }\n  }\n\n  /**\n   * MarkdownIt#inline -&gt; ParserInline\n   *\n   * Instance of [[ParserInline]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.inline = new ParserInline()\n\n  /**\n   * MarkdownIt#block -&gt; ParserBlock\n   *\n   * Instance of [[ParserBlock]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.block = new ParserBlock()\n\n  /**\n   * MarkdownIt#core -&gt; Core\n   *\n   * Instance of [[Core]] chain executor. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.core = new ParserCore()\n\n  /**\n   * MarkdownIt#renderer -&gt; Renderer\n   *\n   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n   * rules for new token types, generated by plugins.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * function myToken(tokens, idx, options, env, self) {\n   *   //...\n   *   return result;\n   * };\n   *\n   * md.renderer.rules['my_token'] = myToken\n   * ```\n   *\n   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.mjs).\n   **/\n  this.renderer = new Renderer()\n\n  /**\n   * MarkdownIt#linkify -&gt; LinkifyIt\n   *\n   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.mjs)\n   * rule.\n   **/\n  this.linkify = new LinkifyIt()\n\n  /**\n   * MarkdownIt#validateLink(url) -&gt; Boolean\n   *\n   * Link validation function. CommonMark allows too much in links. By default\n   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n   * except some embedded image types.\n   *\n   * You can change this behaviour:\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   * // enable everything\n   * md.validateLink = function () { return true; }\n   * ```\n   **/\n  this.validateLink = validateLink\n\n  /**\n   * MarkdownIt#normalizeLink(url) -&gt; String\n   *\n   * Function used to encode link url to a machine-readable format,\n   * which includes url-encoding, punycode, etc.\n   **/\n  this.normalizeLink = normalizeLink\n\n  /**\n   * MarkdownIt#normalizeLinkText(url) -&gt; String\n   *\n   * Function used to decode link url to a human-readable format`\n   **/\n  this.normalizeLinkText = normalizeLinkText\n\n  // Expose utils &amp; helpers for easy acces from plugins\n\n  /**\n   * MarkdownIt#utils -&gt; utils\n   *\n   * Assorted utility functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.mjs).\n   **/\n  this.utils = utils\n\n  /**\n   * MarkdownIt#helpers -&gt; helpers\n   *\n   * Link components parser functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n   **/\n  this.helpers = utils.assign({}, helpers)\n\n  this.options = {}\n  this.configure(presetName)\n\n  if (options) { this.set(options) }\n}\n\n/** chainable\n * MarkdownIt.set(options)\n *\n * Set parser options (in the same format as in constructor). Probably, you\n * will never need it, but you can change options after constructor call.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .set({ html: true, breaks: true })\n *             .set({ typographer, true });\n * ```\n *\n * __Note:__ To achieve the best possible performance, don't modify a\n * `markdown-it` instance options on the fly. If you need multiple configurations\n * it's best to create multiple instances and initialize each with separate\n * config.\n **/\nMarkdownIt.prototype.set = function (options) {\n  utils.assign(this.options, options)\n  return this\n}\n\n/** chainable, internal\n * MarkdownIt.configure(presets)\n *\n * Batch load of all options and compenent settings. This is internal method,\n * and you probably will not need it. But if you will - see available presets\n * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n *\n * We strongly recommend to use presets instead of direct config loads. That\n * will give better compatibility with next versions.\n **/\nMarkdownIt.prototype.configure = function (presets) {\n  const self = this\n\n  if (utils.isString(presets)) {\n    const presetName = presets\n    presets = config[presetName]\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name') }\n  }\n\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty') }\n\n  if (presets.options) { self.set(presets.options) }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enableOnly(presets.components[name].rules)\n      }\n      if (presets.components[name].rules2) {\n        self[name].ruler2.enableOnly(presets.components[name].rules2)\n      }\n    })\n  }\n  return this\n}\n\n/** chainable\n * MarkdownIt.enable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to enable\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable list or rules. It will automatically find appropriate components,\n * containing rules with given names. If rule not found, and `ignoreInvalid`\n * not set - throws exception.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .enable(['sub', 'sup'])\n *             .disable('smartquotes');\n * ```\n **/\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n  let result = []\n\n  if (!Array.isArray(list)) { list = [list] }\n\n  ['core', 'block', 'inline'].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.enable(list, true))\n  }, this)\n\n  result = result.concat(this.inline.ruler2.enable(list, true))\n\n  const missed = list.filter(function (name) { return result.indexOf(name) &lt; 0 })\n\n  if (missed.length &amp;&amp; !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed)\n  }\n\n  return this\n}\n\n/** chainable\n * MarkdownIt.disable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * The same as [[MarkdownIt.enable]], but turn specified rules off.\n **/\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n  let result = []\n\n  if (!Array.isArray(list)) { list = [list] }\n\n  ['core', 'block', 'inline'].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.disable(list, true))\n  }, this)\n\n  result = result.concat(this.inline.ruler2.disable(list, true))\n\n  const missed = list.filter(function (name) { return result.indexOf(name) &lt; 0 })\n\n  if (missed.length &amp;&amp; !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed)\n  }\n  return this\n}\n\n/** chainable\n * MarkdownIt.use(plugin, params)\n *\n * Load specified plugin with given params into current parser instance.\n * It's just a sugar to call `plugin(md, params)` with curring.\n *\n * ##### Example\n *\n * ```javascript\n * var iterator = require('markdown-it-for-inline');\n * var md = require('markdown-it')()\n *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n *             });\n * ```\n **/\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n  const args = [this].concat(Array.prototype.slice.call(arguments, 1))\n  plugin.apply(plugin, args)\n  return this\n}\n\n/** internal\n * MarkdownIt.parse(src, env) -&gt; Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Parse input string and return list of block tokens (special token type\n * \"inline\" will contain list of inline tokens). You should not call this\n * method directly, until you write custom renderer (for example, to produce\n * AST).\n *\n * `env` is used to pass data between \"distributed\" rules and return additional\n * metadata like reference info, needed for the renderer. It also can be used to\n * inject data in specific cases. Usually, you will be ok to pass `{}`,\n * and then pass updated object to renderer.\n **/\nMarkdownIt.prototype.parse = function (src, env) {\n  if (typeof src !== 'string') {\n    throw new Error('Input data should be a String')\n  }\n\n  const state = new this.core.State(src, this, env)\n\n  this.core.process(state)\n\n  return state.tokens\n}\n\n/**\n * MarkdownIt.render(src [, env]) -&gt; String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Render markdown string into html. It does all magic for you :).\n *\n * `env` can be used to inject additional metadata (`{}` by default).\n * But you will not need it with high probability. See also comment\n * in [[MarkdownIt.parse]].\n **/\nMarkdownIt.prototype.render = function (src, env) {\n  env = env || {}\n\n  return this.renderer.render(this.parse(src, env), this.options, env)\n}\n\n/** internal\n * MarkdownIt.parseInline(src, env) -&gt; Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n * block tokens list with the single `inline` element, containing parsed inline\n * tokens in `children` property. Also updates `env` object.\n **/\n\nMarkdownIt.prototype.parseInline = function (src, env) {\n  const state = new this.core.State(src, this, env)\n\n  state.inlineMode = true\n  this.core.process(state)\n\n  return state.tokens\n}\n\n/**\n * MarkdownIt.renderInline(src [, env]) -&gt; String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n * will NOT be wrapped into `&lt;p&gt;` tags.\n **/\nMarkdownIt.prototype.renderInline = function (src, env) {\n  env = env || {}\n\n  return this.renderer.render(this.parseInline(src, env), this.options, env)\n}\n\nexport default MarkdownIt\n</pre></sn><sn><md>### **Exp1**\n---\n### Imports\n1. **External Libraries**:\n   - **utils.mjs**: Contains utility functions for tasks like string handling, object manipulation, etc.\n   - **helpers/index.mjs**: Contains functions related to parsing links and other helper functions.\n   - **Renderer**: A module responsible for rendering the tokens generated by the parser into HTML.\n   - **ParserCore**: Core parser responsible for managing the parsing state and processing tokens.\n   - **ParserBlock &amp; ParserInline**: Handle parsing block-level and inline-level elements of markdown.\n   - **LinkifyIt**: A library to detect and convert URLs in text to anchor tags.\n   - **mdurl**: Provides URL parsing and normalization utilities.\n   - **punycode.js**: Handles internationalized domain names (IDN) and punycode encoding/decoding.\n   \n2. **Config Imports**: These are different configuration presets that define the rules for how Markdown should be parsed.\n   - **cfg_default**: The default configuration.\n   - **cfg_zero**: A configuration with no rules enabled.\n   - **cfg_commonmark**: A configuration for strict CommonMark compatibility.\n\n3. **Configuration Object**: The `config` object holds different preset configurations, allowing easy switching between them.\n\n### Validator and Link Normalization Functions\n- **validateLink**: This function validates if a given URL is safe by checking its scheme (e.g., preventing `javascript:`, `vbscript:`).\n- **normalizeLink**: This normalizes a link by URL-encoding it and applying Punycode to the hostname to ensure it’s machine-readable.\n- **normalizeLinkText**: This normalizes the text of a URL for display purposes, making sure it's in a human-readable format.\n\n### MarkdownIt Class\nThe **MarkdownIt** class is the core class that processes Markdown text. Here’s how it works:\n\n1. **Constructor (`MarkdownIt`)**:\n   - Takes two parameters: `presetName` and `options`.\n     - `presetName`: Used to set the Markdown parsing rules from predefined configurations.\n     - `options`: Configuration options to modify the parser's behavior.\n   - Initializes several properties such as `inline`, `block`, `core`, `renderer`, and `linkify`.\n   - `inline`, `block`, and `core` are instances of different parsing components that handle inline and block parsing, and the core parsing logic, respectively.\n   - The `renderer` is an instance of the `Renderer` class, which is responsible for converting the parsed tokens into HTML.\n   - The `linkify` is an instance of **LinkifyIt** used to automatically detect URLs in the input text.\n   - The constructor also validates and sets the configuration using `configure()` and `set()`.\n\n2. **Methods**:\n   - **set(options)**: Allows modifying the parser options after the instance has been created.\n   - **configure(presets)**: Batch loads all options and components settings from a given preset.\n   - **enable(list, ignoreInvalid)**: Enables specified parsing rules.\n   - **disable(list, ignoreInvalid)**: Disables specified parsing rules.\n   - **use(plugin, params)**: Loads a plugin into the parser with the given parameters.\n   - **parse(src, env)**: Takes a Markdown string (`src`) and an optional `env` object, parses it, and returns a list of tokens (the intermediate representation of the Markdown).\n   - **render(src, env)**: Renders the parsed tokens into HTML.\n   - **parseInline(src, env)**: Similar to `parse`, but it only processes inline elements and skips block-level elements.\n   - **renderInline(src, env)**: Renders inline Markdown into HTML (no paragraph wrap).\n\n### Parsing Process\n1. **MarkdownIt** parses the input Markdown string into tokens using the `parse` method. These tokens represent the elements of the Markdown content (e.g., headings, links, paragraphs).\n   \n2. **Tokens** are then passed to the **renderer**, which generates the corresponding HTML. The renderer uses the **Renderer** class to define how each type of token should be rendered (e.g., how to render a link, image, or heading).\n\n3. **Block vs. Inline Parsing**: The parser distinguishes between block-level and inline-level elements. For example:\n   - Block-level elements might be paragraphs, headings, or lists.\n   - Inline elements might be bold text, italic text, or links.\n\n### Plugin Support\n- **Plugins** can be loaded into the MarkdownIt instance using the `use()` method. This allows for extending the functionality of the parser with custom rules.\n\n### Example Usage:\n```javascript\nvar md = require('markdown-it')()\nvar result = md.render('# markdown-it rulezz!')\n```\nIn the example, the `render` method converts the Markdown string `# markdown-it rulezz!` into HTML.\n\n### Summary\n- **MarkdownIt** provides a flexible Markdown parser and renderer that can be configured using different presets.\n- It supports parsing both block-level and inline Markdown elements.\n- The parser can be extended with plugins, and its behavior can be modified with configuration options.\n- It ensures safe link handling by validating URLs and normalizing them into a safe and consistent format.\n</md></sn><sn><md>### **Exp2**\n---\nI'll walk you through the code step by step:\n\n### 1. **Imports**:\nThe first part of the code imports various modules needed for the parser to work:\n```js\nimport * as utils from './common/utils.mjs'\nimport * as helpers from './helpers/index.mjs'\nimport Renderer from './renderer.mjs'\nimport ParserCore from './parser_core.mjs'\nimport ParserBlock from './parser_block.mjs'\nimport ParserInline from './parser_inline.mjs'\nimport LinkifyIt from 'linkify-it'\nimport * as mdurl from 'mdurl'\nimport punycode from 'punycode.js'\n\nimport cfg_default from './presets/default.mjs'\nimport cfg_zero from './presets/zero.mjs'\nimport cfg_commonmark from './presets/commonmark.mjs'\n\nconst config = {\n  default: cfg_default,\n  zero: cfg_zero,\n  commonmark: cfg_commonmark\n}\n```\n\n### Explanation:\n- The imports include utility functions, core parser components, link normalization tools, URL parsing, and presets that define various Markdown configurations.\n- The `config` object maps preset names to their respective configuration modules (`cfg_default`, `cfg_zero`, `cfg_commonmark`), which set different rules for Markdown parsing.\n\n### 2. **Link Validation and Normalization Functions**:\nThe `validateLink`, `normalizeLink`, and `normalizeLinkText` functions ensure URLs are safe and properly formatted.\n\n```js\nconst BAD_PROTO_RE = /^(vbscript|javascript|file|data):/\nconst GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/\n\nfunction validateLink (url) {\n  const str = url.trim().toLowerCase()\n  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true\n}\n```\n\n- **`validateLink`**: It checks if a URL uses potentially dangerous protocols (e.g., `javascript:` or `file:`). It ensures that URLs that use these protocols are allowed only if they are safe (i.e., data URLs for images).\n  \n```js\nconst RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:']\n\nfunction normalizeLink (url) {\n  const parsed = mdurl.parse(url, true)\n  if (parsed.hostname) {\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) &gt;= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname)\n      } catch (er) { /**/ }\n    }\n  }\n  return mdurl.encode(mdurl.format(parsed))\n}\n```\n\n- **`normalizeLink`**: This function normalizes the URL (e.g., encoding the hostname using `punycode`) and ensures that it’s machine-readable.\n- **`normalizeLinkText`**: Decodes the URL into a human-readable format, converting it back from encoded ASCII (for display purposes).\n\n### 3. **MarkdownIt Class**:\nThis is the core of the Markdown parser, responsible for setting options, configuring components, and providing the rendering functionality.\n\n```js\nfunction MarkdownIt (presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options)\n  }\n\n  if (!options) {\n    if (!utils.isString(presetName)) {\n      options = presetName || {}\n      presetName = 'default'\n    }\n  }\n```\n\n- **MarkdownIt Constructor**: Initializes a new instance of `MarkdownIt`. If it's called without `new`, it ensures that a new instance is created.\n- It also accepts configuration options (`presetName` and `options`), which can specify how the Markdown parser behaves (e.g., strict Markdown, GFM-style, or minimal parsing).\n\n### 4. **Parser Components**:\nInside the `MarkdownIt` constructor, various parser components are initialized:\n```js\n  this.inline = new ParserInline()\n  this.block = new ParserBlock()\n  this.core = new ParserCore()\n  this.renderer = new Renderer()\n  this.linkify = new LinkifyIt()\n```\n\n- **Parser Components**: \n  - `inline`: Handles inline elements like links, images, and formatting (bold, italic).\n  - `block`: Handles block elements like headings, paragraphs, and lists.\n  - `core`: Core processing logic for parsing Markdown.\n  - `renderer`: Converts the parsed tokens into HTML.\n  - `linkify`: Used to automatically detect URLs and convert them into HTML links.\n\n### 5. **Link Validation, Normalization, and Utilities**:\n```js\n  this.validateLink = validateLink\n  this.normalizeLink = normalizeLink\n  this.normalizeLinkText = normalizeLinkText\n  this.utils = utils\n  this.helpers = utils.assign({}, helpers)\n```\n\n- **`validateLink`**: Ensures that any URL in the Markdown is safe.\n- **`normalizeLink`**: Normalizes the URLs in the parsed Markdown.\n- **`helpers` and `utils`**: Provides utility functions and helper methods to aid in custom plugin creation and Markdown processing.\n\n### 6. **Configuration**:\n```js\n  this.options = {}\n  this.configure(presetName)\n\n  if (options) { this.set(options) }\n```\n\n- **Configuration**: The `configure` method is called to load the default preset (`presetName`). If any additional options are passed, the `set` method is used to apply them.\n\n### 7. **Methods**:\nHere are the main methods provided by the `MarkdownIt` class:\n\n#### a) `set()`:\n```js\nMarkdownIt.prototype.set = function (options) {\n  utils.assign(this.options, options)\n  return this\n}\n```\n- **`set()`**: Allows you to dynamically change the parser's options after the instance has been created.\n\n#### b) `configure()`:\n```js\nMarkdownIt.prototype.configure = function (presets) {\n  // Applies configuration from the given preset\n  // Throws error if the preset is invalid\n  const self = this\n  if (utils.isString(presets)) {\n    const presetName = presets\n    presets = config[presetName]\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name') }\n  }\n\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty') }\n  if (presets.options) { self.set(presets.options) }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enableOnly(presets.components[name].rules)\n      }\n    })\n  }\n  return this\n}\n```\n- **`configure()`**: Loads configuration options from a preset. This method is used internally to apply a preset (e.g., `commonmark`, `default`, `zero`).\n\n#### c) `enable()` and `disable()`:\n```js\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n  // Enables specified rules in the parser\n}\n\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n  // Disables specified rules in the parser\n}\n```\n- **`enable()`**: Enables specified Markdown rules.\n- **`disable()`**: Disables specified Markdown rules.\n\n#### d) `use()`:\n```js\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n  // Loads a plugin into the parser instance\n  const args = [this].concat(Array.prototype.slice.call(arguments, 1))\n  plugin.apply(plugin, args)\n  return this\n}\n```\n- **`use()`**: Loads a plugin into the parser. Plugins can extend the functionality of the parser.\n\n#### e) `parse()` and `render()`:\n```js\nMarkdownIt.prototype.parse = function (src, env) {\n  // Parses Markdown source into a list of tokens\n}\n\nMarkdownIt.prototype.render = function (src, env) {\n  // Renders parsed tokens into HTML\n}\n```\n- **`parse()`**: Converts a Markdown string into tokens (intermediate representation).\n- **`render()`**: Converts the parsed tokens into HTML.\n\n### 8. **Export**:\n```js\nexport default MarkdownIt\n```\n- **Export**: Exports the `MarkdownIt` class so it can be used elsewhere.\n\n---\n\n### Summary:\n\nThe `MarkdownIt` class is a modular Markdown parser and renderer with multiple components (block, inline, core) and utility methods to parse Markdown into HTML. It offers flexibility through configuration presets, plugin support, and methods for enabling/disabling parsing rules. This parser is highly customizable and can be extended to handle additional features such as syntax highlighting, link handling, and custom Markdown syntax.</md></sn>","topic_id":939,"last_visited":"2025-04-25T05:14:28.076Z"},{"topic_name":"07.Plugin example","topic_html":"<sn><md>### **Plugin**\n---\n\nTo create a new custom Markdown syntax for `MarkdownIt`, where the syntax `(embed){url}` is converted into the following HTML:\n\n```html\n&lt;temp&gt;&lt;iframe src=\"url\" height=\"500px\" width=\"500px\"&gt;&lt;/temp&gt;\n```\n\nYou will need to write a custom rule in the `MarkdownIt` parser. Here's how you can implement it:\n\n### Steps to Create Custom Syntax:\n\n1. **Create the Rule**: We will create a custom rule to handle the `(embed){url}` syntax.\n2. **Use the `use` method**: To register our custom syntax.\n3. **Modify the `MarkdownIt` instance**: To parse this new syntax and render it as HTML.\n\nHere's how to do it:\n\n### Full Code Example:\n\n```js\nimport MarkdownIt from 'markdown-it'\n\nconst md = new MarkdownIt()\n\n// Custom rule for (embed){url}\nmd.inline.ruler.before('emphasis', 'embed', function (state, silent) {\n  const start = state.pos\n  const max = state.posMax\n\n  // Check if the text starts with '(embed){'\n  if (state.src[start] !== '(' || state.src[start + 1] !== 'e' || state.src[start + 2] !== 'm' || state.src[start + 3] !== 'b' || state.src[start + 4] !== 'e' || state.src[start + 5] !== 'd' || state.src[start + 6] !== ')') {\n    return false\n  }\n\n  const endPos = state.src.indexOf('}', start)\n\n  // If there is no closing bracket or it's malformed, return\n  if (endPos === -1) return false\n\n  const url = state.src.slice(start + 7, endPos)\n\n  // If we're in silent mode, just validate and return\n  if (silent) {\n    return true\n  }\n\n  // Create a token that will be processed\n  const token = state.push('embed', 'temp', 0)\n  token.attrs = [\n    ['src', url],\n    ['height', '500px'],\n    ['width', '500px']\n  ]\n\n  // Move the position forward\n  state.pos = endPos + 1\n  return true\n})\n\n// Renderer to convert 'embed' token to HTML\nmd.renderer.rules.embed = function (tokens, idx) {\n  const token = tokens[idx]\n  const src = token.attrs.find(attr =&gt; attr[0] === 'src')[1]\n  const height = token.attrs.find(attr =&gt; attr[0] === 'height')[1]\n  const width = token.attrs.find(attr =&gt; attr[0] === 'width')[1]\n  return `&lt;temp&gt;&lt;iframe src=\"${src}\" height=\"${height}\" width=\"${width}\"&gt;&lt;/iframe&gt;&lt;/temp&gt;`\n}\n\n// Test the new syntax\nconst markdown = '(embed){https://example.com}'\nconst result = md.render(markdown)\nconsole.log(result)\n```\n\n### Explanation:\n\n1. **Custom Inline Rule**:\n   - We use `md.inline.ruler.before('emphasis', 'embed', ...)` to create a new rule that goes before the `emphasis` rule.\n   - The function checks if the string starts with `(embed){`, extracts the URL, and validates the syntax.\n   - It then creates a new token of type `'embed'` with attributes for `src`, `height`, and `width`.\n\n2. **Renderer**:\n   - We define a custom renderer for the `'embed'` token. The renderer converts the token attributes into an `&lt;iframe&gt;` wrapped in a `&lt;temp&gt;` tag.\n   - The iframe is given a fixed `height` and `width` of `500px`.\n\n3. **Testing the Syntax**:\n   - The `markdown` string contains the custom syntax `(embed){https://example.com}`.\n   - The `md.render(markdown)` method processes the markdown and converts it into HTML.\n   \n### Output:\n\nFor the input:\n\n```markdown\n(embed){https://example.com}\n```\n\nThe resulting HTML will be:\n\n```html\n&lt;temp&gt;&lt;iframe src=\"https://example.com\" height=\"500px\" width=\"500px\"&gt;&lt;/iframe&gt;&lt;/temp&gt;\n```\n\n### How to Use:\n\n- Include the code above in your project where you initialize `MarkdownIt`.\n- You can use the custom syntax `(embed){url}` in your Markdown files, and it will be rendered as an `&lt;iframe&gt;` inside a `&lt;temp&gt;` tag.\n</md></sn>","topic_id":940,"last_visited":"2025-04-25T10:23:04.747Z"},{"topic_name":"08.ruler","topic_html":"<sn><h5>Overview</h5><pre data-v=\"javascript\">/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n\n/**\n * new Ruler()\n **/\n</pre></sn><sn><h3>Ruler Constructor function</h3><pre data-v=\"javascript\">/**\n * new Ruler()\n **/\nfunction Ruler () {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = []\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null\n}\n</pre></sn><sn><md>### **\\_\\_find\\_\\_**\n---\nThis code defines a **helper method** inside the `Ruler` class called `__find__`, which is designed to find the index of a rule by its name in the `__rules__` array. The method is not intended to be used directly, as suggested by the comment above it.\n\n### **Explanation of the `__find__` Method:**\n\nThe `__find__` method iterates over the `__rules__` array, which contains the rules added to the `Ruler` class. Each rule has a `name` property. The goal of this method is to return the **index** of the rule whose name matches the provided `name` parameter.\n\nIf the rule with the specified name is found, the method returns its index in the array. If not, it returns `-1`, indicating that the rule wasn't found.\n\n### **Code Breakdown:**\n\n```js\nRuler.prototype.__find__ = function (name) {\n  // Iterate over all the rules in the __rules__ array\n  for (let i = 0; i &lt; this.__rules__.length; i++) {\n    // If the rule's name matches the provided name, return its index\n    if (this.__rules__[i].name === name) {\n      return i;\n    }\n  }\n  // If the rule was not found, return -1\n  return -1;\n};\n```\n\n### **How the `__find__` Method Works:**\n\n1. **For Loop**: It loops through the `__rules__` array.\n   - `this.__rules__`: Array of rules in the `Ruler` object.\n   - Each rule is an object with a `name` property (like `name: 'bold'`).\n\n2. **Condition Check**: Inside the loop, it checks if the `name` of the current rule matches the `name` argument passed to the `__find__` method.\n   - If a match is found, the method returns the index of that rule (the current value of `i`).\n   \n3. **Return -1**: If the loop finishes and no matching rule is found, it returns `-1` to indicate that the rule with the specified name does not exist in the list.\n\n### **Example:**\n\nLet's walk through an example with a `Ruler` class that has a few rules.\n\n```js\nfunction Ruler() {\n  this.__rules__ = [];\n}\n\n// Adding rules to the Ruler\nRuler.prototype.addRule = function(name, enabled, fn) {\n  this.__rules__.push({ name, enabled, fn });\n};\n\n// Helper method to find a rule by name\nRuler.prototype.__find__ = function (name) {\n  for (let i = 0; i &lt; this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i;  // Return the index of the rule\n    }\n  }\n  return -1;  // Return -1 if rule not found\n};\n\n// Example usage\nconst ruler = new Ruler();\nruler.addRule(\"bold\", true, function(str) { return `**${str}**`; });\nruler.addRule(\"italic\", true, function(str) { return `*${str}*`; });\n\n// Now find a rule by its name\nconst boldIndex = ruler.__find__(\"bold\");  // Expected: 0 (first rule)\nconst italicIndex = ruler.__find__(\"italic\");  // Expected: 1 (second rule)\nconst unknownIndex = ruler.__find__(\"underline\");  // Expected: -1 (not found)\n\nconsole.log(boldIndex);  // Outputs: 0\nconsole.log(italicIndex);  // Outputs: 1\nconsole.log(unknownIndex);  // Outputs: -1\n```\n\n### **Step-by-step Example:**\n\n1. **Create the `Ruler` object**: \n   - `const ruler = new Ruler();`\n\n2. **Add Rules**:\n   - The rule `bold` is added first, so its index is `0`.\n   - The rule `italic` is added second, so its index is `1`.\n\n3. **Call `__find__` Method**:\n   - `ruler.__find__(\"bold\")`: Finds the rule with the name `\"bold\"`, and returns `0` because it's the first rule.\n   - `ruler.__find__(\"italic\")`: Finds the rule with the name `\"italic\"`, and returns `1`.\n   - `ruler.__find__(\"underline\")`: No rule with this name exists, so it returns `-1`.\n\n### **Summary**:\nThe `__find__` method is used to find the index of a rule by its name. If the rule exists, it returns its index; otherwise, it returns `-1`. This method helps in quickly identifying and working with rules in the `__rules__` array.</md></sn><sn><md>### **rule,rules,chaing,cache**\n---\nTo better understand how the **rules**, **rule**, **chain**, **chains**, and **cache** work in the context of the `Ruler` class, let’s break them down and provide example objects or arrays for each.\n\n### **1. `__rules__` (Array of Rules)**\n\nThe `__rules__` array holds all the rules added to the `Ruler` class. Each rule is an object with properties like `name`, `enabled`, `fn` (the function to execute), and `alt` (alternative rule names).\n\n#### Example `__rules__` Array:\n\n```js\nconst __rules__ = [\n  {\n    name: \"bold\",\n    enabled: true,\n    fn: function(str) { return `**${str}**`; },\n    alt: [\"b\"]\n  },\n  {\n    name: \"italic\",\n    enabled: true,\n    fn: function(str) { return `*${str}*`; },\n    alt: [\"i\"]\n  },\n  {\n    name: \"underline\",\n    enabled: false,\n    fn: function(str) { return `__${str}__`; },\n    alt: [\"u\"]\n  }\n];\n```\n\n- **`name`**: The name of the rule (`\"bold\"`, `\"italic\"`, etc.).\n- **`enabled`**: A boolean indicating whether the rule is active (`true`) or not (`false`).\n- **`fn`**: A function that processes the input string (e.g., for bold, it wraps the string in `**`).\n- **`alt`**: An array of alternative names for the rule (e.g., `\"b\"` for `bold`, `\"i\"` for `italic`).\n\n### **2. `rule` (Single Rule Object)**\n\nA single rule object is one of the elements in the `__rules__` array. Here’s an example of the `bold` rule object:\n\n```js\nconst rule = {\n  name: \"bold\",\n  enabled: true,\n  fn: function(str) { return `**${str}**`; },\n  alt: [\"b\"]\n};\n```\n\n### **3. `chain` (Single Rule Chain Name)**\n\nA **chain** represents a specific name in the rule set, which could be the rule name itself (like `\"bold\"`) or an alternative name (like `\"b\"`). Chains help in grouping rules.\n\nFor example:\n- **`chain`** can be `\"bold\"` (the primary rule name).\n- **`chain`** can also be `\"b\"` (an alternative name for the `bold` rule).\n\n#### Example Chains:\n```js\nconst chain1 = \"\";      // Default chain (no specific rule name).\nconst chain2 = \"b\";     // The alternative name for the \"bold\" rule.\nconst chain3 = \"i\";     // The alternative name for the \"italic\" rule.\n```\n\n### **4. `chains` (Array of All Chains)**\n\nThe `chains` array holds all unique chain names, including the default chain and the alternative names for each rule. It includes the rule names and any alternative names collected from the rules.\n\n#### Example `chains` Array:\n\n```js\nconst chains = [\"\", \"b\", \"i\"];  // Default chain and the alternative names for 'bold' and 'italic'.\n```\n\n- The first element (`\"\"`) represents the default chain.\n- `\"b\"` represents the alternative name for the `\"bold\"` rule.\n- `\"i\"` represents the alternative name for the `\"italic\"` rule.\n\n### **5. `__cache__` (Object Mapping Chains to Rule Functions)**\n\nThe `__cache__` is an object that maps each chain (rule name or alternative name) to an array of rule functions that belong to that chain. This is built by the `__compile__` method.\n\n#### Example `__cache__` Object:\n\n```js\nconst __cache__ = {\n  \"\": [ function(str) { return `**${str}**`; }, function(str) { return `*${str}*`; } ],  // Default chain includes bold and italic functions.\n  \"b\": [ function(str) { return `**${str}**`; } ],  // The \"b\" chain only includes the bold function.\n  \"i\": [ function(str) { return `*${str}*`; } ]   // The \"i\" chain only includes the italic function.\n};\n```\n\n- The `\"\"` chain (default) includes both the **bold** and **italic** rule functions.\n- The `\"b\"` chain only includes the **bold** rule function because `\"b\"` is an alternative name for `\"bold\"`.\n- The `\"i\"` chain only includes the **italic** rule function because `\"i\"` is an alternative name for `\"italic\"`.\n\n### **Putting It All Together:**\n\nHere’s how everything ties together:\n\n1. **`__rules__`** contains all rules (like **bold** and **italic**), including their functions and alternative names.\n2. **`chains`** is an array of all the unique rule names and their alternatives (like `\"\"`, `\"b\"`, `\"i\"`).\n3. **`__cache__`** is the final lookup table that maps each chain to the corresponding rule functions.\n\n#### Example Code:\n\n```js\n// Simulating rules and cache setup\nconst __rules__ = [\n  {\n    name: \"bold\",\n    enabled: true,\n    fn: function(str) { return `**${str}**`; },\n    alt: [\"b\"]\n  },\n  {\n    name: \"italic\",\n    enabled: true,\n    fn: function(str) { return `*${str}*`; },\n    alt: [\"i\"]\n  },\n  {\n    name: \"underline\",\n    enabled: false,\n    fn: function(str) { return `__${str}__`; },\n    alt: [\"u\"]\n  }\n];\n\n// Cache and chains building\nconst chains = [\"\", \"b\", \"i\"];  // Unique chains\nconst __cache__ = {\n  \"\": [function(str) { return `**${str}**`; }, function(str) { return `*${str}*`; }],\n  \"b\": [function(str) { return `**${str}**`; }],\n  \"i\": [function(str) { return `*${str}*`; }]\n};\n\n// Using the cache (example)\nconst str = \"Hello, World!\";\n\n// Apply bold using the \"b\" chain\nconst boldResult = __cache__[\"b\"][0](str);  // Outputs: **Hello, World!**\nconsole.log(boldResult);\n\n// Apply italic using the \"i\" chain\nconst italicResult = __cache__[\"i\"][0](str);  // Outputs: *Hello, World!*\nconsole.log(italicResult);\n```\n\n### **Summary:**\n\n- **`__rules__`**: Holds all the rule objects (like `\"bold\"`, `\"italic\"`, etc.), each with its function and alternative names.\n- **`rule`**: A single rule object in the `__rules__` array.\n- **`chain`**: A specific rule name or alternative name (e.g., `\"b\"` for bold).\n- **`chains`**: An array of all unique chain names (including default and alternative rule names).\n- **`__cache__`**: A lookup cache that maps chains (rule names or alternatives) to rule functions.\n\n</md></sn><sn><md>#### **\\_\\_compile\\_\\_**\n---\nThis code is part of the `Ruler` class, specifically the `__compile__` method. The purpose of this method is to **build a cache** of rule chains for faster application and lookup of rules in the future. It does this by creating a list of rule names and their alternative names, and then creating a cache that associates each chain (group of related rules) with the rule functions that belong to it.\n\n### **Explanation of the `__compile__` Method:**\n\nThe `__compile__` method works as follows:\n\n1. **Creating the `chains` Array**:\n   - An empty array `chains` is initialized with just an empty string `['']`. This will eventually hold all unique rule names and their alternative names.\n   \n2. **Collecting Unique Rule Names**:\n   - The method loops through each rule in the `__rules__` array and checks whether the rule is enabled (`if (!rule.enabled) { return }`).\n   - For each enabled rule, it checks if any of the rule's alternative names (`alt`) are already in the `chains` array. If not, it adds them to `chains`.\n\n3. **Initializing the `__cache__`**:\n   - The `__cache__` property is initialized as an empty object (`self.__cache__ = {}`). This will eventually hold the lookup cache for each rule chain.\n\n4. **Building the Cache**:\n   - The method then iterates over each `chain` in the `chains` array (which includes both the rule names and alternative names).\n   - For each chain, it initializes an empty array in the `__cache__` object for that chain.\n   - Then it loops through the rules again. If a rule is enabled and its alternative names include the current `chain` (or if the chain is an empty string, indicating the default chain), the rule’s function (`rule.fn`) is added to the cache for that chain.\n\n### **Code Breakdown:**\n\n```js\nRuler.prototype.__compile__ = function () {\n  const self = this;\n  const chains = [''];  // Initialize with an empty string as the default chain\n\n  // Collect unique names from the rules and their alternatives\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    // Add rule's alternative names to chains if not already included\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) &lt; 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  // Initialize the cache object\n  self.__cache__ = {};\n\n  // Build the cache by associating rule functions with their chains\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];  // Initialize an empty array for each chain\n\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      // Only include rules that match the current chain\n      if (chain &amp;&amp; rule.alt.indexOf(chain) &lt; 0) { return; }\n\n      // Add rule function to the cache for this chain\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n```\n\n### **Example Walkthrough:**\n\nLet’s walk through an example where we have a `Ruler` object with a couple of rules, each with some alternative names:\n\n```js\nfunction Ruler() {\n  this.__rules__ = [];\n  this.__cache__ = null;\n}\n\nRuler.prototype.addRule = function(name, enabled, fn, alt) {\n  this.__rules__.push({ name, enabled, fn, alt });\n};\n\nRuler.prototype.__compile__ = function () {\n  const self = this;\n  const chains = [''];\n\n  // Collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return; }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) &lt; 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n\n  // Build the cache\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return; }\n\n      if (chain &amp;&amp; rule.alt.indexOf(chain) &lt; 0) { return; }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n\n// Create a new Ruler instance\nconst ruler = new Ruler();\n\n// Add rules with alternative names\nruler.addRule(\"bold\", true, function (str) { return `**${str}**`; }, [\"b\"]);\nruler.addRule(\"italic\", true, function (str) { return `*${str}*`; }, [\"i\"]);\nruler.addRule(\"underline\", false, function (str) { return `__${str}__`; }, [\"u\"]);\n\n// Compile the cache\nruler.__compile__();\n\n// Display the cache\nconsole.log(ruler.__cache__);\n```\n\n### **Step-by-Step Breakdown:**\n\n1. **Initial Setup**:\n   - A new `Ruler` instance is created: `const ruler = new Ruler()`.\n   - Three rules are added to the `ruler` object:\n     - The `bold` rule, enabled, with alternative name `\"b\"`.\n     - The `italic` rule, enabled, with alternative name `\"i\"`.\n     - The `underline` rule, disabled, with alternative name `\"u\"`.\n\n2. **Calling `__compile__`**:\n   - When `ruler.__compile__()` is called, the following steps occur:\n     - `chains` is initially `['']`, which is the default chain.\n     - It collects the alternative names `\"b\"` and `\"i\"` from the rules and adds them to `chains`. The final `chains` array is `['', 'b', 'i']`.\n   \n3. **Building the Cache**:\n   - The `__cache__` object is then populated:\n     - For chain `''` (default chain):\n       - It includes the `bold` and `italic` rules because they don’t require any alternative names.\n     - For chain `'b'` (the alternative name for `bold`):\n       - It includes the `bold` rule because its `alt` array includes `'b'`.\n     - For chain `'i'` (the alternative name for `italic`):\n       - It includes the `italic` rule because its `alt` array includes `'i'`.\n\n4. **Resulting Cache**:\n   The final `__cache__` object will look like this:\n\n```js\n{\n  \"\": [ [Function: bold], [Function: italic] ],\n  \"b\": [ [Function: bold] ],\n  \"i\": [ [Function: italic] ]\n}\n```\n\n### **Summary**:\nThe `__compile__` method efficiently builds a **lookup cache** (`__cache__`) for rules based on their names and alternative names. This cache helps speed up rule application by allowing the system to quickly find which functions should be executed for a particular rule or chain. The method ensures that only enabled rules are included and handles both default and alternative rule names.</md></sn><sn><md>### **Ruler.at()**\n---\n```js\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function &amp; options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  const index = this.__find__(name)\n  const opt = options || {}\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name) }\n\n  this.__rules__[index].fn = fn\n  this.__rules__[index].alt = opt.alt || []\n  this.__cache__ = null\n}\n```\n\n### **Explanation:**\n\nThe `Ruler.prototype.at` method allows you to replace an existing rule by its name with a new function (`fn`) and optional settings (`options`).\n\n### **Parameters:**\n- **`name`** (`String`): The name of the rule you want to replace.\n- **`fn`** (`Function`): The new rule function that should replace the existing one.\n- **`options`** (`Object`, optional): Additional settings for the new rule. Specifically, the `alt` property is used to specify alternative chain names for the rule.\n\n### **Steps in the Method:**\n\n1. **Find the Rule by Name**:\n   The method calls the `__find__` function to search for the rule by its name. It returns the index of the rule if found, or `-1` if not found.\n\n2. **Error Handling**:\n   If the rule is not found (i.e., the index is `-1`), it throws an error saying \"Parser rule not found\" along with the rule name.\n\n3. **Update the Rule**:\n   If the rule is found, the method updates the rule's function (`fn`) and its alternative names (`alt`) based on the provided options.\n\n4. **Reset the Cache**:\n   After modifying the rule, the method resets the `__cache__` to `null`. This is necessary because the rule's change may affect the structure of the rules, and the cache needs to be rebuilt.\n\n### **Options:**\n- **`alt`** (`Array`, optional): Specifies an array of alternate chain names for the rule. This helps link the rule to alternative names, allowing it to be triggered by other chains.\n\n### **Example Usage:**\n\n#### Example 1: Replace a Rule in `markdown-it`\n\n```js\nvar md = require('markdown-it')();\n\n// Original rule: 'replacements' rule (for typographic replacements in markdown)\nmd.core.ruler.at('replacements', function replace(state) {\n  // Custom implementation for replacements\n  console.log(\"Custom replacement function\");\n  // ... implement the custom logic\n});\n```\n\nHere:\n- The `replacements` rule is replaced with a custom function (`replace`).\n- `md.core.ruler.at` is used with the rule name (`'replacements'`), the new function (`replace`), and optional settings (not provided in this example).\n\n#### Example 2: Replace Rule with New Options\n\n```js\nvar md = require('markdown-it')();\n\n// Replacing the 'bold' rule with a new function and setting an alternative chain 'b' for bold\nmd.core.ruler.at('bold', function newBoldRule(str) {\n  return `**${str}**`;  // Custom bold formatting\n}, {\n  alt: ['b']  // Adding 'b' as an alternative chain for the bold rule\n});\n```\n\nHere:\n- The `bold` rule is replaced with a new function (`newBoldRule`).\n- The `alt` option is used to make the rule accessible by the alternative chain `\"b\"`.\n\n### **Detailed Walkthrough of Code:**\n\n1. **Find the Rule**:\n   ```js\n   const index = this.__find__(name);\n   ```\n   This finds the index of the rule in the `__rules__` array by its name. If the rule does not exist, `__find__` returns `-1`.\n\n2. **Handle Missing Rule**:\n   ```js\n   if (index === -1) { throw new Error('Parser rule not found: ' + name); }\n   ```\n   If the rule is not found, an error is thrown.\n\n3. **Update the Rule**:\n   ```js\n   this.__rules__[index].fn = fn;\n   this.__rules__[index].alt = opt.alt || [];\n   ```\n   This updates the rule at the found index:\n   - It sets the new rule function (`fn`).\n   - It updates the `alt` array with the new alternative names provided in `options.alt` (if any). If no alternatives are provided, it defaults to an empty array `[]`.\n\n4. **Reset Cache**:\n   ```js\n   this.__cache__ = null;\n   ```\n   The cache is reset because the rule has changed, and the cache needs to be rebuilt with the new rule function.\n\n### **Summary:**\n- The `at` method allows you to replace an existing rule by name with a new function and options.\n- You can update the rule's behavior and add alternative chain names using the `alt` property.\n- The method ensures that the cache is cleared, as the structure of the rules may have changed and needs to be recompiled.\n\nThis method is useful when you need to customize or extend the behavior of existing parser rules in a flexible and modular way.</md></sn><sn><md>### **Ruler.before()**\n---\n\n```js\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  const index = this.__find__(beforeName)\n  const opt = options || {}\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName) }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt.alt || []\n  })\n\n  this.__cache__ = null\n}\n```\n\n### **Explanation:**\n\nThe `Ruler.prototype.before` method allows you to insert a new rule into the rules chain before an existing rule. This is useful when you want to add functionality at a specific point in the rule processing order.\n\n### **Parameters:**\n1. **`beforeName`** (`String`): The name of the rule that the new rule should be added before. The new rule will be inserted right before this rule in the processing order.\n2. **`ruleName`** (`String`): The name for the new rule that is being added.\n3. **`fn`** (`Function`): The function implementing the new rule. This function will be executed during the processing of the markdown.\n4. **`options`** (`Object`, optional): Additional options for the new rule. Specifically, the `alt` property can be used to define alternate chain names.\n\n### **Steps in the Method:**\n\n1. **Find the Rule by Name**:\n   The method starts by calling `__find__` to search for the index of the rule named `beforeName`. This will determine where to insert the new rule in the rules chain.\n\n2. **Error Handling**:\n   If the `beforeName` rule is not found (i.e., if `index` is `-1`), an error is thrown indicating that the specified parser rule was not found.\n\n3. **Insert the New Rule**:\n   If the rule is found, the method uses the `splice()` function to insert the new rule before the `beforeName` rule. The new rule is an object that contains:\n   - `name`: The name of the new rule (`ruleName`).\n   - `enabled`: A boolean indicating whether the rule is enabled (`true` by default).\n   - `fn`: The function implementing the rule.\n   - `alt`: An array of alternate chain names, taken from the `options.alt` (if provided).\n\n4. **Reset the Cache**:\n   The method sets `__cache__` to `null` to invalidate the current cache. This ensures that the cache will be rebuilt the next time it's needed to reflect the new rule order.\n\n### **Options:**\n- **`alt`** (`Array`, optional): An array of alternate chain names. This allows the rule to be triggered by multiple chain names.\n\n### **Example Usage:**\n\n#### Example 1: Adding a Rule Before an Existing Rule\n\n```js\nvar md = require('markdown-it')();\n\n// Add a new rule 'my_rule' before the 'paragraph' rule\nmd.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n  // Custom rule logic here\n  console.log(\"My custom rule before paragraph.\");\n  // Custom logic for markdown parsing\n});\n```\n\nIn this example:\n- The new rule `my_rule` is added before the `paragraph` rule in the parsing chain.\n- The new rule's function (`replace`) is executed whenever the rule is triggered.\n\n#### Example 2: Using Alternate Chains\n\n```js\nvar md = require('markdown-it')();\n\n// Add a new rule 'my_rule' before the 'paragraph' rule, with an alternate chain 'p'\nmd.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n  // Custom rule logic\n  console.log(\"My custom rule before paragraph.\");\n}, {\n  alt: ['p']  // Adding 'p' as an alternative chain name\n});\n```\n\nIn this example:\n- The rule is added before the `paragraph` rule and is accessible by both `\"paragraph\"` and `\"p\"` chains.\n- The `alt` option allows the rule to also be triggered when the chain `\"p\"` is used.\n\n### **Detailed Walkthrough of Code:**\n\n1. **Find the Rule**:\n   ```js\n   const index = this.__find__(beforeName);\n   ```\n   This calls the `__find__` function to locate the index of the rule named `beforeName` in the rules array. If the rule is not found, the method throws an error.\n\n2. **Handle Missing Rule**:\n   ```js\n   if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }\n   ```\n   If the `beforeName` rule is not found, an error is thrown with the message \"Parser rule not found: `beforeName`\".\n\n3. **Insert the New Rule**:\n   ```js\n   this.__rules__.splice(index, 0, {\n     name: ruleName,\n     enabled: true,\n     fn,\n     alt: opt.alt || []\n   });\n   ```\n   The `splice()` method is used to insert the new rule at the `index` found earlier. The new rule object is created with:\n   - The name of the new rule (`ruleName`).\n   - The function (`fn`) that defines the rule's behavior.\n   - The `alt` property (an empty array `[]` if no alternatives are provided).\n\n4. **Reset Cache**:\n   ```js\n   this.__cache__ = null;\n   ```\n   After adding the new rule, the cache is invalidated by setting `__cache__` to `null`. This ensures that the cache is rebuilt with the new rule order.\n\n### **Summary:**\n- The `before` method allows you to insert a new rule before an existing one in the parsing chain.\n- You can provide an optional `alt` property to specify alternate names for the rule.\n- After adding the new rule, the cache is reset to reflect the changes.\n- This method is useful for modifying the parsing order or adding new behavior before certain rules in a flexible and modular way.</md></sn><sn><h3>Ruler.after()</h3><pre data-v=\"javascript\">/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  const index = this.__find__(afterName)\n  const opt = options || {}\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName) }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt.alt || []\n  })\n\n  this.__cache__ = null\n}\n</pre></sn><sn><md>### **Ruler.push()**\n---\n```js\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  const opt = options || {}\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt.alt || []\n  })\n\n  this.__cache__ = null\n}\n```\n\n### **Explanation:**\n\nThe `Ruler.prototype.push` method is used to add a new rule to the **end of the rule chain**. This method is helpful when you want to append a new rule after all existing rules without changing the order of the existing rules.\n\n### **Parameters:**\n1. **`ruleName`** (`String`): The name of the new rule that will be added to the end of the chain.\n2. **`fn`** (`Function`): The function that defines the behavior of the rule. This function will be executed as part of the parsing process.\n3. **`options`** (`Object`, optional): Additional options for the new rule. The main option here is `alt`, which allows you to specify alternate chain names for the rule.\n\n### **Steps in the Method:**\n\n1. **Set Options**:\n   The method checks if options were provided and defaults to an empty object (`{}`) if no options are given. Specifically, it checks for the `alt` property, which is an array of alternate chain names.\n\n2. **Add Rule to the End**:\n   The method then pushes a new rule object to the `__rules__` array. The new rule object contains:\n   - `name`: The name of the new rule (`ruleName`).\n   - `enabled`: A boolean flag set to `true` by default, indicating that the rule is enabled.\n   - `fn`: The function (`fn`) that defines the rule's behavior.\n   - `alt`: An array of alternate chain names (`opt.alt`), which can be provided in the options (defaults to an empty array if not provided).\n\n3. **Reset Cache**:\n   After adding the new rule, the method sets `__cache__` to `null`, invalidating the existing cache. This ensures that the cache is rebuilt the next time it is needed, reflecting the updated rule chain.\n\n### **Options:**\n- **`alt`** (`Array`, optional): An array of alternate chain names. This allows the rule to be triggered by multiple chain names, making it more flexible.\n\n### **Example Usage:**\n\n#### Example 1: Add a Rule to the End of the Chain\n\n```js\nvar md = require('markdown-it')();\n\n// Add a new rule 'my_rule' to the end of the rule chain\nmd.core.ruler.push('my_rule', function replace(state) {\n  // Custom rule logic here\n  console.log(\"My custom rule at the end of the chain.\");\n  // Custom logic for markdown parsing\n});\n```\n\nIn this example:\n- The new rule `my_rule` is added to the end of the parsing chain.\n- The function (`replace`) is executed whenever the rule is triggered during the markdown parsing.\n\n#### Example 2: Using Alternate Chains\n\n```js\nvar md = require('markdown-it')();\n\n// Add a new rule 'my_rule' to the end of the rule chain, with an alternate chain 'my_alt_chain'\nmd.core.ruler.push('my_rule', function replace(state) {\n  // Custom rule logic\n  console.log(\"My custom rule with alternate chain.\");\n}, {\n  alt: ['my_alt_chain']  // Adding 'my_alt_chain' as an alternative chain name\n});\n```\n\nIn this example:\n- The rule is added to the end of the chain and is also accessible by the alternate chain name `\"my_alt_chain\"`.\n- The `alt` option allows the rule to be triggered by the alternate chain as well.\n\n### **Detailed Walkthrough of Code:**\n\n1. **Set Options**:\n   ```js\n   const opt = options || {};\n   ```\n   This checks if options are provided. If not, it defaults to an empty object (`{}`). The `alt` property will be used later to specify alternate chains for the rule.\n\n2. **Add Rule to the End**:\n   ```js\n   this.__rules__.push({\n     name: ruleName,\n     enabled: true,\n     fn,\n     alt: opt.alt || []\n   });\n   ```\n   This line adds the new rule to the end of the `__rules__` array. The rule object contains:\n   - `name`: The name of the new rule (`ruleName`).\n   - `enabled`: A boolean flag set to `true`, indicating that the rule is enabled by default.\n   - `fn`: The function (`fn`) that defines the rule's behavior.\n   - `alt`: An array of alternate chain names (`opt.alt`). If no alternate names are provided, it defaults to an empty array `[]`.\n\n3. **Reset Cache**:\n   ```js\n   this.__cache__ = null;\n   ```\n   The cache is reset by setting `__cache__` to `null`. This ensures that the cache is rebuilt, as the rule chain has changed with the addition of the new rule.\n\n### **Summary:**\n- The `push` method allows you to add a new rule to the **end** of the rule chain.\n- You can provide an optional `alt` array in the `options` to specify alternate names for the rule.\n- After adding the new rule, the cache is reset to ensure that the updated rule chain is used for future parsing.\n\nThis method is useful when you want to append a rule at the end of the processing chain without affecting the existing rules or their order.</md></sn><sn><md>### **Ruler.enable()**\n---\n```js\n/**\n * Ruler.enable(list [, ignoreInvalid]) -&gt; Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [list] }\n\n  const result = []\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    const idx = this.__find__(name)\n\n    if (idx &lt; 0) {\n      if (ignoreInvalid) { return }\n      throw new Error('Rules manager: invalid rule name ' + name)\n    }\n    this.__rules__[idx].enabled = true\n    result.push(name)\n  }, this)\n\n  this.__cache__ = null\n  return result\n}\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [list] }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false })\n\n  this.enable(list, ignoreInvalid)\n}\n```\n\n### **Explanation:**\n\nThe `Ruler.prototype.enable` and `Ruler.prototype.enableOnly` methods are used to **enable** or **enable only specific rules** in the rule chain. Let's go through each method step by step.\n\n---\n\n### **1. `Ruler.prototype.enable`**\n\nThis method is used to **enable specific rules** by their names. You provide a list of rule names, and the method will enable those rules if they exist.\n\n#### **Parameters:**\n- **`list`** (`String|Array`): A single rule name or an array of rule names that you want to enable.\n- **`ignoreInvalid`** (`Boolean`, optional): If `true`, the method will silently skip over any invalid rule names that are not found. If `false` (default), an error is thrown when a rule name is not found.\n\n#### **Steps:**\n1. **Ensure `list` is an Array**:\n   ```js\n   if (!Array.isArray(list)) { list = [list] }\n   ```\n   If the `list` parameter is not already an array, it is converted to an array. This allows for handling both single rule names and arrays of rule names in the same way.\n\n2. **Iterate Over the List**:\n   ```js\n   list.forEach(function (name) { ... }, this)\n   ```\n   The method loops through each rule name in the `list`.\n\n3. **Find the Rule by Name**:\n   ```js\n   const idx = this.__find__(name)\n   ```\n   For each rule name, it calls the `__find__` method to search for the index of the rule in the internal `__rules__` array. If the rule is found, `idx` will be the index of the rule.\n\n4. **Error Handling**:\n   ```js\n   if (idx &lt; 0) {\n     if (ignoreInvalid) { return }\n     throw new Error('Rules manager: invalid rule name ' + name)\n   }\n   ```\n   If the rule is not found (i.e., `idx` is `-1`), the method either skips the rule (if `ignoreInvalid` is `true`) or throws an error if `ignoreInvalid` is `false`.\n\n5. **Enable the Rule**:\n   ```js\n   this.__rules__[idx].enabled = true\n   result.push(name)\n   ```\n   If the rule is found, it enables the rule by setting its `enabled` property to `true` and adds the rule's name to the `result` array.\n\n6. **Reset the Cache**:\n   ```js\n   this.__cache__ = null\n   ```\n   After enabling the rule, the cache is invalidated (`__cache__` is set to `null`), so the rule chain will be recalculated the next time it's needed.\n\n7. **Return the List of Enabled Rules**:\n   ```js\n   return result\n   ```\n   The method returns an array of the names of the rules that were successfully enabled.\n\n#### **Example Usage:**\n\n```js\nvar md = require('markdown-it')();\n\n// Enable 'rule1' and 'rule2'\nmd.core.ruler.enable(['rule1', 'rule2']);\n```\n\nIn this example, the `enable` method will enable the rules named `'rule1'` and `'rule2'`. If any rule is not found and `ignoreInvalid` is `false`, an error will be thrown.\n\n---\n\n### **2. `Ruler.prototype.enableOnly`**\n\nThis method enables only the rules specified in the `list` and **disables all other rules**. It's like a whitelist that ensures only the rules in the list are active, and all others are disabled.\n\n#### **Parameters:**\n- **`list`** (`String|Array`): A single rule name or an array of rule names to enable.\n- **`ignoreInvalid`** (`Boolean`, optional): If `true`, it silently ignores invalid rule names. If `false` (default), it throws an error for any rule not found.\n\n#### **Steps:**\n1. **Ensure `list` is an Array**:\n   ```js\n   if (!Array.isArray(list)) { list = [list] }\n   ```\n   Just like in the `enable` method, it ensures that `list` is an array.\n\n2. **Disable All Rules**:\n   ```js\n   this.__rules__.forEach(function (rule) { rule.enabled = false })\n   ```\n   The method first disables all the rules in the `__rules__` array by setting the `enabled` property of each rule to `false`.\n\n3. **Enable Specific Rules**:\n   ```js\n   this.enable(list, ignoreInvalid)\n   ```\n   Then, it calls the `enable` method to enable only the rules specified in `list`.\n\n#### **Example Usage:**\n\n```js\nvar md = require('markdown-it')();\n\n// Enable only 'rule1' and 'rule2', and disable all other rules\nmd.core.ruler.enableOnly(['rule1', 'rule2']);\n```\n\nIn this example, the `enableOnly` method will:\n- Disable all rules first.\n- Enable only `'rule1'` and `'rule2'`.\n  \nIf any rule in the `list` is not found and `ignoreInvalid` is `false`, an error will be thrown.\n\n---\n\n### **Summary of Key Points:**\n\n- **`enable`**: Enables the rules specified by their names in the list and returns the names of successfully enabled rules. It throws an error for any rule not found unless `ignoreInvalid` is `true`.\n- **`enableOnly`**: Enables only the rules specified by their names in the list and disables all other rules. It internally calls `enable` to handle the enabling of the rules.\n- Both methods allow you to provide a list of rule names or a single rule name, and you can optionally handle errors with the `ignoreInvalid` parameter.</md></sn><sn><h3>Ruler.disable()</h3><pre data-v=\"javascript\">/**\n * Ruler.disable(list [, ignoreInvalid]) -&gt; Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [list] }\n\n  const result = []\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    const idx = this.__find__(name)\n\n    if (idx &lt; 0) {\n      if (ignoreInvalid) { return }\n      throw new Error('Rules manager: invalid rule name ' + name)\n    }\n    this.__rules__[idx].enabled = false\n    result.push(name)\n  }, this)\n\n  this.__cache__ = null\n  return result\n}\n</pre></sn><sn><md>### **Ruler.getRules()**\n---\n\n\nThe `getRules` method in the `Ruler` class is used to retrieve an array of active functions (rules) for a given **chain name**. If the rules are not cached, it compiles the rules first and then returns the active ones.\n\n#### **Code Explanation:**\n\n```js\n/**\n * Ruler.getRules(chainName) -&gt; Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__()\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || []\n}\n\nexport default Ruler\n```\n\n### **Breakdown of the Method:**\n\n1. **Check if Cache Exists:**\n   ```js\n   if (this.__cache__ === null) {\n     this.__compile__()\n   }\n   ```\n   - **What this does**: It first checks if the `__cache__` is `null`. If it is, it means the rule chains have not yet been compiled and cached. In this case, it calls the `__compile__` method to compile and cache the rules.\n   - **Why it's necessary**: Caching the rule chains allows for faster access on subsequent calls to `getRules`, as the system avoids recalculating the rule chain every time.\n\n2. **Return Active Rules for the Given Chain:**\n   ```js\n   return this.__cache__[chainName] || []\n   ```\n   - **What this does**: After ensuring that the cache exists, it looks up the active rules for the specified `chainName` in the cached data (`__cache__`). \n   - If rules for the specified `chainName` are found, it returns those rules as an array. \n   - If no rules are found for the given `chainName` (meaning the chain is empty or no rules are active), it returns an empty array `[]`.\n   \n   - **Note**: The `chainName` could be an empty string (`''`), which is the default chain name. The check `this.__cache__[chainName] || []` ensures that even if no rules exist for a chain, an empty array is returned instead of `undefined`.\n\n---\n\n### **Example Usage:**\n\nSuppose you have an instance of the `Ruler` class and some rules have been added to different chains.\n\n```js\nvar md = require('markdown-it')();  // Create a Markdown-It instance\n\n// Example: Assuming you have rules added to 'paragraph' chain\nmd.core.ruler.push('my_rule', function replace(state) {\n  // Rule implementation...\n});\n\n// Retrieve active rules for the 'paragraph' chain\nconst rules = md.core.ruler.getRules('paragraph');\nconsole.log(rules);  // Output: Array of functions for the 'paragraph' chain\n```\n\nIn this example:\n1. You use `md.core.ruler.push` to add a rule to the `paragraph` chain.\n2. When you call `getRules('paragraph')`, the method checks if the rules are cached. If not, it will compile and cache the rules.\n3. Then, it will return an array of active functions (rules) associated with the `'paragraph'` chain.\n\nIf the chain name does not exist or no rules have been added to the chain, it will return an empty array.\n\n---\n\n### **Key Points:**\n- **Caching**: `getRules` ensures efficient access to rule chains by caching them.\n- **Monomorphic Signature**: The method's signature is designed to always take a `chainName` and return an array, even if no rules exist for the given chain.\n- **Fallback for Empty Chains**: If no rules exist for a given chain (or the rules are disabled), an empty array is returned instead of `null` or `undefined`.\n</md></sn>","topic_id":941,"last_visited":"2025-04-25T12:34:56.016Z"}],"chapter_id":244}],"author":{"login":"Nh-emon","id":146737722,"node_id":"U_kgDOCL8KOg","avatar_url":"https://avatars.githubusercontent.com/u/146737722?v=4","gravatar_id":"","url":"https://api.github.com/users/Nh-emon","html_url":"https://github.com/Nh-emon","followers_url":"https://api.github.com/users/Nh-emon/followers","following_url":"https://api.github.com/users/Nh-emon/following{/other_user}","gists_url":"https://api.github.com/users/Nh-emon/gists{/gist_id}","starred_url":"https://api.github.com/users/Nh-emon/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Nh-emon/subscriptions","organizations_url":"https://api.github.com/users/Nh-emon/orgs","repos_url":"https://api.github.com/users/Nh-emon/repos","events_url":"https://api.github.com/users/Nh-emon/events{/privacy}","received_events_url":"https://api.github.com/users/Nh-emon/received_events","type":"User","site_admin":false,"name":"Emon","company":null,"blog":"","location":null,"email":null,"hireable":null,"bio":null,"twitter_username":null,"public_repos":20,"public_gists":0,"followers":1,"following":1,"created_at":"2023-10-02T13:07:54Z","updated_at":"2024-08-06T16:33:13Z"},"created_on":"2025-02-02T14:33:56.844Z","is_private":false,"folder":"Programming","web_url":"https://qdock.free.nf","last_update_on":"2025-04-25T12:35:00.946Z"}